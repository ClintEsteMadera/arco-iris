\section{Extensión a Rainbow: Arco Iris}

	\subsection{Idea Básica}

		Como ya se ha comentado anteriormente, la idea de este trabajo es extender el \emph{framework} ``Rainbow'' para poder
		lograr un mecanismo de auto reparación más flexible y con mayor capacidad expresiva, con el objetivo de proveer mayor
		visibilidad a los \emph{stakeholders} de la aplicación sobre dicho proceso, permitiendoles así involucrarse en la
		definición de escenarios de uso real del sistema y su relación con los atributos de calidad requeridos para el mismo.
		La solución intenta involucrarlos también en la definición de prioridades de los escenarios y/o estrategias a
		considerar en la auto reparación del sistema cuando uno de los escenarios no se cumple.

		A fin de lograr lo antedicho, se consideró necesario extender el framework Rainbow, cuyo código se encuentra escrito
		mayormente en el lenguaje de programación Java.
		
		Los integrantes del grupo ABLE \cite{ABLE}, que son quienes poseen propiedad intelectual sobre el \emph{framework}, no
		sólo decidieron proveer el código fuente completo para poder realizar esta extensión, sino que estuvieron dispuestos
		en todo momento a colaborar, responder dudas e inquietudes, hacer sugerencias, etc.

		\subsubsection{Rainbow ``out of the box''}
		
			El primer paso fue inspeccionar el código del framework y leer su documentación (no muy abundante, por cierto).
			Luego de ese primer paso, se tuvo una buena noción sobre el funcionamiento de Rainbow y sus componentes principales
			de arquitectura, las cuales se pueden observar en el siguiente diagrama de colaboración de objetos:
			
			\begin{center}
				\includegraphics[width=1.00\textwidth]{images/Rainbow_Architecture.png}
			\end{center}
			
			Observamos que, en Rainbow, una persona con rol de arquitecto (o similar) es el encargado de configurar al framework
			utilizando, básicamente, dos vías:
			\begin{enumerate}
				\item la creación de un modelo de la arquitectura del sistema al cual Rainbow va a adaptar. Dicho modelo se
				especifica utilizando el estilo C\&C y el lenguaje de descripción de arquitecturas ACME, anteriormente descripto en
				el presente trabajo. Los componentes y conectores poseen propiedades (con valores asociados), constraints y también
				existe la posibilidad de especificar invariantes a nivel de sistema o sub sistema. Dichos invariantes serán
				evaluados periódicamente por Rainbow para verificar que el sistema funcione dentro de los límites determinados como
				normales.
				\item la generación de un conjunto de archivos de configuración que especifican diversos aspectos relacionados con
				la definición del sistema a auto-reparar, como por ejemplo: ubicación física del archivo ACME con la arquitectura
				del sistema a adaptar, archivos de tácticas y estrategias de reparación (estos escritos en un lenguaje de scripting
				llamado ``stitch''), datos para la configuración de la conexión de Rainbow con el sistema en \emph{runtime}, etc. 
			\end{enumerate}
	
			Podemos ver también en el gráfico anterior, cómo los denominados ``Probes'' son los componentes designados en Rainbow
			para interactuar directamente con el sistema a adaptar (``Target System''), obteniendo así información relevante a
			los fines de la auto-reparación del mismo. Dicha información no será interpretada dentro de los ``probes'' sino que
			ellos delegaran dicha tarea a los denominados ``Gauges''. Estos componentes son los encargados de entender la
			información provista por los gauges y traducirla a pares \verb@<Propiedad, Valor>@ dónde \verb@Propiedad@ es el
			nombre de una propiedad correspondiente a un componente (o conector o subsistema, etc\ldots) de la arquitectura del
			sistema a adaptar; y \verb@Valor@ es ni más ni menos que el nuevo valor que posee dicha propiedad.
			
			Normalmente, existe un par $<$Gauge, Probe$>$ distinto (a nivel implementativo son clases Java) por cada tipo
			relevante de \emph{concern} que interese ser monitoreado en tiempo de ejecución. Un ejemplo de \emph{concern} podría
			ser: ``tiempo de respuesta experimentado por el usuario'', el cual es un \emph{concern} relacionado al atributo de
			calidad \emph{performance}.
			
			Asociado al tipo de componente ``Gauge'', se encuentra el ``Gauge Coordinator'' el cual, tal como su nombre lo indica,
			coordina la información provista por todos los Gauges e invoca a la operación ``update property" del denominado
			``Rainbow Model''.
			
			El Rainbow Model, componente clave en la arquitectura del \emph{framework}, tiene, entre otras cosas, la
			responsabilidad de saber como impactar el cambio de los valores de la propiedades de los componentes, conectores,
			sub-sistemas o sistemas del modelo de arquitectura de la aplicación a adaptar. También sabe verificar si se ha violado
			alguna de las constraints presentes en el modelo de arquitectura con el cual el \emph{framework} ha sido inicializado.
			
			Por otra parte, existe otro componente llamado ``Architecture Evaluator'', el cual consulta periódicamente a
			\emph{Rainbow Model} sobre si se ha violado alguna constraint. En ese caso, el \emph{Architecture Evaluator} dispara
			el mecanismo de adaptación invocando al ``Adaptation Manager'' (junto con el Rainbow Model, el componente más
			importante de todos).
			
			El \emph{Adaptation Manager} sigue una lógica un tanto compleja (que luego explicaremos en detalle) para determinar la
			mejor estrategia de reparación a realizar y luego, mediante ``Effectors'' (no mostrados en el gráfico anterior por
			claridad), las estrategias llegan a impactarse, en tiempo de ejecución, en el sistema a ser adaptado y siempre con la
			intención de restituir los invariantes planteados para el sistema en cuestión.
			
			Pues bien, a continuación veremos cómo queda el sistema conceptualmente luego de incorporar las extensiones
			planteadas en el presente trabajo (a las cuales denominamos ``Arco Iris'').
			
			\begin{center}
				\includegraphics[width=1.00\textwidth]{images/Rainbow_Architecture_With_Scenarios.png}
			\end{center}
	
			\todo{JONY: Completar explicación sobre los agregados de Rainbow}
			
			\todo{JONY: Introducir el diagrama de clases}
	
			\begin{center}
				\includegraphics[width=1.00\textwidth]{images/Arco_Iris_Model.png}
			\end{center}
	
			\todo{JONY: Comentar sobre el diagrama de clases y chau.}

	\subsection{ATAM para Flexibilizar la Auto Reparación}

		Actualmente Rainbow posee conocimiento sobre la arquitectura del sistema a adaptar mediante un modelo de su arquitectura
		expresado en el lenguaje de descripción de arquitecturas Acme. Uno de los objetivos de Arco Iris es extender el
		conocimiento que el \emph{framework} tiene sobre el sistema en general. Este nuevo conocimiento será utilizado por Arco
		Iris en tiempo de ejecución para refinar y optimizar la auto reparación.

		Esencialmente, se incluye información sobre los atributos de calidad del sistema que son relevantes para los
		\emph{stakeholders} del sistema en tiempo de ejecución. Se permite, por ejemplo, poder describir la importancia relativa
		de la \emph{performance}, la usabilidad, la disponibilidad, etc.; definiendo así una serie de \emph{tradeoffs} entre
		distintos atributos de calidad requeridos por el sistema. El enfoque propuesto para lograr esto consiste en especificar
		\textbf{Escenarios de Atributos de Calidad} \cite{Scenarios} (de ahora en más, simplemente ``Escenarios''), tal cual
		fueron descriptos anteriormente, aunque con algunos agregados de información orientados a la auto reparación.

		Un Escenario modela una situación concreta y real de uso del sistema ante la cual el mismo debe comportarse de una
		manera esperada. Los escenarios contienen la siguiente información:
		\begin{itemize}
			\item Fuente del Estímulo
			\item Estímulo
			\item Artefacto
			\item Entorno
			\item Respuesta
			\item Cuantificación de la Respuesta
		\end{itemize}

		Supongamos que tenemos el siguiente escenario:

		\begin{quote}
			Un proceso del sistema recibe un mensaje externo no anticipado durante un modo de operación normal. El
			proceso informa al operador y continúa su operación sin caídas.
		\end{quote}

		Veamos cómo se desgloza la información de este escenario según la descomposición antes mencionada:

		\begin{itemize}
			\item Fuente: Sistema externo
			\item Estímulo: Mensaje no anticipado
			\item Entorno: Operación normal
			\item Artefacto: Proceso interno
			\item Respuesta: Informar al operador y seguir operando
			\item Medición de la respuesta: sin caídas (downtime)
		\end{itemize}

		\indent De todos estos atributos, el \textbf{Estímulo}, el \textbf{Artefacto}, el \textbf{Entorno} y la
		\textbf{Cuantificación de la Respuesta} son particularmente relevantes a los fines de establecer información útil para
		el mecanismo de auto reparación. A lo largo de las próximas subsecciones mostraremos cómo Arco Iris hace uso de esta
		información para modificar, optimizar y refinar la auto reparación realizada por Rainbow.


		\subsubsection{El Estímulo en la Auto Reparación}

			El \textbf{Estímulo} de un escenario normalmente se asocia a un evento desencadenado en el sistema por la acción del
			algún  usuario del mismo. Dicho evento es el punto de entrada del escenario, el disparador (interno o externo) que
			inicia la interacción con el sistema, y más particularmente, con el artefacto del escenario en cuestión. Por ejemplo,
			supongamos que en un sistema de administración de cuentas bancarias un cliente intenta hacer una transferencia,
			en este caso la fuente del estímulo sería el cliente y el estímulo en sí mismo sería realizar transferencia.

			Saber cual es el estímulo de cada escenario permite optimizar la auto reparación, ya que habiendo ocurrido determinado
			estímulo, Arco Iris podrá detectar cuáles son los potenciales escenarios que pueden verse afectados y trabajará
			verificando dicho subconjunto, evitando así chequeos innecesarios.

			Cabe destacar que también se ofrece la posibilidad de que el estímulo sea ``cualquiera'', es decir, que
			el escenario aplique siempre, independientemente del estímulo que haya impactado al sistema. Esto puede ser muy útil
			para casos más genéricos, por ejemplo, si se requiere que el tiempo de respuesta experimentado por el usuario nunca
			sobrepase determinado umbral sin importar la funcionalidad del sistema que el usuario esté utilizando. De no configurar
			ningún estímulo en ningún escenario, Arco Iris verificará que se satisfagan todos los escenarios en cada iteración.
			Esta es la manera en que trabaja Rainbow.

			Entonces, a diferencia de Rainbow, Arco Iris permite refinar el conjunto de escenarios que pudieron verse afectados por
			medio del estímulo que ocasionó el problema, reduciendo así la cantidad de escenarios a verificar y sobre todo la
			cantidad de estrategias a evaluar para intentar resolverlo, mientras que en Rainbow (en Arco Iris se mantiene esta
			posibilidad), la única manera de limitar el uso de las estrategias es agregar restricciones en la misma estrategia,
			siendo esto algo muy técnico y quedando fuera del alcance de la mayor parte de los \emph{stakeholders} del sistema, por
			ejemplo, para que una estrategia que soluciona problemas de performance no sea tenida en cuenta al reparar un escenario
			relacionado a un atributo de calidad distinto, como por ejemplo el costo, debe agregarse una precondición como la
			siguiente en la estrategia:

			{\scriptsize
			\begin{verbatim}
    strategy SimpleReduceResponseTime
      [ styleApplies && responseTimeConstraintViolation ] {
      ...
    }
			\end{verbatim}
			}

			Donde \emph{responseTimeConstraintViolation} es un predicado que permite determinar si existe algún cliente cuyo tiempo
			de respuesta haya sobrepasado el máximo tiempo de respuesta permitido:

			{\scriptsize
			\begin{verbatim}
    define boolean responseTimeConstraintViolation =
      exists c : T.ClientT in M.components | c.experRespTime > M.MAX_RESPTIME;
			\end{verbatim}
			}

			Es importante remarcar que, en caso de que el problema que se está intentando reparar no esté relacionado con la
			performance, Rainbow deberá de todos modos chequear el tiempo de respuesta de todos los clientes, mientras que en
			Arco Iris existe la posibilidad de evitarlo al configurar correctamente los estímulos de cada escenario.

			Adentrándonos ya en la implementación, tengamos en cuenta que el estímulo era un concepto inexistente en Rainbow, por lo
			cual en Arco Iris debimos modificar algunos de los componentes existentes para poder tomar conocimiento de qué estímulo
			desencadenaba una determinada acción, así como también para interpretar luego dicha información.
			Dado a que Rainbow permite trabajar en modo simulación, fue necesario implementar dos soluciones para poder utilizar el
			concepto de estímulo en ambos escenarios.

			Al trabajar en el modo de simulación, dado que no participan ni los \emph{probes} ni los \emph{gauges}, fue necesario
			implementar un mecanismo ad hoc, que consistió en barrer todos los escenarios al iniciar Arco Iris, recogiendo en un
			mapa la información de qué estímulos eran los posibles responsables de las modificaciones causadas sobre cada una de las
			propiedades de los artefactos configurados en los escenarios. A continuación mostramos el concepto de dicha
			implementación en pseudocódigo:

			\todo{Elegir cual es mejor!}

			{\scriptsize
			\begin{verbatim}
				por cada escenario habilitado
				  por cada constraint del escenario
				    por cada propiedad involucrada en el constraint
				      escenariosPorEstimulo.agregar(escenario.estimulo, escenario)
				      estimulosPorPropiedades.agregar(propiedad, escenario.estimulo)
			\end{verbatim}
			}

			\begin{lstlisting}[language=Pascal]
por cada escenario habilitado {
	por cada constraint del escenario {
		por cada propiedad involucrada en el constraint {
			escenariosPorEstimulo.agregar(escenario.estimulo, escenario)
			estimulosPorPropiedades.agregar(propiedad, escenario.estimulo)
		}
	}
}
			\end{lstlisting}

			El modo simulación funciona notificando los cambios en las propiedades de interés, las cuales son
			determinadas a la hora de implementar la simulación. Entonces, al contar los estímulos relacionados con cada
			propiedad y los escenarios por cada estímulo, podemos acotar la cantidad de escenarios a verificar en cada
			ejecución de la auto reparación.

			En modo real, o sea sin simulación, para notificar el estímulo desencadente fue necesario extender los
			\emph{probes}, que son los componentes encargados de testear una determinada funcionalidad del sistema,
			siendo el responsable también de medir la respuesta y de reportar dicha información a un bus, del cual
			luego la consumirán los \emph{gauges}, quienes interpretarán los datos transformándolos en cambios en el
			modelo de la arquitectura. Obviamente también fue necesario extender la funcionalidad de los \emph{gauges}
			para poder intrepretar la información de estímulo agregada en cada uno de los \emph{probes}. En ambos
			casos, y gracias al mecanismo empleado por Rainbow, no fue necesario modificar las interfaces ni de los
			\emph{probes} ni de los \emph{gauges}, ya que éstos se comunican mediante cadenas de texto, justamente
			para ofrecer una amplia libertad a la hora de implementarlos ya que pueden existir maneras muy diversas de
			testear y tomar métricas de las distintas funcionalidades de los sistemas. Luego, una vez obtenido el estímulo
			correspondiente, no resta más que recurrir al mapa de escenarios por estímulos (utilizado también en el modo
			simulación) para acotar la cantidad de escenarios a comprobar.

\todo{agregar comparación de info reportada por los Probes con estimulos y sin estimulos}

		\subsubsection{El Artefacto en la Auto Reparación}

			El \textbf{Artefacto} se refiere al componente, subsistema o parte del sistema afectada por el escenario. Dado que
			Rainbow trabaja con el modelo de la arquitectura del sistema descripto en el lenguaje Acme, contaremos con la
			especificación de las propiedades de los componentes y los conectores del sistema, entonces en el escenario de Arco Iris
			podremos contar con una vinculación directa con los componentes afectados. Al seleccionar un artefacto, el usuario de
			Arco Iris no estará más que eligiendo un componente o conector de la arquitectura del sistema, esto lo aprovecharemos
			para acotar las propiedades sobre las cuales podrá predicar la \textbf{Cuantificación de la Respuesta}.

			Para ejemplificar el concepto de artefacto utilizaremos la arquitectura presentada en Znn, recordemos que es una
			arquitectura cliente-servidor, de la cual en este caso tomaremos la especificación del componente cliente definido como
			\emph{ClientT}, a saber:

			\scriptsize{
			\begin{verbatim}
    Component Type ClientT extends ArchElementT with {

      Property deploymentLocation : string <<  default : string = "localhost"; >> ;

      Property experRespTime : float <<  default : float = 100.0; >> ;

      Property reqRate : float <<  default : float = 0.0; >> ;
    }
			\end{verbatim}
			}

			Y supongamos que se define el siguiente escenario:

			\label{escenarioPerformance}
			\begin{quote}
				Znn news debe servir el contenido de las noticias a los clientes en un tiempo de respuesta menor a 3 segundos en un
				entorno de operación normal.
			\end{quote}

			Claramente en este ejemplo \emph{ClientT} será el artefacto sobre el cual predicará la verificación de validez de
			este escenario, más adelante veremos cómo se configurará dicha restricción.

			En la sección \ref{sec:scenariosUI} se explicará en más detalle cómo se podrá emplear esta información para mejorar
			la experiencia de los \emph{stakeholders} a la hora de especificar escenarios mediante la herramienta visual
			presentada junto a Arco Iris: \textbf{scenarios UI}


		\subsubsection{El Entorno en la Auto Reparación}

			Dentro de la definición de escenario, el \textbf{Entorno} se refiere al estado en el que el sistema se encuentra
			cuando se recibe el estímulo, por ejemplo ``operatoria normal'' o ``alta carga''. El entorno condiciona la validez
			del escenario en cuestión a que el sistema se encuentre en un determinado estado. Por ejemplo, en el escenario
			planteado anteriormente en la sección \ref{escenarioPerformance}, si el sistema se encuentra en un entorno de
			``alta carga'' el escenario automáticamente se cumple, ya que no están dadas las condiciones del entorno que el mismo plantea.

			El entorno también permite a Arco Iris reducir la búsqueda de escenarios que no se cumplan ya que se ignorarán los
			escenarios cuyo entorno posea condiciones que no se satisfagan en el estado del sistema a la hora de recibir el	estímulo.

			\todo{¿Cómo se determina el estado? Hablar de las properties, las constraints, etc.}
			\todo{Contar la estructura de un Environment, el mapa $<$Concern, Weight$>$, etc...}


			También se permite especificar que un determinado escenario aplica bajo cualquier entorno, esto es, que en ese caso
			existe una única condición subyacente: \verb@true@. \todo{Esto va a tener más sentido luego de que se amplíe esta
			sección contando sobre las condiciones del environment, quizás hasta graficando un poco...}


		\subsubsection{La Cuantificación de la Respuesta en la Auto Reparación}

			La \textbf{Cuantificación de la Respuesta} es quizás la propiedad más importante: de ella surgen las restricciones
			que deben ser evaluadas para que, en caso de no cumplirse, se lance la auto reparación.

			En este caso, las restricciones genéricas que usa Rainbow se reutilizan, \todo{contar un poco sobre su sintaxis}
			poniéndolas en el contexto de un Escenario de Atributo de Calidad, proveyendo así mayor visibilidad a los
			\emph{stakeholders} sobre estas restricciones, anteriormente sólo conocidas por los arquitectos o encargados de
			configurar \todo{¿cómo?} Rainbow.

	\subsection{Prioridades entre Escenarios}

		Arco Iris permite asignar prioridades entre escenarios, de modo tal que al momento de escoger una estrategia de
		autoreparación, se tengan en consideración otros aspectos del sistema (especificados como atributos de calidad) de
		modo tal que la estrategia de reparación elegida no comprometa a alguna otra funcionalidad de la aplicación
		considerada más importante para el usuario.

		\todo{Explicar que son enteros y un poquito más de detalle implementativo}

	\subsection{Estrategias y su Relación con los Escenarios}

		\todo{Explicar RESP\_TIME\_STILL\_BROKEN y COST\_STILL\_BROKEN en las estrategias}
	
		\todo{explicar como se configuran normalmente las estrategias en Rainbow, como reutilizamos la misma implementación y
		explicar que la información para determinar la utilidad del sistema de acuerdo a lo que se estima que la estrategia
		arregla sigue sacandose de lo que ya estaba (rainbow o znn?)}

		En Arco Iris, las estrategias de reparación si bien tienen su vida propia, se pueden asociar a los escenarios. La idea
		subyacente debajo de esta decisión de diseño es que se pueda especificar un conjunto de estrategias de reparación a
		ser consideradas para su ejecución, en el caso de que el escenario en cuestión se vea comprometido.

		Una ventaja derivada del agregado del concepto de Escenarios es que ahora los problemas y sus posibles soluciones
		(i.e. estrategias de reparación), pueden ser visibles a los usuarios y stakeholders de la aplicación. Como ya sucedía
		en Rainbow, las estrategias poseen la información necesaria para permitir simular su aplicación y estimar cómo
		quedaría el sistema luego de haber aplicado dicha estrategia. (estimación de la nueva ``utilidad del sistema''). Cabe
		aclarar que la ``utilidad del sistema'' es una función que se calcula a partir del cumplimiento o no de los escenarios
		requeridos por los stakeholders, teniendo en cuenta sus prioridades relativas y la prioridad de la estrategia simulada.

	\subsection{Detección: cuando activar el mecanismo de auto reparación}

		Con este nuevo enfoque, dónde el Escenario es el concepto central, es necesario establecer cambios en la lógica
		aplicada por el \emph{framework} para decidir en que momento es necesario intentar auto reparar el sistema (i.e.
		evaluar restricciones o invariantes del mismo).

		En Rainbow, dichas restricciones se encuentran embebidas en los componentes de la arquitectura (modelados con ACME).
		En Arco Iris, las \emph{constraints} a evaluar son aquellas presentes en la cuantificación de la respuesta de cada
		escenario. El formato y sintáxis no se modifica, sólo se cambia la ubicación de las constraints para mayor visibilidad
		de los \emph{stakeholders} funcionales. \todo{mencionar los de EAvg y ESum? Si no es acá, ¿donde?}

		\todo{Ampliar gigantescamente la siguiente explicación, con gráficos, mas detalle, etc. y dejando en claro como
		funcionaba en Rainbow y que agregamos nosotros}

		Ante la invocación de un estímulo en el sistema en ejecución, el \textbf{Monitor} del sistema informa de esta
		situación al \textbf{Intérprete}, que a su vez actualiza las propiedades del modelo de la arquitectura (recordemos: en
		ACME) e invoca finalmente al \textbf{Evaluador de Restricciones} para que busque aquellos escenarios que posean al
		estímulo ejecutado y que estén definidos para el \textbf{Entorno} de ejecución actual y que las restricciones
		asociadas a sus \textbf{Cuantificaciones de Respuesta} no se cumplan. Aquellos escenarios que cumplan dichas
		condiciones serán aquellos a los cuales el Manejador de Reparaciones intentará reparar.

	\subsection{Selección de estrategia a aplicar}

		\todo{Esta subsección probablemente necesite ser reescrita en su totalidad, explicando en una subsubsection el
		concepto de utilidad del sistema}

		\subsubsection{Utilidad del Sistema}

			\todo{Explicar Utilidad del sistema}

		El módulo denominado como ``Adaptation Manager'' es uno de los módulos que han sufrido más modificaciones como parte
		de esta extensión a Rainbow. El mismo ha sido extendido \todo{¿cómo?} para que utilice el conocimiento plasmado en los
		escenarios para que determine la mejor (en un sentido heurístico) estrategia de reparación a aplicar, teniendo en
		cuenta:
		\begin{itemize}
			\item el entorno de ejecución en que se encuentra la aplicación,
			\item el atributo de calidad asociado al escenario, \todo{Hablamos por todos lados de QA pero en realidad es
			Concern!} y
			\item las prioridades relativas de los escenarios.
		\end{itemize}
		El objetivo final es el de intentar reparar el inconveniente hallado pero siempre restricto a evitar perjudicar
		algún otro escenario de mayor prioridad \todo{Esto es un efecto colateral de la utility function pero...podemos
	garantizar que esto es asi siempre? Creo que esto necesita ser reescrito} y mediante el uso de heurísticas, poder
	aproximar la mejor estrategia de reparación a llevar a cabo de modo que la \emph{utilidad del sistema} se maximize.

	\subsection{Eliminación de limitaciones}

		En la implementación actual de Rainbow, la cantidad de restricciones evaluada es fija y es embebida en las
		descripciones de la arquitectura (en ACME) que realizan los arquitectos del sistema. Debido a esto, cualquier cambio
		que se desee hacer requiere de una engorrosa tarea de modificación del modelo de arquitectura y obviamente, de un
		reinicio del framework.

		En Arco Iris, los \emph{stakeholders} podrán cargar de manera sencilla (para ver cómo, remitirse a la sección
		\ref{sec:scenariosUI}) una cantidad ilimitada de escenarios y cambiar prioridades relativas, pesos entre distintos
		concerns para distintos entornos y posibles estrategias de reparación para cada escenario y/o en general. Esto
		configura Arco Iris como un sistema que tiene en cuenta muchos más aspectos que Rainbow al momento de decidir la
		mejor estrategia a ser aplicada.

		\todo{Ver si tiene sentido poner esto como tabla! La tabla se va al carajo y la referencia no funciona!!!}

		En la tabla \ref{ventajasArcoIris} se observa el detalle de las ventajas de Arco Iris por sobre Rainbow.

		\begin{sidewaystable}
			\begin{center}
					\footnotesize{
					\rowcolors*[\hline]{1}{GreenYellow!25}{GreenYellow!10}
					\begin{tabularx}{\textwidth}{|X|X|X|X|}
						\label{ventajasArcoIris}
						\textbf{Problema} & \textbf{Implementación en Rainbow} & \textbf{Implementación en Arco Iris} & \textbf{Ventajas}\\
						Información sobre restricciones & Las restricciones son guardadas en el modelo de la arquitectura (expresado en
						\mbox{ACME}) & Los \mbox{\emph{stakeholders}} usan una interfaz visual para expresar restricciones del sistema en
						formato de escenarios de QAW. Esa información es analizada por Rainbow para tomar decisiones sobre las auto
						reparaciones a realizar. & Las res\-tri\-ccio\-nes pue\-den ser a\-gre\-ga\-das y/o editadas dinámicamente y de
						una manera simplificada para los \emph{stakeholders}.\\
						Relación entre \emph{concerns} arquitecturales (e.g. tiempo de respuesta) & El concepto de atributo de
						calidad no tiene un modelado específico en Rainbow. Sí está presente en Znn, y son llamados llamados ``Quality
						Dimensions''. Los mismos se relacionan estáticamente en una función de utilidad (dónde el valor de los atributos
						suman 1) & Los atributos de calidad son parte de los escenarios y se relacionan utilizando la terminología de
						ATAM. Un escenario puede tener mayor prioridad que otro y esto afecta a los \emph{tradeoffs} que nuestra extensión
						a Rainbow deberá hacer al momento de escoger una estrategia de reparación. & Los \emph{stakeholders} tienen la
						posibilidad de cambiar esta información dinámicamente y consecuentemente, afectar la manera en que el
						\emph{framework} opera.\\
						Decisiones sobre que reparaciones realizar & Las reparaciones a realizar también se encuentran en archivos de
						configuración & El sistema evalúa los escenarios cargados y como se afectan entre ellos. Luego invoca a un módulo
						que decide qué reparaciones pueden llevarse a cabo de acuerdo a las restricciones. & Dicho módulo puede ser
						extendido para incluír complejas heurísticas que aprendan de los efectos de reparaciones pasadas y puedan así
						mejorar los resultados.\\
						Entorno de ejecución (e.g. Alta Carga)& El entorno de ejecución es estáticamente configurado en un archivo de
						configuración y no se modifica de acuerdo al estado dinámico del sistema que se intenta reparar. Para modificar
						tal estático y limitado valor, es necesario el reinicio de Rainbow. & El modelo de Arco Iris permite al usuario
						especificar distintos entornos de ejecución, los cuales tienen restricciones asociadas que se chequean
						continuamente y que, de cumplirse, hacen que el sistema automáticamente se considere que está en otro entorno de
						ejecución, afectando al algoritmo de decisión de estrategias de reparación. & Lo antedicho, agrega una nueva
						arista a las variables consideradas al momento de elegir la mejor estrategia de reparación, aumentando las
						probabilidades de que la estrategia seleccionada sea más precisa de acuerdo a la situación del sistema en
						\emph{runtime}.
					\end{tabularx}
					}
			\end{center}
		\end{sidewaystable}