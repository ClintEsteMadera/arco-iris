\section{Extensión a Rainbow: Arco Iris}

	\subsection{Introducción}

		Como ya se ha comentado anteriormente, la idea de este trabajo es extender el \emph{framework} Rainbow para poder
		lograr un mecanismo de auto reparación más flexible y con mayor capacidad expresiva, y con el objetivo de proveer visibilidad
		a los \emph{stakeholders} de la aplicación sobre dicho proceso, permitiéndoles involucrarse en la definición de
		escenarios de atributos de calidad del sistema, de sus prioridades relativas y de las estrategias a considerar en la
		auto reparación del sistema cuando un escenario deja de cumplirse.
		A fin de lograr lo antedicho, se propone extender el \emph{framework} Rainbow, con la anuencia y apoyo de los
		integrantes del proyecto ABLE, quienes poseen su propiedad intelectual.

	\subsection{Rainbow \emph{out of the box}}

		En el diagrama de colaboración de objetos que se muestra en la Figura \ref{fig:Rainbow_Architecture} se pueden 
		observar los principales componentes de la arquitectura de Rainbow.
		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/Rainbow_Architecture.png}
			\caption{Arquitectura de Rainbow}
			\label{fig:Rainbow_Architecture}
		\end{figure}}
		
		Observamos que, en Rainbow, una persona con rol de arquitecto (o similar) es el encargado de configurar el 
		\emph{framework} utilizando, básicamente, dos vías:
		\begin{enumerate}
			\item la creación de un modelo de la arquitectura del sistema al cual Rainbow va a adaptar. Dicho modelo se
			especifica utilizando el estilo de componentes y conectores (C\&C) y el lenguaje de descripción de arquitecturas
			ACME (ver sección \ref{sec:acme}). En dicho lenguaje, los componentes y conectores poseen propiedades (con valores
			asociados), restricciones y también se ofrece la posibilidad de especificar invariantes a nivel de sistema o sub
			sistema. Dichos invariantes y restricciones serán evaluados periódicamente por Rainbow para verificar que el sistema
			funcione dentro de los límites determinados como normales.
			\item la generación de un conjunto de archivos de configuración que especifican diversos aspectos relacionados con
			la definición del sistema a auto reparar, como por ejemplo: ubicación física del archivo ACME que describe la
			arquitectura del sistema, archivos de tácticas y estrategias de reparación (escritos en \emph{Stitch}), datos para
			la configuración de la conexión de Rainbow con el sistema en \emph{runtime}, etc.
		\end{enumerate}

		Podemos ver también en el gráfico anterior que los denominados \emph{Probes} son los componentes designados para
		interactuar directamente con el sistema a adaptar (el \emph{Target System}), obteniendo así información relevante a los
		fines de su auto reparación. Dicha información no es interpretada dentro de los \emph{probes}, sino que ellos delegan
		dicha tarea a los denominados \emph{Gauges}. Estos componentes son los encargados de interpretar la información provista por
		los \emph{probes} y traducirla a pares \verb@<Propiedad,Valor>@ donde \verb@Propiedad@ refiere al nombre de una
		propiedad correspondiente a un componente o conector de la arquitectura del sistema a adaptar, mientras que
		\verb@Valor@ es el nuevo valor que poseerá dicha propiedad.

		Normalmente, por cada tipo relevante de \emph{concern} que interese ser monitoreado en tiempo de ejecución existe un
		par \verb@<Gauge,Probe>@ asociado. Un ejemplo de \emph{concern} podría ser: ``tiempo de respuesta experimentado por el
		usuario'', el cual es un \emph{concern} relacionado al atributo de calidad eficiencia.

		El \emph{Gauge Coordinator}, tal como su nombre lo sugiere, coordina la información provista por todos los
		\emph{gauges} y se encarga de notificar los cambios en el sistema en ejecución al componente \emph{Rainbow Model}.
	
		\emph{Rainbow Model}, componente clave en la arquitectura del \emph{framework}, tiene como principal responsabilidad
		hacer efectiva la actualización de los valores de la propiedades de los componentes, conectores, sub sistemas o
		sistemas del modelo de arquitectura de la aplicación a adaptar. También es quien tiene el conocimiento necesario para
		detectar violaciones a las restricciones e invariantes presentes en el modelo de arquitectura con el cual el
		\emph{framework} ha sido configurado.

		Por otra parte, existe otro componente llamado \emph{Architecture Evaluator}, el cual consulta periódicamente a
		\emph{Rainbow Model} para tomar conocimiento de violaciones a restricciones definidas en el modelo de la arquitectura.
		En el caso de existir alguna violación, el \emph{Architecture Evaluator} dispara el mecanismo de adaptación invocando
		al \emph{Adaptation Manager}.

		El \emph{Adaptation Manager}, uno de los componentes más importantes de Rainbow, sigue una lógica un tanto compleja
		(explicada en detalle en la sección \ref{sec:strategySelection}) para determinar la estrategia de reparación que deja
		al sistema en el mejor estado posible, para luego ejecutarla.
		
		La \emph{Estrategia} contiene la lógica necesaria para reparar el sistema en ejecución mediante el uso de
		\emph{Tácticas}, que a su vez, utilizan a los denominados \emph{Effectors}, los cuales son componentes que realizan
		acciones simples y concretas sobre el sistema en ejecución, como por ejemplo ``aumentar el nivel de logging de un
		componente determinado''.

	\subsection{Rainbow + Escenarios = ``Arco Iris''}

			En el presente apartado se presenta someramente las características principales de la arquitectura de Rainbow
			luego de incorporar las extensiones planteadas en el presente trabajo, a las cuales denominamos ``Arco Iris''.

		\subsubsection{Arquitectura de Arco Iris}
		\label{sec:arquitecturaArcoIris}

			En la figura \ref{fig:Rainbow_Architecture_With_Scenarios} podemos observar como luce la arquitectura
			del \emph{framework} con la incorporación de las extensiones realizadas.

			\afterpage{\clearpage
			\begin{figure}[H]
				\centering
				\includegraphics[width=1.00\textwidth]{images/Arco_Iris_Architecture.png}
				\caption{Arquitectura de Arco Iris}
				\label{fig:Rainbow_Architecture_With_Scenarios}
			\end{figure}}

			El arquitecto sigue realizando las mismas tareas que realizaba en Rainbow (i.e. ``alimentarlo'' con el
			modelo de la arquitectura del sistema a adaptar y con archivos de configuración requeridos por Rainbow) pero ahora se
			le suma una tarea más: el configurar los escenarios de atributos de calidad; tarea que realiza en conjunto con una o
			más personas que asumen distintos roles que normalmente se engloban en la palabra \emph{stakeholders} (e.g. analistas
			funcionales, usuarios del sistema, líderes, clientes, el \emph{sponsor} del proyecto, etc.)

			En la versión original de Rainbow (i.e. sin extensiones) el \emph{framework} deja al usuario (e.g. el arquitecto) la
			responsabilidad de codificar los \emph{probes} y \emph{gauges} que recolectarán información del sistema a adaptar y
			traducirán esa información a cambios en los valores de las propiedades del sistema. Esto sigue siendo igual en
			Rainbow con las extensiones provistas por Arco Iris, es decir, el usuario sigue siendo el encargado de crear los
			componentes que en tiempo de ejecución encuestan al sistema periódicamente para obtener información relevante y
			mantener actualizado el modelo de la arquitectura subyacente.

			En el diagrama se puede observar que, en Arco Iris, tanto los \emph{probes} como los \emph{gauges} ahora poseen
			conocimiento del concepto de \textbf{estímulo} (tal cual es descrito en los escenarios de atributos de calidad de ATAM).
			A diferencia de los utilizados en Rainbow, los \emph{probes} implementados para trabajar con Arco Iris deberán
			indicar el estímulo al cual están asociados, mientras que los \emph{gauges} deberán interpretar esta información y
			notificar al \emph{Arco Iris Model} de la actualización sobre el modelo indicando el estímulo desencadenante. Las
			novedades sobre los cambios ocurridos en el sistema en \emph{runtime} serán informados con el siguiente formato:
			\verb@<Propiedad,Valor,Estímulo>@
			En función de las modificaciones al modelo original de Rainbow descritas en el párrafo anterior, el componente
			\emph{Gauge Coordinator} ha sido extendido (i.e. \emph{Arco Iris Gauge Coordinator}) conservando el comportamiento
			original provisto por Rainbow. De esta manera, Arco Iris puede coordinar información proveniente de \emph{gauges} de
			Rainbow y/o de Arco Iris con su correspondiente conocimiento sobre el estímulo originario de la modificación.
			De la misma manera, el componente \emph{Arco Iris Model} es una extensión de \emph{Rainbow Model}
			que permite manipular información de estímulos proveniente del \emph{Arco Iris Gauge Coordinator} sin perder el
			soporte original provisto por \emph{Rainbow Model}.

			Cuando \emph{Arco Iris Model} es notificado de que un estímulo ha sido invocado en el sistema solicita
			al \emph{Self Healing Configuration Manager} el subconjunto de escenarios habilitados que poseen dicho estímulo y que
			a su vez han dejado de cumplirse\footnote{De ahora en más, diremos equivalentemente que el escenario en esta
			situación se encuentra ``roto''.}. Luego de obtener este subconjunto de escenarios, invocará al \emph{Arco Iris
			Adaptation Manager}, extensión del componente original \emph{Adaptation Manager}, indicando el conjunto de escenarios
			detectados como ``rotos'' a los cuales debe intentar reparar considerando diversas variables como por ejemplo sus
			prioridades relativas.
			
			Además de detectar los escenarios rotos para un determinado estímulo, el componente \emph{Self Healing Configuration
			Manager} carga la denominada \emph{Self Healing Configuration}, una abstracción de la mayor parte de la información
			referente a auto reparación utilizada por Arco Iris. Esto incluye, por supuesto, los escenarios creados por los
			\emph{stakeholders} y arquitectos.
		\subsubsection{Modelo de Restricciones en Arco Iris}
		\label{sec:modeloRestriccionesArcoIris}

			Tanto Rainbow como Arco Iris, hacen uso del concepto de \textbf{restricción}, que si bien se utiliza en distintos
			contextos debido a que ambos \emph{frameworks} enfocan la auto reparación desde distintos ángulos, ambos responden a
			la misma finalidad.
			
			Arco Iris utiliza restricciones en dos contextos distintos. Por un lado, las condiciones para conocer
			el entorno en que se encuentra el sistema no son más que meras restricciones, y por otro, la cuantificación de la
			respuesta no es más que una restricción que determina la condición necesaria para que el escenario se satisfaga.

			Rainbow utiliza el concepto de \emph{restricción} para:
			\begin{itemize}
				\item imponer condiciones sobre el modelo de la arquitectura que el sistema debe satisfacer en tiempo de ejecución,
				idealmente, en todo momento. Estas condiciones pueden predicar sobre propiedades de componentes, conectores, sub
				sistemas o directamente sobre todo el sistema.
				\item especificar precondiciones a la ejecución de tácticas y estrategias, así como también, para condicionar el
				algoritmo de cada estrategia.
			\end{itemize} 

			En el primer caso, las restricciones se encuentran expresadas en el lenguaje \textbf{Acme}. Si bien, se provee un
			modelo en Java de los distintos tipos de restricciones que un usuario del lenguaje normalmente querría expresar,
			dicha implementación se encuentra fuertemente acoplada a la lógica de \emph{parseo} utilizada por el lenguaje, lo
			cual imposibilitó su reutilización en Arco Iris.

			En el segundo caso, las restricciones se encuentran expresadas en el lenguaje \textbf{Stitch} y no poseen una
			contraparte en el lenguaje Java.

			Consecuentemente, Arco Iris implementa su propio modelo simplificado de restricciones, el cual se encuentra inspirado en
			el modelo de Acme, aunque desacoplado de cualquier otra lógica externa. Así, el concepto de restricción presentado en
			Arco Iris permite agregar nuevos tipos de restricciones simplemente implementando la interfaz \verb@Constraint@
			\footnote{Dicha implementación deberá ser agregada al enumerado ConstraintType en Arco Iris UI para que la UI reconozca
			el nuevo tipo}. La interfaz definida es la siguiente:

			\begin{Verbatim}[gobble=4]
				public interface Constraint {

					boolean holds(Number value);

					String getFullyQualifiedPropertyName();
				}
			\end{Verbatim}

			Mediante el método \verb@holds@, se define como responsabilidad de la misma \verb@Constraint@ el determinar si se
			cumple o no, recibiendo como parámetro el valor actual de la propiedad del modelo de la arquitectura sobre el cual
			predica la cuantificación de la respuesta. Es de notar que en el futuro esta interfaz podría ser modificada para
			soportar propiedades cuyos valores no sean numéricos.
			
			El método \verb@getFullyQualifiedPropertyName@ retornará el nombre completo calificado de la propiedad sobre la
			que predica, incluyendo el sistema y el componente al que pertenece, por ejemplo, \verb@ZNewsSys.ClientT.experRespTime@
			alude a la propiedad \verb@experRespTime@ de todos los componentes del sistema \verb@ZNewsSys@ que sean de tipo
			\verb@ClientT@. De la misma manera, se pueden referenciar propiedades de \textbf{instancias} particulares como por
			ejemplo: \verb@ZNewsSys.Server2.cost@.
			
			Para el presente trabajo se utilizó	una única implementación de esta interfaz, consistente en una
			relación binaria de orden ($<$, $\leq$, $=$, $>$ o $\geq$) entre una propiedad de un componente, conector, etc. de
			la arquitectura (e.g. \verb@server1.responseTime@) y una constante numérica. La implementación mencionada recibe el
			nombre de \emph{NumericBinaryRelationalConstraint} y su código puede verse en el apéndice
			\ref{sec:numericBinaryRelationalConstraintCode}.
			
			Dado que, como hemos mencionado anteriormente, las restricciones predican sobre propiedades del sistema en ejecución,
			cuyos valores son sensibles al ``ruido'' producido por la presencia de posibles \emph{outliers}, Arco Iris utiliza,
			al igual que Rainbow, el concepto de \emph{Exponential Moving Average} (presentado en la sección
			\ref{sec:exponentialAverage}) para evitar este efecto negativo que afecta tanto a la detección del entorno actual
			como a la verificación de los escenarios.
			
			\subsubsubsection{Cuantificación de las Restricciones}

				Rainbow utiliza las reglas e invariantes provistas en el lenguaje Acme para definir restricciones sobre el modelo de
				la arquitectura del sistema a reparar. Estas reglas e invariantes, se limitan a predicar únicamente sobre una
				instancia específica o bien sobre todas las instancias de un determinado tipo de componente.
				
				Ahora bien, en Rainbow, cuando la restricción aplica a un \textbf{tipo} de componente de la arquitectura, pueden
				darse dos casos: que se predique sobre el \textbf{valor promedio} de todas las instancias de dicho tipo de
				componente o bien sobre la \textbf{sumatoria}. Para implementar estos casos, Rainbow opta por interpretar las
				restricciones impuestas sobre el modelo en Acme como si predicaran implícitamente sobre el \emph{promedio} de todos
				los valores; y por otro lado, ofrece como mecanismo para expresar restricciones sobre la \emph{sumatoria} de
				todos los valores, la definición de precondiciones dentro de las estrategias de reparación definidas en en lenguaje
				\emph{Stitch}. El siguiente, es un ejemplo de cómo Znn impone restricciones sobre la sumatoria del costo de los
				servidores del sistema:
				
				\begin{Verbatim}[gobble=5]
					import op "org.sa.rainbow.stitch.lib.Model";
					...
					define float totalCost = Model.sumOverProperty("cost", servers);
					define boolean hiCost = totalCost >= M.THRESHOLD_COST;
					...
					/* This Strategy is triggered by the total server costs rising above acceptable
					 * threshold; this Strategy reduces the number of active servers
					 */
					strategy ReduceOverallCost
					[ hiCost ] {
					  t0: (hiCost) -> dischargeServers(1) @[2000 /*ms*/] {
					    t1: (!hiCost) -> done;
					    t2: (lowRespTime && hiCost) -> do[2] t0;
					    t3: (default) -> TNULL;
					  }
					}
					...
				\end{Verbatim}

				Se observa la utilización de una clase Java (\verb@Model.sumOverProperty("cost", servers)@) para obtener la
				sumatoria de los costos de los servidores. Esta forma de establecer restricciones (el ``qué'') se encuentra
				claramente acoplada con la forma de reparar el sistema (``el cómo'') y además, no existe una forma única de definir
				restricciones sobre el modelo, lo cual puede conducir a confusiones y potenciales inconsistencias; así como también
				redunda en poca flexibilidad para el usuario que define restricciones sobre el modelo, ya que esta manera de hacerlo
				requiere conocimiento técnico no trivial.

				Para subsanar esta falencia de diseño, Arco Iris agrega a las restricciones numéricas el concepto de
				\textbf{Cuantificador}. El cual es extensible y actualmente soporta dos opciones: \textbf{sumatoria} o
				\textbf{promedio}, los que especifican respectivamente si la condición predica sobre la sumatoria o el promedio de
				los valores de una determinada propiedad, para todas las instancias en \emph{runtime} de un determinado componente.

	\subsection{Flexibilización de la Auto Reparación con QAS}

		Actualmente Rainbow posee conocimiento sobre el sistema a adaptar mediante el modelo de su arquitectura expresado en
		el lenguaje de descripción de arquitecturas Acme. En dicho modelo también se encuentran definidos invariantes y
		restricciones sobre el comportamiento esperado del sistema, información que luego es utilizada por Rainbow para
		detectar cuándo el sistema se encuentra en un estado no deseado. Existen algunos problemas con respecto a cómo Rainbow
		lleva a cabo esta tarea:
		\begin{itemize}
			\item Rainbow verifica que se satisfagan \textbf{todos} los invariantes y restricciones del modelo. En caso de
			detectar que alguna de estas condiciones no se satisfacen, no existe un correlato directo entre la restricción o
			invariante que deja de cumplirse con la o las estrategias de reparación que solucionan dicho problema. 
			\item Como consecuencia del punto anterior, Rainbow debe considerar todas las estrategias definidas para el sistema
			al momento de determinar la mejor estrategia de reparación a ejecutar.
			\item A fin de establecer un correlato indirecto entre aquello que causó el funcionamiento no esperado del sistema y
			las estrategias de reparación candidatas, se \textbf{replican} las restricciones o invariantes ya definidas en el
			modelo como precondiciones en las estrategias.
		\end{itemize}
		
		Se observa que este esquema es poco flexible ya que ante cualquier modificación en los requerimientos de auto
		reparación definidos para el sistema, el usuario deberá modificar tanto el modelo de la arquitectura como las
		estrategias de reparación asociadas. Esta redundancia, además de significar un trabajo de configuración innecesario
		para el usuario, puede llevar a inconsistencias que provocarían un comportamiento indeseado en la auto reparación del
		sistema.

		Por otro lado, el modificar el comportamiento de la auto reparación en Rainbow requiere un conocimiento técnico no
		trivial, por lo que el cambio debería ser realizado por el arquitecto del sistema, esto hace a Rainbow menos flexible
		ante cambios en los requerimientos de los usuarios no técnicos, ya que éstos no podrían llevar a cabo la modificación
		de requerimientos sin la asistencia activa de un usuario técnico.

 		Con el objetivo de subsanar las falencias anteriormente comentadas, Arco Iris extiende el conocimiento que
 		Rainbow posee sobre el sistema y lo organiza de una manera más adecuada. Esencialmente, se incluye información sobre
		los atributos de calidad del sistema que son relevantes para los \emph{stakeholders}. Se permite, por ejemplo, poder
		describir la importancia relativa de la eficiencia, la disponibilidad, etc.; definiendo así una serie de
		\emph{tradeoffs} entre distintos atributos de calidad requeridos para el sistema. El enfoque propuesto para lograr
		esto consiste en especificar \textbf{Escenarios de Atributos de Calidad}, tal cual fueron descritos en la sección
		\ref{sec:QAS}, extendiendo el concepto con información orientada a flexibilizar la auto reparación. Esta extensión es
		explicada en detalle en la sección \ref{sec:modeloExtensionQAS}.
		
		A continuación se detallan las soluciones introducidas por Arco Iris para solucionar los problemas que
		posee Rainbow mencionados anteriormente:
		\begin{itemize}
			\item Gracias al uso de QAS, el invariante o restricción que en Rainbow se encontraba descrito en el modelo de la
			arquitectura, pasa a formar parte del \emph{response measure}. Luego, para solucionar la falta de correlato entre la
			detección del problema y su reparación, Arco Iris extiende el concepto de escenario, agregándole el conocimiento de
			cuáles son las estrategias de reparación candidatas para reparar el sistema, en caso de que dicho escenario no se
			cumpla.
			\item  Conforme a lo explicado en el punto anterior, se evita la necesidad de considerar todas las estrategias como
			candidatas, tal cual era el comportamiento original de Rainbow.
			\item Al contar con el correlato explícito entre el problema y sus posibles soluciones, ya no es necesario especificar
			precondiciones a las estrategias de reparación, flexibilizando y simplificando de esta manera el uso del
			\emph{framework} así como también eliminando la existencia de posibles inconsistencias en su configuración.
		\end{itemize}

		En la Figura \ref{fig:QAS_Model} se puede observar el modelo diseñado para representar los QAS en Arco Iris. Este
		modelo cumple una tarea fundamental ya que toda esta información será manipulada constantemente por Arco Iris para
		llevar a cabo la auto reparación en base a las expectativas plasmadas por los \emph{stakeholders} al crear los escenarios.

		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/QAS_Model.png}
			\caption{Modelo de QAS}
			\label{fig:QAS_Model}
		\end{figure}}		
		
		De todos los atributos que posee un QAS, el \textbf{Estímulo}, el \textbf{Artefacto}, el \textbf{Entorno} y la
		\textbf{Cuantificación de la Respuesta} son particularmente relevantes a los fines de establecer información útil para
		el mecanismo de auto reparación. A lo largo de las próximas secciones se detalla el uso que hace Arco Iris de esta
		información para modificar, optimizar y flexibilizar la auto reparación llevada a cabo por Rainbow.

		\subsubsection{El Estímulo en la Auto Reparación}

			El \textbf{estímulo} de un escenario normalmente se asocia a un evento desencadenado en el sistema por la acción del
			alguno de sus usuarios. Dicho evento es el punto de entrada del escenario, el disparador (interno o externo) que
			inicia la interacción con el sistema, y más particularmente, con el artefacto del escenario en cuestión. Por ejemplo,
			supongamos que en un sistema de administración de cuentas bancarias un cliente intenta hacer una transferencia, en
			este caso la fuente del estímulo sería el cliente y el estímulo en sí mismo sería \emph{realizar transferencia}.
			En términos de auto reparación, generalmente el estímulo se encuentra asociado a una operación provista por el
			artefacto del sistema, el cual puede ser un componente, un conector o un sub sistema.

			Saber cuál es el estímulo de cada escenario permite optimizar la auto reparación, ya que habiendo ocurrido
			determinado estímulo, Arco Iris podrá detectar cuáles son los potenciales escenarios que pueden verse afectados y
			trabajará verificando dicho subconjunto, acotando así la cantidad de restricciones a verificar y, consecuentemente,
			optimizando el tiempo de la auto reparación.

			Cabe destacar que también se ofrece la posibilidad de no especificar el estímulo al configurar un escenario, es decir,
			se permite la opción de que el escenario aplique siempre, independientemente del estímulo que haya impactado al sistema.
			Esto puede ser útil para casos genéricos, por ejemplo, si se requiere que el tiempo de respuesta experimentado por el
			usuario nunca sobrepase determinado umbral sin importar la funcionalidad del sistema que el usuario esté utilizando.
			En particular, se podría no configurar ningún estímulo en ningún escenario, y en ese caso, Arco Iris verificará que
			se satisfagan todos los escenarios en cada iteración de la auto reparación cada vez que un estímulo perteneciente a
			cualquier escenario impacte sobre el sistema. Como puede se observar, es recomendable configurar el estímulo
			específico para cada escenario a fin de conseguir un funcionamiento más preciso del \emph{framework}.
			Entonces, a diferencia de Rainbow, quien debe verificar todas las restricciones en todo momento, Arco Iris permite
			refinar el conjunto de escenarios que pueden verse afectados por efecto del estímulo que ocasiona el problema,
			reduciendo así la cantidad de restricciones e invariantes a verificar.

			Para notificar sobre el estímulo desencadente fue necesario extender los \emph{probes}, que, como ya mencionamos
			anteriormente, son los componentes encargados de extraer del sistema información referente a un determinado
			\emph{concern}, así también como de volcar dicha información en una cola compartida con otros \emph{probes}. De este
			\emph{bus}, los \emph{gauges} consumirán la información para luego interpretarla y transformarla en cambios en los
			valores de propiedades del modelo de la arquitectura.
			
			La extensión de los \emph{probes} implicó la necesidad de extender los \emph{gauges} de manera tal que puedan
			interpretar la nueva información sobre estímulos agregada en cada uno de los mensajes creados por los \emph{probes}.
			
			Debido a que en el diseño original de Rainbow, los mensajes que los \emph{probes} envían a los \emph{gauges} son
			meras cadenas de texto, las extensiones realizadas a ambos componentes no presentaron mayores inconvenientes.
			
			Para graficar la diferencia en la implementación que genera el agregar el estímulo en la auto reparación, se
			ejemplificará una extensión a un \emph{probe} utilizado por Znn. El \emph{probe} escogido para extender y así poder
			ser utilizado en Arco Iris consiste simplemente en invocar un servicio, esperar su respuesta y medir el tiempo
			transcurrido entre la invocación y la respuesta; ésta será la información que el \emph{probe} reportará en el
			\emph{bus} que luego consultará e interpretará el \emph{gauge} correspondiente.
			
			A continuación se puede observar la configuración original utilizada en Znn para instanciar un \emph{probe} del tipo
			ClientProxyProbe, esta configuración se puede encontrar en el archivo \verb@probes.yml@, donde se declaran todos los
			\emph{probes} que serán instanciados al iniciar Rainbow:

			\begin{Verbatim}[gobble=4]
				probes: 
				ClientProxyProbe0: 
					alias: clientproxy 
					location: "localhost"
					type: java 
					javaInfo:
						class: org.sa.rainbow.translator.znews.probes.ClientProxyProbe
						period: 2000
						args.length: 1
						args.0: "http://delegate.oracle/"
			\end{Verbatim}

			Un ejemplo de la información que reporta un \verb@ClientProxyProbe@ con la configuración presentada
			anteriormente podría ser:
			
			\begin{Verbatim}[gobble=4]
				[fri may 13 22:15:04 2011]<clientproxy> localhost: 1532 ms
			\end{Verbatim}
			
			Tanto la configuración como la implementación de \verb@ClientProxy@ son muy similares a las de su contraparte de Arco
			Iris, \verb@ClientProxyWithStimulus@. En el apéndice \ref{sec:probesCode} se pueden observar ambas implementaciones,
			mientras que la configuración de una instancia de \verb@ClientProxyWithStimulus@ se puede observar a continuación:

			\begin{Verbatim}[gobble=4]
				ClientProxyProbeWithStimulus0:
					alias: clientproxyWithStimulus
					location: "localhost" 
					type: java 
					javaInfo:
						class: ar.uba.dc.arcoiris.znn.probes.ClientProxyProbeWithStimulus
						period: 2000
						args.length: 2
						args.0: "http://delegate.oracle/"
						args.1: "delegateStimulus"
			\end{Verbatim}

			Por último, se muestra la información reportada por una instancia de\\
			\verb@ClientProxyWithStimulus@ con la configuración que se acaba de presentar:
			
			\begin{Verbatim}[gobble=4]
				[fri may 13 22:15:04 2011]<clientproxyWithStimulus> localhost<stimulus:delegateStimulus>: 1532 ms
			\end{Verbatim}

			Algunas formas posibles de implementar \emph{probes} son:
			\begin{itemize}
			  \item \emph{Parsing} e interpretación de información existente en archivos de logs del sistema o en el servidor en
			  el cual se ejecuta.
			  \item Invocaciones idempotentes a servicios provistos por el sistema, con el fin de obtener métricas sobre las
			  respuestas.
			  \item El sistema a adaptar puede ofrecer servicios específicos que provean información relevante para su auto
			  reparación.
			\end{itemize}

		\subsubsection{El Artefacto en la Auto Reparación}

			El \textbf{artefacto} se refiere al componente, conector o sub sistema afectado por el escenario, cualesquiera de
			ellos se encuentran descritos en el modelo de la arquitectura.

			La asociación de un artefacto particular a un escenario permite acotar las propiedades sobre las cuales podrá
			predicar la \textbf{cuantificación de la respuesta} (ver sección \ref{sec:responseMeasure}).

			La arquitectura presentada en Znn servirá para ejemplificar el concepto de artefacto. Cabe recordar que se trata
			de una arquitectura de estilo cliente-servidor, donde el componente de tipo \emph{ClientT} se define de la siguiente
			manera:

			\begin{Verbatim}[gobble=4]
				Component Type ClientT extends ArchElementT with {

				  Property deploymentLocation : string <<  default : string = "localhost"; >> ;

				  Property experRespTime : float <<  default : float = 100.0; >> ;

				  Property requestRate : float <<  default : float = 0.0; >> ;
				}
			\end{Verbatim}

			Suponiendo que se define el siguiente escenario:

			\begin{Quote}
				``Znn news debe servir el contenido de las noticias a los clientes en un tiempo de respuesta menor a 3 segundos en un
				entorno de operación normal.''
			\end{Quote}

			Dado que en la arquitectura de Znn se modela a los clientes como componentes de la arquitectura, con una
			propiedad específica \verb@experRespTime@ que representa el tiempo de respuesta experimentado por el usuario,
			claramente se observa que en este ejemplo \emph{ClientT} es el artefacto sobre el cual ha de predicar la verificación
			de validez del escenario anteriormente detallado. Más adelante, en la sección \ref{sec:responseMeasure}, se podrá
			observar cómo se configura dicha restricción en un escenario de atributos de calidad.

		\subsubsection{El Entorno en la Auto Reparación}
		\label{sec:environment}
		
			\subsubsubsection{El Concepto de Entorno en Rainbow}
			
				Si bien Rainbow utiliza el concepto de entorno y, para contribuir a la confusión del lector, lo llama
				\emph{scenario}, el mismo es configurable aunque estático, es decir, no se adapta dinámicamente a los cambios
				que experimenta el sistema en tiempo de ejecución.
				Rainbow implementa el entorno como una distribución específica de pesos relativos entre los distintos
				\emph{concerns} del sistema. A continuación se muestra un ejemplo de un entorno (\emph{scenario}) de Rainbow
				utilizado por Znn:
		
				\begin{Verbatim}[gobble=5]
					weights:
						scenario 1:
							uR: 0.35
							uF: 0.4
							uC: 0.25
						scenario 2:
							uR: 0.5
							uF: 0.3
							uC: 0.2
						scenario 2b:
							uR: 0.5
							uF: 0.2
							uC: 0.3
				\end{Verbatim}
				
				Observar que cada entorno asigna un valor a cada \emph{concern} del sistema, en donde, en este caso, \verb@uR@
				representa al Tiempo de Respuesta, \verb@uF@ a la Fidelidad de la información y \verb@uC@ al Costo. Notar que la
				sumatoria de los pesos de los distintos \emph{concerns} para cada entorno debe ser igual a 1.

				Esta información debe ser configurada en el archivo de configuración \emph{utilities.yml} utilizado por Rainbow. Aquí,
				como se puede observar, se definen más de un entorno, uno de los cuales luego deberá ser seleccionado por el
				arquitecto en el archivo de configuración \verb@rainbow.properties@ previo a la inicialización, intentando
				predecir cuáles serán las condiciones en las que el sistema deberá responder. Este entorno es utilizado por
				Rainbow al momento de seleccionar una estrategia para reparar el sistema. En la sección \ref{sec:strategySelection}
				se explica en detalle su utilización.

			\subsubsubsection{El Entorno en Arco Iris y su Importancia para la Auto Reparación}

				El concepto de \emph{scenario} de Rainbow es similar al concepto de Entorno planteada por QAS, el cual, a su vez
				ha sido extendido por Arco Iris. La diferencia fundamental radica en que, mientras en Rainbow el usuario debe
				predecir en qué entorno operará el sistema, Arco Iris lo detectará automáticamente. Más adelante en esta sección, se
				explicará en detalle cómo se lleva a cabo esta tarea.

				Concentrándonos ahora únicamente en Arco Iris, y de acuerdo a la definición de QAS, se define al \textbf{Entorno de
				Ejecución}, o simplemente, \textbf{Entorno} como el estado en el que el sistema se encuentra cuando recibe el
				estímulo que desencadena el escenario. A modo de ejemplo: al recibir una solicitud de creación de una cuenta
				bancaria el sistema puede encontrarse en ``operatoria normal'', en ``alta carga'' o quizás tal vez se encuentre
				``fuera de operación''.
				
				El entorno condiciona la validez del escenario en cuestión a que el sistema se encuentre en un determinado estado,
				ya que, por ejemplo, una respuesta esperada aceptable o fácil de cumplir bajo un entorno puede ser inaceptable o muy
				costosa en otro.
	
				En el escenario planteado en la sección anterior, si el sistema se encontrase en un entorno de ``alta carga'' el
				escenario se satisfaría trivialmente, ya que para considerar dicho escenario el sistema debería encontrarse en un
				entorno de ``operación normal''.
				
				De esta manera, el entorno del escenario es un elemento que permite a Arco Iris optimizar la búsqueda de escenarios
				que no se satisfacen en un determinado instante ante la recepción de un estímulo, ya que se ignorarán aquellos
				escenarios cuyo entorno posea condiciones que no se cumplen en dicho instante. Más adelante se profundizará sobre
				dichas condiciones.

			\subsubsubsection{Escenarios modelados con varios entornos}

				Si bien el concepto de escenario de atributo calidad, tal cual fue definido en la sección \ref{sec:QAS}, incluye
				únicamente un sólo entorno, en Arco Iris se ha decidido modelar al escenario con una \textbf{colección de
				entornos}. A fin de justificar esta decisión de diseño, supongamos que un \emph{stakeholder} desea que un
				determinado escenario sea válido en varios entornos. En ese caso, siguiendo la definición estricta de QAS dónde un
				escenario sólo posee un entorno, el \emph{stakeholder} debería crear varios escenarios idénticos, todos ellos
				difiriendo únicamente en su entorno. Esto es claramente inconveniente, más aún considerando que la cantidad de
				entornos configurables por el usuario no está acotada, lo cual podría llevar a una explosión innecesaria de
				escenarios cuasi idénticos.
				
				Ahora bien, habiendo dicho lo anterior, también puede ocurrir la situación dónde, de acuerdo al entorno de
				ejecución, se desea tener en cuenta subconjuntos distintos de estrategias de reparación. En este caso, no existe
				otra opción más que configurar distintos escenarios.
				
				Cabe destacar que, a fines de simplificar el problema y acotar así el alcance de este trabajo, en el modelo de
				Arco Iris se establece una restricción no poco importante: se presupone que el usuario de Arco Iris no cargará en el
				sistema entornos cuyas condiciones de aplicabilidad tengan intersección no nula. Esta simplificación, si bien no
				representa mayor problema a los fines de este trabajo, sí restringe futuras extensiones del mismo. La naturaleza de
				tal restricción y una posible solución son abordadas en detalle en la sección \ref{sec:flexibilizacionEntorno}.

			\subsubsubsection{Estructura y Características del Entorno}

				La estructura del entorno consiste en:
	
				\begin{itemize}
					\item Un nombre,
					\item Un conjunto de condiciones, y
					\item Un mapa \verb@<Concern, Peso>@
				\end{itemize}
	
				El \textbf{nombre} es simplemente una cadena de texto que sirve para rápidamente identificarlo.
	
				Las \textbf{condiciones} son predicados que predican sobre los valores de las propiedades del modelo de la
				arquitectura del sistema en tiempo de ejecución. Para que un sistema en ejecución se encuentre en un determinado
				entorno, deben satisfacerse \textbf{todas} sus condiciones. Para más información sobre la implementación en Arco
				Iris de las condiciones del entorno, ver la sección \ref{sec:modeloRestriccionesArcoIris}.
								
				El objetivo del \textbf{mapa de pesos} presente en la estructura del entorno es el de definir la importancia
				relativa de cada \emph{concern} cuando el sistema se encuentra en el entorno en cuestión. Dicho mapa debe contener
				todos los \emph{concerns} definidos para el sistema y la suma de sus pesos debe ser igual a uno. En la sección
				\ref{sec:arcoIrisStrategyScoring} se detalla de qué manera Arco Iris hace uso de estos pesos para escoger la mejor
				estrategia de reparación.
							
			\subsubsubsection{El Entorno ``ANY''}

				Una característica particular de Arco Iris es la de permitir expresar, mediante la selección de un pseudo-entorno
				preexistente denominado ``ANY'', que un determinado escenario aplica bajo cualquier entorno. Esto es equivalente a que
				el entorno del escenario no posea condición alguna, es decir, que el escenario aplica siempre, trivialmente, sin
				importar las condiciones actuales del sistema en ejecución. Esto puede resultar útil en algunos casos ya que simplifica
				la configuración del escenario, pero es importante tener en cuenta que, por otro lado, el rendimiento de la auto
				reparación se verá reducido puesto que el configurar uno o más entornos específicos por escenario otorga mayor precisión
				al permitir establecer la importancia (peso relativo) de cada \emph{concern} según el estado en el que el sistema se
				encuentre.
	
				El entorno ``ANY'' será asignado automáticamente al escenario si el usuario no especifica ningún entorno o, si por
				el contrario, decide explícitamente que el escenario aplique \textbf{en cualquier entorno de ejecución}. En
				cualquiera de los dos casos, Arco Iris asignará a todos los \emph{concerns} el mismo peso, con la intención de
				evitar otorgarle más importancia a algún \emph{concern} en particular. Esta decisión de equidistribuír los pesos
				relativos por \emph{concern} es, desde ya, arbitraria y se reconoce una posibilidad de mejora en vistas de un
				trabajo futuro. Para más información, ver \ref{asignacionEquidistribuidaPesos}.
	
				Para ejemplificar la importancia de configurar un entorno correctamente y no hacer abuso del pseudo-entorno ``ANY'',
				considerar, por ejemplo, un sistema el cual se encuentra bajo excesiva carga, y los \emph{stakeholders} consideran
				que bajo tales circunstancias lo más prioritario es optimizar la eficiencia del sistema. En ese caso, de no
				especificar el entorno no será posible otorgarle mayor peso a la eficiencia por sobre otros \emph{concerns},
				quedando únicamente la opción de aumentar la prioridad\footnote{se profundizará sobre este tema en la sección
				\ref{sec:priority}} de todos los escenarios relacionados con dicho \emph{concern}, tergiversando así dicha
				información, ya que en realidad lo óptimo sería asignarle más peso al \emph{concern performance} en el entorno de
				``Alta Carga''. Puesto de otra manera, el establecer que un escenario aplica en cualquier entorno, tiene como
				consecuencia que Arco Iris interprete que el entorno carece de importancia, dejando de lado los pesos de los
				\emph{concerns} y distribuyendo equitativamente su importancia relativa, lo cual es equivalente a que el concepto de
				\emph{concern} no exista.

		\subsubsection{La Cuantificación de la Respuesta en la Auto Reparación}
			\label{sec:responseMeasure}

			La \textbf{cuantificación de la respuesta} (o, en inglés, \emph{Response Measure}) es quizás la propiedad más
			importante de un escenario, de ella surgen las restricciones que deben ser evaluadas para que, en caso de no
			cumplirse, se lance la auto reparación. En pocas palabras, la cuantificación de la respuesta se define como la
			métrica según la cual se decide si la respuesta del sistema ante un determinado estímulo es aceptable o no.
			
			Para que un escenario se considere bien formado debe quedar claro cuál es la métrica o manifestación observable de su
			respuesta que se debe satisfacer. Latencia y \emph{throughput} son ejemplos de manifestaciones sobre las cuales puede
			predicar la cuantificación de la respuesta.

			Para graficar la importancia de contar con una cuantificación de la respuesta precisa, supongamos que contamos con la
			siguiente definición:

			\begin{Quote}
				``El sistema debe ser modificable para poder incorporar un nuevo generador de eventos discretos''
			\end{Quote}

			Esta premisa no es suficiente para medir el éxito de la incorporación de la nueva funcionalidad solicitada, ya que
			con suficiente tiempo y recursos, casi cualquier modificación es posible. Este escenario requiere una métrica, como
			por ejemplo: \emph{``Utilizando 160 horas/hombre''}. Esto fuerza al arquitecto a asegurar que el sistema sea
			modificable basándose en un criterio bien definido y con una métrica aplicable.

			Con respecto a la implementación, el componente más importante de la cuantificación de la respuesta es la
			restricción, cuyo modelo en Arco Iris fue anteriormente explicado en la sección
			\ref{sec:modeloRestriccionesArcoIris}.
			
			En Arco Iris las restricciones se sitúan en el contexto de un escenario de atributo de calidad, proveyendo así mayor
			visibilidad a los \emph{stakeholders}, las cuales antes se encontraban implementadas en el modelo de la arquitectura
			utilizando el lenguaje Acme, y consecuentemente, eran sólo conocidas y modificadas por los arquitectos y/o técnicos
			responsables de configurar el \emph{framework}.

			El siguiente ejemplo ha sido extraído de la arquitectura de Znn. Aquí se puede observar de qué manera se implementan
			las restricciones al utilizar Rainbow:
			
			\begin{Verbatim}[gobble=4] 
				Component Type ClientT {
					Property experRespTime : float <<  default : float = 100.0; >> ;
					rule primaryConstraint = invariant self.experRespTime <= MAX_RESPTIME;
				}
			\end{Verbatim}

			Es importante recordar que en Rainbow, una vez que se detectó que la auto reparación debe ser lanzada debido a una
			restricción que dejó de cumplirse, se volverán a evaluar todas las restricciones definidas en las precondiciones de
			\textbf{todas las estrategias} para verificar si aplican o no dependiendo del estado actual del sistema. A
			continuación se muestra un ejemplo extraído de Znn de una estrategia y su precondición:

			\begin{Verbatim}[gobble=4]
				import model "ZNewsSys.acme" { ZNewsSys as M};
				...
				define boolean cViolation =
				    exists c : ClientT in M.components | c.experRespTime > MAX_RESPTIME;
				...
				strategy BruteReduceResponseTime
				[ cViolation ] {
					...
					execute some tactic...
					...
				}
			\end{Verbatim}

			Como se puede observar, tanto la restricción en el modelo que desencadenó la auto reparación como la precondición de
			la estrategia son equivalentes, por lo que se duplica la lógica aumentando el costo de procesamiento, haciendo que la
			reparación sea más costosa y menos escalable. Además al duplicar la configuración, el costo de mantener el
			\emph{framework} es mayor.

			En Arco Iris no será necesario contar con las precondiciones de las estrategias, ya que el conocimiento de cuáles
			estrategias son capaces de reparar una determinada condición se encuentra plasmado en cada escenario. En definitiva, al
			utilizar Arco Iris el usuario accede a la posibilidad de configurar el comportamiento esperado del sistema mediante
			la cuantificación de la respuesta de cada escenario, tarea que se ve sumamente facilitada al utilizar Arco Iris UI
			(ver sección \ref{sec:arcoIrisUI}).
			Otra diferencia esencial con respecto al uso que Rainbow y Arco Iris hacen de las restricciones, es el momento en
			el que se aplican. Hemos visto anteriormente que Rainbow posee un componente llamado \emph{``Architecture
			Evaluator''}, cuya responsabilidad consiste en verificar de a intervalos la arquitectura del modelo, siempre y
			cuando éste haya sufrido algunas modificación y no se esté ya ejecutando un proceso de auto reparación, esto implica
			verificar absolutamente todas las restricciones del modelo. Arco Iris, en cambio, al descubrir un cambio en el
			modelo, verifica que los escenarios se satisfagan, pero no todos los escenarios, sino solamente aquellos cuyo
			estímulo coincida con el que desencadenó la actualización del modelo, optimizando así de manera drástica la cantidad
			de restricciones a verificar, lo que hace más escalable la auto reparación.
	\subsection{Modelo Extendido de QAS}
	\label{sec:modeloExtensionQAS}
	
		Hasta aquí se ha detallado el uso que Arco Iris hace del modelo básico de QAS, pero como se mencionó anteriormente,
		es necesario extender este modelo para agregar información de auto reparación propiamente dicha.
		
		En la figura \ref{fig:Arco_Iris_QAS_Model} se puede observar el modelo del \textbf{escenario de auto reparación}\\
		(\verb@SelfHealingScenario@), el cual, además de ser un QAS tiene toda la información y la lógica necesaria para que
		Arco Iris pueda llevar a cabo su objetivo de flexibilizar la auto reparación.

		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/Arco_Iris_QAS_Model.png}
			\caption{Modelo de Arco Iris}
			\label{fig:Arco_Iris_QAS_Model}
		\end{figure}}

		Los escenarios de auto reparación pueden ser deshabilitados, considerando Arco Iris solamente aquellos escenarios
		habilitados al momento de reparar el sistema.

		Otra propiedad utilizada por Arco Iris y que no forma parte de la definición original de un QAS, es la prioridad. Cada
		\verb@SelfHealingScenario@ tiene preestablecida su prioridad (ver sección \ref{sec:priority} para más detalle). Un
		escenario de Arco Iris también tiene el conocimiento necesario para determinar si se satisface según las condiciones
		actuales del sistema, y también para predecir si seguirá satisfaciendose luego de una potencial aplicación de una
		estrategia en particular.
		Otra extensión a QAS implementada por Arco Iris para optimizar la auto reparación consiste en que cada escenario
		conozca las estrategias que el arquitecto del sistema y los \emph{stakeholders} consideran que son capaces de reparar
		el escenario en caso de que este haya dejado de satisfacerse. En la sección \ref{sec:strategies} puede verse en detalle
		cómo Arco Iris explota esta información.
		Por último, es importante recordar que se ha extendido el concepto de \textbf{entorno} utilizado por QAS, el cual
		pasa a contar, además de con su nombre, con un conjunto de condiciones que serán utilizadas para saber si un determinado
		escenario aplica, dado su entorno, para las condiciones actuales del sistema, y además será capaz de determinar la
		importancia de cada \emph{concern} para el caso en el que el sistema en ejecución se encuentre en este entorno. Esta
		extensión ya fue explicada en detalle en la sección \ref{sec:environment}.	

	\subsection{Prioridades entre Escenarios}
	\label{sec:priority}
	
		Una característica distintiva de Arco Iris, la cual no posee contraparte alguna en Rainbow, es la de ofrecer la
		posibilidad de \textbf{priorizar escenarios} asignándoles prioridades relativas, de modo tal que al momento de escoger
		una estrategia de auto reparación la estrategia seleccionada no comprometa a alguna otra funcionalidad de la aplicación
		considerada más importante según la visión de los \emph{stakeholders}.

		Para lograr lo antedicho, a cada escenario se le asigna una prioridad, representada por un valor numérico entero
		positivo que es inversamente proporcional a la importancia que se desea asignarle al escenario. Por ejemplo, un
		escenario con prioridad 2 es considerado más prioritario que otro con prioridad 6.
		
		Si bien esta nueva funcionalidad abre nuevas posibilidades al usuario, por otro lado, la misma debe manejarse con sumo
		cuidado ya que es probable que, al configurar escenarios con prioridades \emph{muy grandes}, éstos no tengan
		prácticamente ningún peso al momento de seleccionar la estrategia de auto reparación a aplicar, con lo cual dichos
		escenarios nunca serán reparados, careciendo de sentido así su existencia.

		La prioridad del escenario es una propiedad fundamental para el correcto funcionamiento de Arco Iris, veremos su
		importancia al detallar de qué manera Arco Iris selecciona la estrategia que aplicará para reparar el sistema en la
		sección \ref{sec:strategySelection}. Por esta razón será de extrema importancia la correcta configuración de las
		prioridades relativas de los escenarios. Se recomienda realizar la asignación de la prioridad de cada escenario como
		un paso más del Quality Attribute Workshop (QAW), para más detalle ver la sección \ref{sec:QAW}.

	\subsection{Estrategias y su Relación con los Escenarios}
	\label{sec:strategies}

		Antes de profundizar en el impacto de los escenarios en la selección de la estrategia para reparar el sistema,
		repasaremos brevemente cómo se utilizan las mismas en Rainbow.

		Las estrategias en Rainbow tienen un conjunto de precondiciones que nos indican si dicha estrategia puede ser
		utilizada para reparar el sistema en un determinado momento. Esto implica que, en cuanto Rainbow detecta un problema
		en el sistema, deba recorrer todas las estrategias existentes para ver si son aplicables para las condiciones
		actuales. En otras palabras, Rainbow no tiene forma de determinar \textbf{a priori} el subconjunto de estrategias
		candidatas a reparar el sistema en el preciso momento en que una o más restricciones sobre el modelo de la
		arquitectura del sistema se dejan de cumplir. Por ende, todas las estrategias disponibles, pasan a ser candidatas.
		
		Por ejemplo, para que una estrategia que soluciona problemas de eficiencia no sea tenida en cuenta al reparar un
		escenario relacionado a un atributo de calidad distinto, como por ejemplo la mantenibilidad, debe agregarse una
		precondición como la siguiente en la estrategia:

		\begin{Verbatim}[gobble=3]
			strategy SimpleReduceResponseTime
			[ responseTimeConstraintViolation ] {
			...
			}
		\end{Verbatim}

		Donde \emph{responseTimeConstraintViolation} es un predicado que permite determinar si existe algún cliente cuyo tiempo
		de respuesta haya sobrepasado el umbral máximo permitido:

		\begin{Verbatim}[gobble=3]
			define boolean responseTimeConstraintViolation =
						exists c : T.ClientT in M.components | c.experRespTime > M.MAX_RESPTIME;
		\end{Verbatim}

		Con respecto al anterior ejemplo, es importante remarcar que, en caso de que el problema que se está intentando reparar
		no tenga relación con la eficiencia, Rainbow deberá de todos modos chequear el tiempo de respuesta de todos los
		clientes, mientras que en Arco Iris existe la posibilidad de evitarlo al configurar correctamente las estrategias
		que reparan a cada escenario.
			
		Como ya se ha mencionado, en Arco Iris si bien se utilizan el mismo tipo de tácticas y estrategias que en Rainbow (i.e.
		implementadas con Stitch), se propone desacoplar la detección del problema de su solución utilizando como medio para
		ello los escenarios de atributos de calidad. Allí se definen las condiciones para la detección del problema (restricciones
		dentro de la cuantificación de la respuesta) y se referencian las posibles estrategias de reparación a ser
		consideradas para su ejecución, en el caso de que el escenario en cuestión se vea comprometido. De esta forma, las
		estrategias quedan exentas de conocer cuáles son las circunstancias en las que su ejecución tiene sentido. Esto permite
		al arquitecto tener un mayor control sobre las estrategias a ejecutar en determinadas condiciones, ya que al situarse en
		un escenario concreto, él sabrá cuales serán las soluciones más adecuadas basándose en el entorno del sistema y en la
		prioridad del escenario en cuestión.
				
		Cabe acotar que Arco Iris también ofrece la posibilidad de configurar el mismo comportamiento brindado por Rainbow: esto
		se logra simplemente indicando la opción que representa a ``todas las estrategias existentes'' cuando se configura el
		escenario (una forma sencilla de especificar ésto, utilizando Arco Iris UI, se explica en la sección
		\ref{sec:strategySelectionUI}). Implementativamente hablando, basta sólo con asignarle al escenario la única instancia
		de la clase \verb@AllRepairStrategies@.
		
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/RepairStrategiesHierarchy.png}
			\caption{Jerarquía de Estrategias de Reparación en Arco Iris}
			\label{fig:RepairStrategiesHierarchy}
		\end{figure}
				
		En Arco Iris, para poder escribir estrategias que involucren varias tácticas, el usuario contará con un mecanismo que
		le permitirá verificar si los escenarios de un determinado \emph{concern}, y que han sido marcados para reparar,
		siguen aún sin cumplirse. En base a esta información la estrategia podrá decidir cómo continuar su ejecución. A
		continuación se muestra un ejemplo de su utilización:

		\begin{Verbatim}[gobble=3]
			import op "org.sa.rainbow.adaptation.ArcoIrisAdaptationManager";
			...
			define boolean RESP_TIME_STILL_BROKEN =
					ArcoIrisAdaptationManager.isConcernStillBroken("RESPONSE_TIME");
			...
			/*
			 * This Strategy will drop fidelity once, observe, then drop again if necessary.
			 */
			strategy BruteReduceResponseTime {
			  t0: (true) -> lowerFidelity(2, 100) @[5000 /*ms*/] {
			    t1: (!RESP_TIME_STILL_BROKEN) -> done;
			    t2: (RESP_TIME_STILL_BROKEN) -> lowerFidelity(2, 100) @[8000 /*ms*/] {
			      t2a: (!RESP_TIME_STILL_BROKEN) -> done;
			      t2b: (default) -> TNULL;  // in this case, we have no more steps to take
			    }
			  }
			}
			...
			\end{Verbatim}

		Como se puede observar en el código, para que este mecanismo funcione, es necesario importar la función
		\verb@isConcernStillBroken@ de la clase \verb@ArcoIrisAdaptationManager@, cuya implementación se verá a continuación.
		Notar que el usuario solamente deberá indicar cual es el \emph{concern} de su interés:

		\begin{Verbatim}[gobble=3]
			public static boolean isConcernStillBroken(String concernString) {
				Concern concern = Concern.valueOf(concernString);

				boolean result = false;
				for (SelfHealingScenario scenario : currentBrokenScenarios) {
					if (scenario.getConcern().equals(concern) &&
							scenarioBrokenDetector4CurrentSystemState.isBroken(scenario)) {
						result = true;
						break;
					}
				}
				return result;
			}
		\end{Verbatim}

	\subsection{Activación del Mecanismo de Auto Reparación}

		\subsubsection{Introducción}

			Con el nuevo enfoque presentado en este trabajo, donde el \emph{Escenario} es el concepto central, es necesario
			establecer cambios en la lógica aplicada por el \emph{framework} al momento de evaluar restricciones para determinar
			si es necesario auto reparar el sistema.
	
			En Rainbow, como ya hemos visto, las restricciones del sistema se encuentran embebidas en el modelo de su
			arquitectura, escrito en lenguaje Acme. Por ejemplo, para especificar que el tiempo de respuesta no debe exceder un
			determinado umbral es necesario definir una restricción en el tipo de componente \verb@ClientT@, quien es el que
			posee dicha propiedad (i.e. \verb@experRespTime@, el tiempo de respuesta experimentado por un cliente). En el
			siguiente ejemplo tomado de la arquitectura de Znn, se puede apreciar la declaración de tal restricción:
	
			\begin{Verbatim}[gobble=4]
				Component Type ClientT {

					Property experRespTime : float <<  default : float = 100.0; >> ;

					rule primaryConstraint = invariant self.experRespTime <= MAX_RESPTIME;
				}
			\end{Verbatim}
	
			En Arco Iris ya no es necesario definir estas restricciones en la arquitectura, desacoplando así la arquitectura
			del sistema de la definición de condiciones a evaluar para lanzar la auto reparación. Como se ha explicado en la
			sección \ref{sec:responseMeasure}, ahora las restricciones están presentes en la \emph{Cuantificación de la
			Respuesta} de cada escenario. con el fin de dar mayor visibilidad a los \emph{stakeholders} del sistema. Para esto,
			se añade la posibilidad de definir las restricciones de manera visual utilizando la herramienta Arco Iris UI (más
			detalles en la sección \ref{sec:arcoIrisUI_constraints}).

		\subsubsection{Desarrollo}
		\label{sec:desarrolloMecanismoAutoReparacion}

			Para determinar si el sistema necesita auto repararse, Rainbow utiliza una funcionalidad ofrecida por ACME, que
			permite evaluar las restricciones descritas en el modelo de la arquitectura. Dicha funcionalidad es provista por una
			herramienta llamada \emph{Type Checker}. A continuación podemos observar una versión simplificada de cómo Rainbow se
			sirve de esta utilidad para decidir si debe lanzar la auto reparación o no:
	
			\begin{Verbatim}[gobble=4]
				public class RainbowModel {
					...
					RainbowModel() {
						...
						this.m_acme = /* parse the model from a .acme file */
						this.m_acmeEnv.getTypeChecker().registerModel(this.m_acme);
						// only consider the first system found on the .acme file
						this.m_acmeSys = this.m_acme.getSystems().iterator().next();
						...
					}

					public void evaluateConstraints () {
						SynchronousTypeChecker typechecker = m_acmeEnv.getTypeChecker();
						typechecker.typecheckAllModelsNow();
						this.m_constraintViolated = !typechecker.typechecks(m_acmeSys);
						if (this.m_constraintViolated) {
							Set errors = m_acmeEnv.getAllRegisteredErrors();
							Oracle.instance().writeEvaluatorPanel(m_logger, errors.toString());
						}
					}
					...
				}
			\end{Verbatim}
	
			El componente \verb@ArchEvaluator@, luego de invocar al método \verb@evaluateConstraints@ visto más arriba, y
			habiendo comprobado además que no existe un proceso de adaptación ejecutándose en el sistema, invocará al
			\verb@AdaptationManager@ para que inicie dicho proceso.
	
			Por los motivos explicados en la sección \ref{sec:modeloRestriccionesArcoIris}, Arco Iris no hace uso de este
			mecanismo de \emph{parseo} de restricciones y en cambio, maneja su propio modelo simplificado de restricciones, el
			cual se encuentra desacoplado del modelado de la arquitectura. Estas restricciones (o \emph{constraints}) serán de
			vital importancia al momento de activar el mecanismo de auto reparación.
			
			Al iniciar, Arco Iris carga todos los escenarios definidos en su configuración (para más detalle, ver la sección
			\ref{sec:configuracionArcoIris}), y arma un mapa que le permitirá optimizar las verificaciones recurrentes de los
			escenarios ante la llegada de cada estímulo. El mapa almacena todos los escenarios correspondientes a cada estímulo,
			así, ante la invocación de un estímulo en el sistema, Arco Iris sólo deberá verificar que se cumplan los escenarios
			relacionados con aquel estímulo, acotando así de manera sustancial la cantidad de restricciones a verificar.
	
			Paso a paso, el proceso de activación de la auto reparación en Arco Iris consiste en lo siguiente:
			\begin{enumerate}
				\item En el sistema en ejecución ocurre un evento, y uno o más \emph{probes} de Arco Iris lo detectan y publican
				información sobre dicho evento en una cola compartida (ya existente en Rainbow).
				\item Un \emph{gauge} configurado para ``escuchar'' este tipo de eventos, toma el mensaje de la cola y lo traduce a
				otro mensaje que consiste en una tripla \verb@<Propiedad,Valor,Estímulo>@, la cual a su vez será depositada en otra
				cola compartida entre todos los \emph{gauges}.
				\item El componente \verb@ArcoIrisGaugeCoordinator@ chequea periódicamente esta última cola en búsqueda de
				nuevas instrucciones para actualizar el modelo arquitectural con los cambios ocurridos en \emph{runtime}. Al encontrar el
				mensaje dejado por el \emph{gauge},informará a \verb@ArcoIrisModel@ (una extensión de \verb@RainbowModel@) sobre
				dicho cambio de propiedad y el estímulo que lo generó.
				\item
					\begin{enumerate}
						\item Suponiendo que no existe un proceso de adaptación en progreso, \verb@ArcoIrisModel@ procede a actualizar el
						valor de la propiedad en cuestión en el modelo de la arquitectura del sistema, utilizando la información presente
						en la anteriormente mencionada tripla.
						\item En el caso en que ya exista un proceso de adaptación ejecutándose, \verb@ArcoIrisModel@ no toma ninguna
						acción ante el pedido de actualizar el valor de la propiedad en cuestión, puesto que el sistema se encuentra en un
						estado inestable debido a las reparaciones en curso y el modificar los valores a algunas propiedades del modelo
						podría llegar a ser perjudicial. En otras palabras, cuando se lanza la adaptación, no se reciben mas
						actualizaciones sobre el modelo hasta que dicha adaptacion finalice.
					\end{enumerate}
				\item Además de actualizar el valor de o de las propiedades en el modelo arquitectural, \verb@ArcoIrisModel@ busca
				aquellos escenarios que puedan llegar a verse afectados por el estímulo que desencadenó el cambio de propiedad en el
				modelo (recordemos que dicho estímulo está presente en la tripla que le llega a \verb@ArcoIrisModel@).
				\item Una vez identificados los escenarios potencialmente afectados, se verifica que se cumplan las restricciones
				expresadas en la \textbf{cuantificación de la respuesta}, siempre y cuando el entorno del escenario coincida con el
				entorno en el que se encuentra el sistema actualmente, de lo contrario, el escenario se considera verificado
				automáticamente.
				\item En caso de detectar que uno o más escenarios dejaron de cumplirse, el \verb@ArcoIrisModel@ notifica al
				\verb@ArcoIrisAdaptationManager@ (una extensión del \verb@AdaptationManager@ de Rainbow) para que inicie la auto
				reparación del sistema.
				\item En primer término, el \verb@ArcoIrisAdaptationManager@ debe decidir cuál será la estrategia más conveniente a
				aplicar, es decir, qué estrategia maximiza la \emph{Utilidad del Sistema} (ver \ref{sec:systemUtility}) en el
				entorno de operación actual. Tanto este proceso como el concepto de \emph{Utilidad del Sistema} serán cubiertos en
				detalle en las siguientes dos secciones.
			\end{enumerate}

			\begin{figure}[H]
				\centering
					\includegraphics[width=0.90\textwidth]{images/SelfHealingActivation.png}
				\caption{Activación de la estrategia de reparación en Arco Iris}
				\label{fig:SelfHealingActivation}
			\end{figure}

	\subsection{Selección de la Estrategia}
	\label{sec:strategySelection}
	
		Arco Iris selecciona la estrategia a aplicar para reparar el sistema, de un manera sustancialmente diferente a cómo lo
		hace Rainbow. Para comenzar, Rainbow considera todas las estrategias existentes mientras que Arco Iris se limita a
		considerar únicamente las estrategias propuestas en el escenario que se ha dejado de satisfacer.
		
		Ahora bien, una vez determinado el subconjunto de estrategias a considerar, es necesario asignarle un valor a cada
		una para poder compararlas y seleccionar la estrategia, que luego de ser aplicada, maximice el rendimiento del
		sistema. Para esto, se definirá el concepto de \emph{Utilidad del Sistema} y se presentará la heurística propuesta
		para su cálculo en Arco Iris.

		\subsubsection{Utilidad del Sistema}
		\label{sec:systemUtility}

			Rainbow utiliza la \textbf{teoría de la utilidad}, concepto forjado en el estudio de la economía, que permite asignar
			una medida relativa de satisfacción (i.e. \emph{utilidad}) sobre un sistema sobre el cual es necesario medir el
			impacto ante determinados cambios.
			
			En Rainbow, un sistema brinda un 100\% de utilidad cuando cumple todos sus requerimientos y no viola ninguna de las
			restricciones planteadas para el mismo. Desde la perspectiva de Arco Iris, la utilidad se maximiza cuando todos los
			escenarios definidos se cumplen, consecuentemente, en la medida en que los escenarios dejan de cumplirse, la utilidad
			del sistema baja.
			
			Rainbow posee un mecanismo que permite predecir cuál estrategia dejaría al sistema en una mejor situación, de acuerdo
			al valor arrojado por el cálculo de la utilidad del sistema luego de la supuesta ejecución de cada una de las
			estrategias candidatas. Si bien este mecanismo de predicción es reutilizado por Arco Iris, el cálculo de la utilidad
			del sistema, propiamente dicho, es sustancialmente diferente. 

			En el archivo de configuración llamado \verb@utilities.yml@, Rainbow permite configurar:
			\begin{itemize}
				\item cúales son los \emph{concerns} que manejará el sistema y la propiedad del modelo de la arquitectur asociada a
				él.
				\item como se vió anteriormente en la sección \ref{sec:environment}, se especifican distintos entornos de ejecución
				estáticos, esto es, se configura el entorno predecido de ejecución antes de iniciar el \emph{framework} y
				dicho entorno no cambia de acuerdo a la situación real del sistema en \emph{runtime}. Estos entornos estáticos
				(llamados ``scenarios'', que nada tienen que ver con los escenarios de Arco Iris) son ni más ni menos que un
				diccionario que especifica qué peso (o importancia) tiene en el sistema cada \emph{concern}.
				\item por cada uno de los \emph{concerns} que manejará el sistema, se define una función de utilidad, la cual, dada
				un valor de la propiedad del modelo relacionada (e.g. tiempo de respuesta), arroja un valor entre 0 y 1, cuyo uso se
				explicará en breve.
			\end{itemize}			

			Se observa a continuación, un ejemplo de una configuración de este tipo, tomada de Znn:

			\begin{Verbatim}[gobble=4]
				...
				utilities:
					uR:
						label:       Average Response Time
						mapping:     "[EAvg]ClientT.experRespTime"
						description: "Client experienced response time in milliseconds, R, defined as
						              a float property 'ClientT.experRespTime' in the architecture"
						utility:
							0:    1.00
							100:  1.00
							200:  0.99
							500:  0.90
							1000: 0.75
							1500: 0.50
							2000: 0.25
							4000: 0.00
					uF:
						label:        Average Fidelity
						mapping:      "[EAvg]ServerT.fidelity"
					...
					weights:
						scenario 1:
							uR: 0.35
							uF: 0.4
							uC: 0.25
						scenario 2:
							uR: 0.5
							uF: 0.3
							uC: 0.2
					...
			\end{Verbatim}

			En las primeras líneas se observa la configuración del \emph{concern} tiempo de respuesta, cuyo identificador
			será \verb@uR@ y la propiedad del modelo con la cual se corresponde es \verb@experRespTime@ del tipo de componente
			\verb@ClientT@. A continuación se encuentra definida la función de utilidad para dicho \emph{concern}, la cual, dado
			un valor de tiempo de respuesta en milisegundos, retorna un valor interpolado entre 0 y 1, que determina el
			porcentaje de utilidad que el sistema brinda para el \emph{concern} en cuestión; dónde 0 representa ausencia de
			utilidad alguna y 1 representa que el sistema brinda el máximo de utilidad posible. Por ejemplo, para un tiempo
			de respuesta de 2000 milisegundos, el sistema brinda un 25\% de la utilidad para dicho \emph{concern}.

			Se observa también la configuración estática de entornos de ejecución (denominados \emph{scenarios} por Rainbow), la
			cual fue explicada en detalle en la sección \ref{sec:environment}. Recordar que uno de estos entornos será
			seleccionado en la configuración de Rainbow como el entorno actual y, por ende, sus pesos serán utilizados en el
			cálculo de la \emph{Utilidad del Sistema}, cuyo pseudocódigo se presenta a continuación:

			\begin{Verbatim}[gobble=4]
				utilidadDelSistema = 0
				valoresPorConcern = valores actuales del sistema para cada concern (e.g. uR=1500, uF=5)
				Por cada concern
					uf = Funcion de Utilidad para el concern actual
					valorConcern = valoresPorConcern.get(concern) (e.g. 1500)
					valorUtilidad = uf(valorConcern) (e.g. 0.50)
					valorPonderado = valorUtilidad * peso estático asignado al concern (e.g. 0.35)
					utilidadDelSistema = utilidadDelSistema + valorPonderado
			\end{Verbatim}

			El concepto de \emph{Utilidad del Sistema} es clave para comprender los mecanismos utilizados por Rainbow y Arco Iris
			para puntuar las estrategias candidatas a ser elegidas para reparar una situación anómala del sistema que se está
			adaptando.

		\subsubsection{Puntuación de Estrategias según Rainbow}
		\label{sec:rainbowStrategyScoring}

			Una vez obtenido el subconjunto de estrategias aplicables, Rainbow procede a asignarle un puntaje a cada una y luego
			\textbf{aplica la estrategia de mayor puntaje}.

			Para calcular el puntaje de una estrategia, Rainbow obtiene dos datos:
			\begin{enumerate}
				\item \label{pesosEstaticos} los pesos asignados a cada \emph{concern} de acuerdo al entorno estáticamente
				configurado antes de que inicie el \emph{framework}. (para más detalle sobre estos pesos, remitirse a la sección
				\ref{sec:environment})
				\item \label{estimaciones} calcula estimaciones del valor de cada \emph{concern} luego de la potencial aplicación de
				la estrategia en cuestión y aplica a dichos valores las respectivas funciones de utilidad definidas en el archivo
				de configuración \verb@utilities.yml@. (ver sección \ref{sec:systemUtility})
			\end{enumerate}

			Para estimar el valor de cada \emph{concern} luego de la ejecución de una determinada estrategia sobre el sistema, y
			considerando que las estrategias se componen de tácticas, cada táctica deberá explicitar los \emph{concerns} sobre
			los cuales impacta y en qué medida lo hace. Por ejemplo, en el caso de ``bajar un servidor'' en Znn se especifica la
			siguiente meta información asociada a la táctica, representando el impacto estimado sobre el sistema:
			\begin{Verbatim}[gobble=4]
				dischargeServers:
					uR: +144
					uF: 0
					uC: -1.00
			\end{Verbatim}

			Esto significa que una vez ejecutada esta táctica, y de manera aproximada, la eficiencia se verá degradada en
			144 milisegundos y la fidelidad permanecerá intacta, mientras que el costo se reducirá en 1 unidad.

			A fin de comprender la heurística aplicada por Rainbow para obtener las estimaciones explicadas en el punto
			\ref{estimaciones}, es útil recordar que las estrategias poseen líneas etiquetadas (e.g. \verb@t0, t1@, etc...), las
			cuáles pueden entenderse como ``ramas'' del algoritmo, por ejemplo:
			
			\begin{Verbatim}[gobble=4]
				strategy SimpleReduceResponseTime
				[ cViolation ] {
				  t0: (/*hiLoad*/ cViolation) -> enlistServers(1) @[1000 /*ms*/] {
				    t1: (!cViolation) -> done;
				    t2: (/*hiRespTime*/ cViolation) -> lowerFidelity(2, 100) @[3000 /*ms*/] {
				      t2a: (!cViolation) -> done;
				      t2b: (default) -> TNULL;  // in this case, we have no more steps to take
				    }
				  }
				}
			\end{Verbatim}
			
			Así, Rainbow estima el valor de cada \emph{concern} para una estrategia dada, considerando a) la
			\textbf{probabilidad} que tiene cada rama de la estrategia de ser ejecutada y b) los atributos de las tácticas
			presentes en cada rama, esto es, el impacto que cada táctica tiene sobre los \emph{concerns} del sistema. Estos
			valores luego serán ponderados por el peso estático de cada \emph{concern} (punto \ref{pesosEstaticos}) para obtener
			finalmente el puntaje de la estrategia.
			
			Se presenta a continuación, el pseudocódigo del cálculo de puntuación de una estrategia llevado a cabo por Rainbow:
			\begin{Verbatim}[gobble=4]
				puntaje = 0
				estimacionPorConcern = Estimar los valores para cada concern luego de aplicar la estrategia
				Por cada concern
					uf = Funcion de Utilidad para el concern actual
					estimacion = estimacionPorConcern.get(concern)
					valorUtilidad = uf(estimacion)
					valorPonderado = valorUtilidad * peso asignado al concern en la config. estática de Rainbow
					puntaje = puntaje + valorPonderado
			\end{Verbatim}

		\subsubsection{Puntuación de Estrategias según Arco Iris}
		\label{sec:arcoIrisStrategyScoring}

		\todo{TURCO y JONY: continuar revisando desde aca}

			En el caso de Arco Iris el primer paso será calcular la utilidad del sistema antes de iniciar la auto reparación,
			asegurándose así de que la estrategia a aplicar no perjudique el rendimiento actual de la aplicación, esto es, la
			estrategia que resulte tener la puntuación máxima deberá mejorar la utilidad del sistema, de lo contrario Arco Iris
			no procederá a ejecutarla.

			La heurística aplicada por Arco Iris para el cálculo de la puntuación de una estrategia utilizará el conocimiento
			plasmado en los escenarios para determinar la mejor estrategia de reparación a aplicar, teniendo en cuenta
			lo siguiente:
			\begin{itemize}
				\item el impacto estimado de la potencial ejecución de la estrategia sobre el sistema, calculado de la misma forma
				que Rainbow (ver sección \ref{sec:rainbowStrategyScoring}),
				\item el entorno de ejecución en el que se encuentra la aplicación y el peso que cada \emph{concern} tiene para
				dicho entorno,
				\item el \emph{concern} asociado al escenario, y
				\item las prioridades relativas entre los escenarios.
			\end{itemize}

			Es importante mencionar que para calcular la utilidad del sistema, Arco Iris sólo considerará aquellos escenarios que
			se encuentren ``habilitados''(o \emph{enabled}, en el modelo de Arco Iris presentado en la figura
			\ref{fig:Arco_Iris_QAS_Model}). En otras palabras, para calcular la utilidad del sistema, Arco Iris asignará un
			determinado puntaje a cada escenario habilitado que se satisfaga, el resto de los escenarios serán ignorados, o lo
			que es equivalente, tendrán puntaje cero.
			
			Por cada escenario habilitado, Arco Iris verificará si el mismo aplica para el entorno actual del sistema, en caso de
			no aplicar el escenario se satisface trivialmente, por lo que sumará a la utilidad del sistema. Para los escenarios
			que sí apliquen al entorno actual, Arco Iris evaluará si las restricciones establecidas en la cuantificación de la
			respuesta del escenario se satisfacen y sólo en caso afirmativo sumarán a la utilidad del sistema.

			Ahora bien, una vez que se tienen los escenarios que pesarán sobre la utilidad del sistema, veamos cómo Arco Iris
			asignará un puntaje (\emph{score}) a cada uno. A continuación se puede ver plasmado en pseudocódigo el cálculo del
			puntaje de un escenario y como es utilizado para calcular el puntaje de la estrategia y a su vez como Arco Iris
			seleccionará la estrategia de mayor puntaje para reparar el sistema:

			\begin{Verbatim}[gobble=4]
				scoreMaximo = utilidad actual del sistema

				Por cada estrategia
					scoreStrategia = 0
					estimacionPorConcern = simular la aplicación de la estrategia como lo hace Rainbow y
					                       obtener el valor resultante para los concerns

					Por cada escenario habilitado
						Si (no aplica al entorno actual o
						    aplica al entorno actual y la cuantificación de la respuesta se satisface)

							prioridadRelativa = calcular prioridad relativa del escenario
							pesoConcern = peso que el entorno actual asigna al concern del escenario
							scenarioConcern = concern del escenario
							uf = funcion de utilidad para el concern del escenario
							utilidad = uf(estimacionPorConcern(scenarioConcern))
							puntajeEscenario = utilidad * prioridadRelativa * pesoConcern
							scoreStrategia = scoreStrategia + puntajeEscenario
						Fin
					Fin

					Si scoreStrategia > scoreMaximo
						estrategiaSeleccionada = estrategia actual
					Fin
				Fin
			\end{Verbatim}

			Como se dijo anteriormente, si la mejor estrategia no agrega más utilidad que la actual, Arco Iris no aplica
			ninguna estrategia. Luego, por cada estrategia, Arco Iris simulará su aplicación reutilizando para este punto la
			implementación de Rainbow. Lo importante de la simulación es obtener los valores estimados para cada \emph{concern},
			los cuales se almacenan en un diccionario \verb@<Concern, Estimación>@.

			Una vez obtenidos los valores estimados, Arco Iris iterará por los escenarios habilitados y por cada escenario que se
			satisfaga\footnote{Aquí, que un escenario se ``satisfaga'' significa que o bien el entorno del escenario no coincide
			con el actual, o bien, si coincide y la cuantificación de la respuesta del escenario se satisface} deberá
			calcular la \textbf{prioridad relativa} del escenario. Recordemos que cada escenario posee una prioridad asignada,
			pero esa prioridad no puede ser tomada directamente para calcular la Utilidad del Sistema ya que aquellos escenarios
			cuyas prioridades son numéricamente menores, poseen una mayor importancia para los \emph{stakeholders}. Para
			calcular la prioridad relativa y permitir extender y/o modificar la lógica de su cálculo, se ha definido la interfaz
			\verb@ScenarioRelativePriorityAssigner@, la cual define el siguiente método:

			\begin{Verbatim}[gobble=4]
				public abstract int relativePriority(SelfHealingScenario scenario);
			\end{Verbatim}

			Por defecto se provee la implementación \verb@DefaultScenarioRelativePriorityAssigner@, que calcula la prioridad
			relativa pesando los valores absolutos de las prioridades de los escenarios contra el escenario de menor prioridad,
			esto es, el escenario con máxima prioridad numérica entre todos los escenarios:

			\begin{Verbatim}[gobble=4]
				public class DefaultScenarioRelativePriorityAssigner
				         implements ScenarioRelativePriorityAssigner {

					private SelfHealingConfigurationManager selfHealingConfigurationManager;
				
					public DefaultScenarioRelativePriorityAssigner(SelfHealingConfigurationManager shcm) {
						this.selfHealingConfigurationManager = shcm;
					}

					@Override
					public int relativePriority(SelfHealingScenario scenario) {
						int maxPriority = selfHealingConfigurationManager.getMaxPriority() + 1;
						return (maxPriority - scenario.getPriority()) / maxPriority;
					}
				}
			}
			\end{Verbatim}

			Algunas aclaraciones:
			\begin{itemize}
				\item en la sección siguiente se entrará en detalle sobre el rol que cumple en Arco Iris el objeto
				\verb@SelfHealingConfigurationManager@.
				\item se toma como prioridad máxima la del escenario menos prioritario, más uno, para evitar que la prioridad
				relativa de dicho escenario sea cero y que sea ignorado en el cálculo de la Utilidad del Sistema.
			\end{itemize}

			Una vez calculada la prioridad relativa del escenario, el siguiente paso será obtener el peso que el entorno actual
			asigna al \emph{concern} del escenario en cuestión. Por ejemplo, si el entorno actual es de alta carga, es lógico que
			los escenarios de eficiencia tengan un mayor peso que los escenarios de costo, por esto se pesan los escenarios según
			su \emph{concern} y el entorno en el que se encuentra el sistema.

			Luego, al igual que Rainbow, Arco Iris aplicará la función de utilidad al valor estimado por la simulación para el
			\emph{concern} del escenario en cuestión, pero además de ponderar la dicha utilidad con el peso del \emph{concern}
			(que en Rainbow es estático mientras que en Arco Iris dependerá del entorno actual del sistema), Arco Iris
			considerará también la prioridad relativa del escenario. Finalmente, el valor obtenido será acumulado al puntaje de
			la estrategia, escogiendo para reparar el sistema a aquella estrategia que posea el puntaje máximo.
			
			La estrategia elegida hace uso de \emph{Effectors}, que consisten en pequeñas piezas de software diseñadas
			especialmente para interactuar de manera directa con el sistema en ejecución.

	\subsection{Modelo de Adaptación de Arco Iris}

		\todo{No se mencionó que que hay un ScoreAssigner para el estado actual y otro para scorear la estrategia, cuando
		lleguemos acá vemos si ya se explicó.}
		
		En la figura \ref{fig:Arco_Iris_Adaptation_Model} se presenta el modelo conceptual de la adaptación
		llevada a cabo por Arco Iris, el cual ha sido desarrollado en detalle hasta aquí.
		
		\todo{Actualizar figura: en la imagen falta la invocacion de Arco Iris Model a Arco Iris Adaptation Manager}
		
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/Arco_Iris_Adaptation_Model.png}
			\caption{Modelo de Adaptación de Arco Iris}
			\label{fig:Arco_Iris_Adaptation_Model}
		\end{figure}

	\subsection{Configuración de Arco Iris}
	\label{sec:configuracionArcoIris}
	
		La configuración de Arco Iris se encuentra modelada en \verb@SelfHealingConfiguration@, el cual que posee la siguiente
		estructura:

		\begin{figure}[H]
			\centering
				\includegraphics[width=0.50\textwidth]{images/SelfHealingConfiguration.png}
			\caption{Estructura de la configuración de Self Healing utilizada por Arco Iris}
			\label{fig:SelfHealingConfiguration}
		\end{figure}		

		A fin de simplificar y amenizar para el usuario la creación y edición de la configuración que Arco Iris utiliza, se
		provee la herramienta Arco Iris UI, la cuál será explicada en detalle en la sección \ref{sec:arcoIrisUI}.

		Arco Iris obtiene todo lo que necesita de la configuración utilizando un objeto llamado
		\verb@SelfHealingConfigurationManager@, el cual funciona como un intermediario entre el archivo de configuración y los
		componentes centrales de Arco Iris. A continuación, se enumeran algunas de las funcionalidades más importantes de
		\verb@SelfHealingConfigurationManager@:
		\begin{itemize}
			\item \verb@findBrokenScenarios@: Dado un estímulo, obtiene la colección de escenarios con dicho estímulo que no se
			cumplen. Este método es invocado desde \verb@ArcoIrisModel@ al momento de actualizar una propiedad en el modelo de la
			arquitectura del sistema a adaptar.(ver sección \ref{sec:desarrolloMecanismoAutoReparacion})
			\item \verb@getEnabledScenarios@: Obtener todos los escenarios que se encuentran habilitados. Este método es invocado
			desde \verb@ArcoIrisAdaptationManager@ durante el cálculo de la utilidad del sistema.(ver sección
			\ref{sec:arcoIrisStrategyScoring})
			\item \verb@getMaxPriority@: obtiene la prioridad de mayor valor absoluto configurada en alguno de los escenarios de
			la configuración subyacente. Este método es utilizado por\\
			\verb@DefaultScenarioRelativePriorityAssigner@ para el cálculo de la prioridad relativa de un escenario.(ver sección
			\ref{sec:arcoIrisStrategyScoring})
		\end{itemize}

		En el apéndice \ref{sec:SelfHealingConfigXML}, se puede observar un ejemplo de un archivo de configuración de
		\emph{Self Healing}.

		\subsubsection{Formato del Archivo de Configuración}
		\label{sec:formatoArchivoConfiguracion}

			El archivo de configuración de \emph{Self Healing} que Arco Iris acepta, debe tener un formato. Se ha
			decidido que el mejor formato para dicho archivo es el formato XML porque es un formato entendible no sólo por
			sistemas de \emph{software} sino también por personas. Esto es particularmente útil en el caso en que el usuario
			desee efectuar retoques mínimos sobre la configuración y no desee o, por algún motivo, no pueda ejecutar la
			herramienta Arco Iris UI. Dentro de este tipo de lenguajes de marcas (dónde se encuentran otros como JSON o
			YAML\footnote{Para más información sobre estos lenguajes de intercambio de datos, visitar \url{http://www.json.org/}
			o \url{http://www.yaml.org/}}) se elige el formato XML por ser el más ampliamente conocido.

		\subsubsection{Mecanismo de Lectura de la Configuración}
		\label{sec:lecturaConfiguracion}

			La clase \verb@SelfHealingConfigurationPersister@ provee un método (\verb@readFromFile@) para leer un archivo XML de
			configuración de \emph{Self Healing} y otro método (\verb@saveToFile@) para escribir una configuración en Java a un
			archivo XML. Para ambos fines, la clase utiliza el reconocido parser ``XStream'' \footnote{Para más información,
			visitar \url{http://xstream.codehaus.org/}}, el cual permite fácilmente convertir objetos Java en XML y viceversa.

		\subsubsection{Actualización Dinámica de Configuración}
		\label{sec:actualizacionDinamicaConfig}

			Una de las principales limitaciones de Rainbow es la imposibilidad de actualizar la configuración del \emph{framework}
			sin tener que reiniciar su ejecución. A fin de superar (al menos parcialmente) tal limitación, proponemos un simple
			mecanismo de detección de cambios en el archivo de configuración de Arco Iris, el cual, al detectar cualquier cambio en
			dicho archivo, \textbf{reemplazará dinámicamente la configuración de Arco Iris cargada en memoria por la nueva
			configuración}; todo esto sin necesidad de reiniciar el \emph{framework}.

			El mecanismo se ejecuta periódicamente cada $X$ milisegundos, siendo $X$ configurable utilizando el archivo de
			configuración estándar de Rainbow \verb@rainbow.properties@. La propiedad a configurar recibe el nombre
			de \verb@customize.scenarios.reloadInterval@, cuyo valor inicial por defecto será $5000$, es decir, el mecanismo de
			actualización se ejecutará cada 5 segundos.

			Se utiliza el patrón \emph{Observer}\footnote{Para más información acerca del patrón Observer, visitar
			\url{http://en.wikipedia.org/wiki/Observer_pattern}} como modo de notificar a todos aquellos objetos interesados en
			llevar a cabo alguna acción como consecuencia de un cambio en la configuración. El componente (\emph{observer}
			siguiendo la nomenclatura utilizada comúnmente en el patrón) más interesado en conocer cuando un cambio en la
			configuración tiene lugar es el denominado \verb@SelfHealingConfigurationManager@, el cual, en ese caso, descarta
			toda la configuración de los escenarios cargada en memoria, tomando luego la nueva configuración del archivo
			recientemente actualizado. A partir de este momento Arco Iris continuará trabajando con la nueva configuración de
			escenarios sin detener en ningún momento su ejecución.
			
			El mecanismo descrito en este apartado se encuentra implementado en la clase\\
			\verb@FileSelfHealingConfiguracionDao@ y podemos ver su código a continuación:

			\begin{Verbatim}[gobble=4]
				private static final long CONFIG_RELOAD_INTERVAL_MS =
					Long.valueOf(Rainbow.property("customize.scenarios.reloadInterval"));

				private static final String SELF_HEALING_CONFIG_FILE_NAME =
					Rainbow.property("customize.scenarios.path");

				private static final File SELF_HEALING_CONFIG_FILE =
					Util.getRelativeToPath(Rainbow.instance().getTargetPath(), SELF_HEALING_CONFIG_FILE_NAME);
				...
				public FileSelfHealingConfigurationDao() {
					super();
					this.listeners = new HashSet<SelfHealingConfigurationChangeListener>();
					this.loadSelfHealingConfigurationFromFile();

					TimerTask task = new FileChangeDetector(SELF_HEALING_CONFIG_FILE) {
						@Override
						protected void onChange(File file) {
							logger.info(SELF_HEALING_CONFIG_FILE_NAME +
								" has just changed, reloading Self Healing Configuration!");
							loadSelfHealingConfigurationFromFile();
							notifyListeners();
						}
					};

					Timer timer = new Timer();
					timer.schedule(task, new Date(), CONFIG_RELOAD_INTERVAL_MS);
				}
				
				public void register(SelfHealingConfigurationChangeListener listener) {
					this.listeners.add(listener);
				}
				
				protected void notifyListeners() {
					for (SelfHealingConfigurationChangeListener listener : this.listeners) {
						listener.selfHealingConfigurationHasChanged();
					}
				}
								
				...
			\end{Verbatim}
