\section{Extensión a Rainbow: Arco Iris}

	\subsection{Introducción}

		Como ya se ha comentado anteriormente, la idea de este trabajo es extender el \emph{framework} Rainbow para poder
		lograr un mecanismo de auto reparación más flexible y con mayor capacidad expresiva, y con el objetivo de proveer visibilidad
		a los \emph{stakeholders} de la aplicación sobre dicho proceso, permitiéndoles involucrarse en la definición de
		escenarios de atributos de calidad del sistema, de sus prioridades relativas y de las estrategias a considerar en la		auto reparación del sistema cuando un escenario deja de cumplirse.
		A fin de lograr lo antedicho, se propone extender el \emph{framework} Rainbow, con la anuencia y apoyo de los
		integrantes del proyecto ABLE, quienes poseen su propiedad intelectual.

	\subsection{Rainbow \emph{out of the box}}

		En el diagrama de colaboración de objetos que se muestra en la Figura \ref{fig:Rainbow_Architecture} se pueden 		observar los principales componentes de la arquitectura de Rainbow.
		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/Rainbow_Architecture.png}
			\caption{Arquitectura de Rainbow}
			\label{fig:Rainbow_Architecture}
		\end{figure}}
		
		\todo{Traducir al castellano los labels en los diagramas del EA}

		\todo{Agregar en ambos graficos: AdaptationManager escoge y lanza Strategy (opcional)}

		\todo{Agregar en ambos graficos: Effector invocado desde el Strategy}

		Observamos que, en Rainbow, una persona con rol de arquitecto (o similar) es el encargado de configurar el 
		\emph{framework} utilizando, básicamente, dos vías:
		\begin{enumerate}
			\item la creación de un modelo de la arquitectura del sistema al cual Rainbow va a adaptar. Dicho modelo se
			especifica utilizando el estilo de componentes y conectores (C\&C) y el lenguaje de descripción de arquitecturas
			ACME (ver sección \ref{sec:acme}). En dicho lenguaje, los componentes y conectores poseen
			propiedades (con valores asociados), restricciones y también se ofrece la posibilidad de especificar invariantes a
			nivel de sistema o sub sistema. Dichos invariantes y restricciones serán evaluados periódicamente por Rainbow para
			verificar que el sistema funcione dentro de los límites determinados como normales.
			\item la generación de un conjunto de archivos de configuración que especifican diversos aspectos relacionados con
			la definición del sistema a auto reparar, como por ejemplo: ubicación física del archivo ACME que describe la
			arquitectura del sistema, archivos de tácticas y estrategias de reparación (escritos en \emph{Stitch}), datos para
			la configuración de la conexión de Rainbow con el sistema en \emph{runtime}, etc.
		\end{enumerate}

		Podemos ver también en el gráfico anterior que los denominados \emph{Probes} son los componentes designados para
		interactuar directamente con el sistema a adaptar (el \emph{Target System}), obteniendo así información relevante a los
		fines de su auto reparación. Dicha información no es interpretada dentro de los \emph{probes}, sino que ellos delegan
		dicha tarea a los denominados \emph{Gauges}. Estos componentes son los encargados de interpretar la información provista por
		los \emph{probes} y traducirla a pares \verb@<Propiedad,Valor>@ donde \verb@Propiedad@ refiere al nombre de una
		propiedad correspondiente a un componente o conector de la arquitectura del sistema a adaptar, mientras que
		\verb@Valor@ es el nuevo valor que poseerá dicha propiedad.

		Normalmente, por cada tipo relevante de \emph{concern} que interese ser monitoreado en tiempo de ejecución existe un
		par \verb@<Gauge,Probe>@ asociado. Un ejemplo de \emph{concern} podría ser: ``tiempo de respuesta experimentado por el
		usuario'', el cual es un \emph{concern} relacionado al atributo de calidad \emph{performance}.

		El \emph{Gauge Coordinator}, tal como su nombre lo sugiere, coordina la información provista por todos los
		\emph{gauges} y se encarga de notificar los cambios en el sistema en ejecución al componente \emph{Rainbow Model}.
	
		\emph{Rainbow Model}, componente clave en la arquitectura del \emph{framework}, tiene como principal responsabilidad
		hacer efectiva la actualización de los valores de la propiedades de los componentes, conectores, sub sistemas o
		sistemas del modelo de arquitectura de la aplicación a adaptar. También es quien tiene el conocimiento necesario para
		detectar violaciones a las restricciones e invariantes presentes en el modelo de arquitectura con el cual el
		\emph{framework} ha sido configurado.

		Por otra parte, existe otro componente llamado \emph{Architecture Evaluator}, el cual consulta periódicamente a
		\emph{Rainbow Model} para tomar conocimiento de violaciones a restricciones definidas en el modelo de la arquitectura.
		En el caso de existir alguna violación, el \emph{Architecture Evaluator} dispara el mecanismo de adaptación invocando
		al \emph{Adaptation Manager}.

		El \emph{Adaptation Manager}, uno de los componentes más importantes de Rainbow, sigue una lógica un tanto compleja
		(explicada en detalle en la sección \ref{sec:strategySelection}) para determinar la estrategia de reparación que deja
		al sistema en el mejor estado posible, para luego ejecutarla.
		
		La \emph{Estrategia} contiene la lógica necesaria para reparar el sistema en ejecución mediante el uso de
		\emph{Tácticas}, que a su vez, utilizan a los denominados \emph{Effectors}, los cuales son componentes que realizan
		acciones simples y concretas sobre el sistema en ejecución, como por ejemplo ``aumentar el nivel de logging de un
		componente determinado''.

	\subsection{Rainbow + Escenarios = ``Arco Iris''}

			En el presente apartado se presenta someramente las características principales de la arquitectura de Rainbow
			luego de incorporar las extensiones planteadas en el presente trabajo, a las cuales denominamos ``Arco Iris''.

		\subsubsection{Arquitectura de Arco Iris}

			En la figura \ref{fig:Rainbow_Architecture_With_Scenarios} podemos observar como luce la arquitectura
			del \emph{framework} con la incorporación de las extensiones realizadas.

			\afterpage{\clearpage
			\begin{figure}[H]
				\centering
				\includegraphics[width=1.00\textwidth]{images/Rainbow_Architecture_With_Scenarios.png}
				\caption{Arquitectura de Arco Iris}
				\label{fig:Rainbow_Architecture_With_Scenarios}
			\end{figure}}

			El arquitecto sigue realizando las mismas tareas que realizaba en Rainbow (i.e. ``alimentarlo'' con el
			modelo de la arquitectura del sistema a adaptar y con archivos de configuración requeridos por Rainbow) pero ahora se
			le suma una tarea más: el configurar los escenarios de atributos de calidad; tarea que realiza en conjunto con una o
			más personas que asumen distintos roles que normalmente se engloban en la palabra \emph{stakeholders} (e.g. analistas
			funcionales, usuarios del sistema, líderes, clientes, el \emph{sponsor} del proyecto, etc.)

			En la versión original de Rainbow (i.e. sin extensiones) el \emph{framework} deja al usuario (e.g. el arquitecto) la
			responsabilidad de codificar los \emph{probes} y \emph{gauges} que recolectarán información del sistema a adaptar y
			traducirán esa información a cambios en los valores de las propiedades del sistema. Esto sigue siendo igual en
			Rainbow con las extensiones provistas por Arco Iris, es decir, el usuario sigue siendo el encargado de crear los
			componentes que en tiempo de ejecución encuestan al sistema periódicamente para obtener información relevante y
			mantener actualizado el modelo de la arquitectura subyacente.

			En el diagrama se puede observar que, en Arco Iris, tanto los \emph{probes} como los \emph{gauges} ahora poseen
			conocimiento del concepto de \textbf{estímulo} (tal cual es descrito en los escenarios de atributos de calidad de ATAM).
			A diferencia de los utilizados en Rainbow, los \emph{probes} implementados para trabajar con Arco Iris deberán
			indicar el estímulo al cual están asociados, mientras que los \emph{gauges} deberán interpretar esta información y
			notificar al \emph{Arco Iris Model} de la actualización sobre el modelo indicando el estímulo desencadenante. Las			novedades sobre los cambios ocurridos en el sistema en \emph{runtime} serán informados con el siguiente formato:			\verb@<Propiedad,Valor,Estímulo>@
			En función de las modificaciones al modelo original de Rainbow descritas en el párrafo anterior, el componente
			\emph{Gauge Coordinator} ha sido extendido (i.e. \emph{Arco Iris Gauge Coordinator}) conservando el comportamiento			original provisto por Rainbow. De esta manera, Arco Iris puede coordinar información proveniente de \emph{gauges} de			Rainbow y/o de Arco Iris con su correspondiente conocimiento sobre el estímulo originario de la modificación.
			De la misma manera, el componente \emph{Arco Iris Model} es una extensión de \emph{Rainbow Model}
			que permite manipular información de estímulos proveniente del \emph{Arco Iris Gauge Coordinator} sin perder el
			soporte original provisto por \emph{Rainbow Model}.

			Cuando \emph{Arco Iris Model} es notificado de que un estímulo ha sido invocado en el sistema solicita
			al \emph{Self Healing Configuration Manager} el subconjunto de escenarios habilitados que poseen dicho estímulo y que
			a su vez han dejado de cumplirse\footnote{De ahora en más, diremos equivalentemente que el escenario en esta
			situación se encuentra ``roto''.}. Luego de obtener este subconjunto de escenarios, invocará al \emph{Arco Iris
			Adaptation Manager}, extensión del componente original \emph{Adaptation Manager}, indicando el conjunto de escenarios
			detectados como ``rotos'' a los cuales debe intentar reparar considerando diversas variables como por ejemplo sus
			prioridades relativas.
			
			Además de detectar los escenarios rotos para un determinado estímulo, el componente \emph{Self Healing Configuration
			Manager} carga la denominada \emph{Self Healing Configuration}, una abstracción de la mayor parte de la información
			referente a auto reparación utilizada por Arco Iris. Esto incluye, por supuesto, los escenarios creados por los			\emph{stakeholders} y arquitectos.			
			\todo{Agregar Self Healing Configuration Manager en el grafico como un colaborador de Arco Iris Model}
			
			\todo{Sacar los gauges, probes y el ArchEvaluator usuales de Rainbow Y ACTUALIZAR EL DOCUMENTO EN TODOS LADOS PARA			QUE NO QUEDE HUELLA DEL ARCH EVALUATOR!}
			
			\todo{Revisar secciones 1 y 2 (y lo que va de la 3) para asegurarnos que no decimos que hay compatibilidad hacia			atrás!!!}
	\subsection{ATAM para Flexibilizar la Auto Reparación}

		Actualmente Rainbow posee conocimiento sobre la arquitectura del sistema a adaptar mediante un modelo de su arquitectura
		expresado en el lenguaje de descripción de arquitecturas Acme. Uno de los objetivos de Arco Iris es extender el
		conocimiento que el \emph{framework} tiene sobre el sistema en general. Este nuevo conocimiento será utilizado por Arco
		Iris en tiempo de ejecución para refinar y optimizar la auto reparación.

		Esencialmente, se incluye información sobre los atributos de calidad del sistema que son relevantes para los
		\emph{stakeholders} del sistema en tiempo de ejecución. Se permite, por ejemplo, poder describir la importancia relativa
		de la \emph{performance}, la usabilidad, la disponibilidad, etc.; definiendo así una serie de \emph{tradeoffs} entre
		distintos atributos de calidad requeridos por el sistema. El enfoque propuesto para lograr esto consiste en especificar
		\textbf{Escenarios de Atributos de Calidad}, tal cual fueron descritos en la sección \ref{sec:QAS}, extendiendo el
		concepto con información orientada a flexibilizar la auto reparación. Esta extensión es explicada en detalle en la
		sección \ref{sec:modeloExtensionATAM}

		En la Figura \ref{fig:ATAM_Model} se puede ver el modelo diseñado para representar los escenarios de ATAM en Arco
		Iris. Este modelo cumple una tarea fundamental ya que toda esta información será manipulada constantemente por Arco
		Iris para llevar a cabo la auto reparación en base a las expectativas plasmadas por los \emph{stakeholders} al crear
		los escenarios.

		\todo{Turco: Quitar weights de Environment y isAny() de Stimulus en la figura}
		
		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/ATAM_Model.png}
			\caption{Modelo de ATAM}
			\label{fig:ATAM_Model}
		\end{figure}}		
		
		Supongamos que luego de una reunión QAW, el arquitecto de un sistema junto con los \emph{stakeholders} acuerdan el
		siguiente escenario de atributo de calidad:

		\begin{quote}
			Un proceso del sistema recibe un mensaje externo no anticipado durante un modo de operación normal. El
			proceso informa al operador y continúa su operación sin caídas.
		\end{quote}

		Veamos cómo se desgloza la información de este escenario según la descomposición antes mencionada:

		\begin{itemize}
			\item Fuente: Sistema externo
			\item Estímulo: Mensaje no anticipado
			\item Entorno: Operación normal
			\item Artefacto: Proceso interno
			\item Respuesta: Informar al operador y seguir operando
			\item Medición de la respuesta: sin caídas (downtime)
		\end{itemize}

		\indent De todos estos atributos, el \textbf{Estímulo}, el \textbf{Artefacto}, el \textbf{Entorno} y la
		\textbf{Cuantificación de la Respuesta} son particularmente relevantes a los fines de establecer información útil para
		el mecanismo de auto reparación. A lo largo de las próximas subsecciones mostraremos cómo Arco Iris hace uso de esta
		información para modificar, optimizar y refinar la auto reparación realizada por Rainbow.


		\subsubsection{El Estímulo en la Auto Reparación}

			El \textbf{estímulo} de un escenario normalmente se asocia a un evento desencadenado en el sistema por la acción del
			alguno de sus usuarios. Dicho evento es el punto de entrada del escenario, el disparador (interno o externo) que
			inicia la interacción con el sistema, y más particularmente, con el artefacto del escenario en cuestión. Por ejemplo,
			supongamos que en un sistema de administración de cuentas bancarias un cliente intenta hacer una transferencia, en
			este caso la fuente del estímulo sería el cliente y el estímulo en sí mismo sería realizar transferencia.

			Saber cuál es el estímulo de cada escenario permite optimizar la auto reparación, ya que habiendo ocurrido
			determinado estímulo, Arco Iris podrá detectar cuales son los potenciales escenarios que pueden verse afectados y trabajará
			verificando dicho subconjunto, minimizando así el tiempo de la auto reparación.

			Cabe destacar que también se ofrece la posibilidad de no especificar el estímulo al configurar un escenario, es decir,
			se permite la opción de que el escenario aplique siempre, independientemente del estímulo que haya impactado al sistema.
			Esto puede ser útil para casos genéricos, por ejemplo, si se requiere que el tiempo de respuesta experimentado por el
			usuario nunca sobrepase determinado umbral sin importar la funcionalidad del sistema que el usuario esté utilizando. De
			no configurar ningún estímulo en ningún escenario, Arco Iris verificará que se satisfagan todos los escenarios en cada
			iteración cada vez que un estímulo perteneciente a cualquier escenario impacte sobre el sistema.
			\todo{JONY Y TURCO: no seria correcto decir ``cada estimulo que recibe el sistema'', ya que la auto reparacion se activa
			cuando llega un estimulo conocido (i.e: perteneciente a otro escenario), pensar si tiene sentido el anyStimulus, no			confunde?}			Entonces, a diferencia de Rainbow, Arco Iris permite refinar el conjunto de escenarios que pudieron verse afectados por
			efecto del estímulo que ocasionó el problema, reduciendo así la cantidad de escenarios a verificar y sobre todo la
			cantidad de estrategias a evaluar para intentar resolverlo, mientras que en Rainbow (en Arco Iris se mantiene esta
			posibilidad), la única manera de limitar el uso de las estrategias es agregar restricciones en la misma estrategia,
			siendo esto de nivel técnico y quedando fuera del alcance de la mayor parte de los \emph{stakeholders} del sistema. Por
			ejemplo, para que una estrategia que soluciona problemas de \emph{performance} no sea tenida en cuenta al reparar un
			escenario relacionado a un atributo de calidad distinto, como por ejemplo el costo, debe agregarse una precondición como
			la siguiente en la estrategia:
			\begin{Verbatim}[gobble=4]
				strategy SimpleReduceResponseTime
				  [ responseTimeConstraintViolation ] {
				  ...
				}
			\end{Verbatim}

			Donde \emph{responseTimeConstraintViolation} es un predicado que permite determinar si existe algún cliente cuyo tiempo
			de respuesta haya sobrepasado el máximo tiempo de respuesta permitido:

			\begin{Verbatim}[gobble=4]
				define boolean responseTimeConstraintViolation =
					exists c : T.ClientT in M.components | c.experRespTime > M.MAX_RESPTIME;
			\end{Verbatim}

			Es importante remarcar que, en caso de que el problema que se está intentando reparar no tenga relación con la
			\emph{performance}, Rainbow deberá de todos modos chequear el tiempo de respuesta de todos los clientes, mientras que
			en Arco Iris existe la posibilidad de evitarlo al configurar correctamente los estímulos de cada escenario.

			Dado a que Rainbow permite trabajar en modo simulación, fue necesario implementar dos soluciones para poder utilizar el
			concepto de estímulo en ambos modos.

			Al trabajar en el modo de simulación, dado que no participan ni los \emph{probes} ni los \emph{gauges}, fue necesario
			implementar un mecanismo ad hoc, que consistió en ``barrer'' todos los escenarios al iniciar Arco Iris, recogiendo en un
			mapa la información de qué estímulos eran los posibles responsables de las modificaciones causadas sobre cada una de las
			propiedades de los artefactos configurados en los escenarios. A continuación se muestra en pseudocódigo el concepto de
			dicha implementación:
			\begin{Verbatim}[gobble=4]
				por cada escenario habilitado
				  por cada constraint del escenario
				    por cada propiedad involucrada en el constraint
				      escenariosPorEstimulo.agregar(escenario.estimulo, escenario)
				      estimulosPorPropiedades.agregar(propiedad, escenario.estimulo)
			\end{Verbatim}

			El modo simulación funciona notificando los cambios en las propiedades de interés, las cuales son determinadas a la hora
			de implementar la simulación. Entonces, al contar con los estímulos relacionados con cada propiedad y los escenarios por
			cada estímulo, es posible acotar la cantidad de escenarios a verificar en cada ejecución de la auto reparación.
			En modo real, o sea, sin simulación, para notificar el estímulo desencadente fue necesario extender los \emph{probes},
			que, como ya mencionamos anteriormente, son los componentes encargados de \emph{testear} una determinada funcionalidad
			del sistema, siendo el responsable también de medir la respuesta y de reportar dicha información a un bus, del cual
			luego será consumida por los \emph{gauges}, quienes interpretan los datos transformándolos en cambios en el modelo de
			la arquitectura.			
			El extender los \emph{probes} implicó la necesidad de extender la funcionalidad de los \emph{gauges} para poder
			intrepretar la información de estímulo agregada en cada uno de los \emph{probes}. En ambos casos, y gracias al
			mecanismo empleado por Rainbow, no fue necesario modificar las interfaces de los \emph{probes} ni de los
			\emph{gauges}, ya que éstos se comunican mediante cadenas de texto, justamente para ofrecer una amplia libertad a la
			hora de implementarlos ya que pueden existir diversas maneras de probar y tomar métricas de las distintas
			funcionalidades de los sistemas. Luego, una vez obtenido el estímulo correspondiente, no resta más que recurrir al
			mapa de escenarios por estímulos (utilizado también en el modo simulación) para acotar la cantidad de escenarios a			comprobar.
			Para graficar la diferencia en la implementación que genera el agregar el estímulo en la auto reparación, se
			ejemplificará una extensión a un \emph{probe} utilizado por Znn. El \emph{probe} escogido para extender y así poder
			ser utilizado en Arco Iris consiste simplemente en invocar un servicio, esperar su respuesta y medir el tiempo
			transcurrido entre la invocación y la respuesta; ésta será la información que el \emph{probe} reportará para luego
			ser interpretada por su \emph{gauge} correlativo, el cual finalmente será responsable de impactar la actualización
			sobre el modelo de la arquitectura.
			
			A continuación se puede observar la configuración original utilizada en Znn para instanciar un \emph{probe} del tipo
			ClientProxyProbe, esta configuración se puede encontrar en el archivo \verb@probes.yml@, donde se declaran todos los
			\emph{probes} que serán instancias al iniciar Rainbow:

			\begin{Verbatim}[gobble=4]
				probes: 
				ClientProxyProbe0: 
					alias: clientproxy 
					location: "localhost"
					type: java 
					javaInfo:
						class: org.sa.rainbow.translator.znews.probes.ClientProxyProbe
						period: 2000
						args.length: 1
						args.0: "http://delegate.oracle/"
			\end{Verbatim}

			Un ejemplo de la información que reporta un \verb@ClientProxyProbe@ con la configuración presentada
			anteriormente podría ser:
			
			\begin{Verbatim}[gobble=4]
				[lun abr 18 00:42:43 2011]<clientproxy> localhost: 1532 ms
			\end{Verbatim}
			
			Tanto la configuración como la implementación de \verb@ClientProxy@ son muy similares a las de su contraparte de Arco
			Iris, \verb@ClientProxyWithStimulus@; en la sección \ref{sec:probesCode} se pueden observar ambas implementaciones,
			mientras que la configuración de una instancia de \verb@ClientProxyWithStimulus@ se puede observar a continuación:

			\begin{Verbatim}[gobble=4]
				ClientProxyProbeWithStimulus0:
					alias: clientproxyWithStimulus
					location: "localhost" 
					type: java 
					javaInfo:
						class: ar.uba.dc.arcoiris.znn.probes.ClientProxyProbeWithStimulus
						period: 2000
						args.length: 2
						args.0: "http://delegate.oracle/"
						args.1: "delegateStimulus"
			\end{Verbatim}

			Por último, se muestra la información reportada por una instancia de\\
			\verb@ClientProxyWithStimulus@ con la configuración que se acaba de presentar:
			
			\begin{Verbatim}[gobble=3]
			[lun abr 18 00:42:43 2011]<clientproxyWithStimulus> localhost<stimulus:delegateStimulus>: 1532 ms
			\end{Verbatim}

			\todo{TURCO Y JONY: (NO ACLARES QUE OSCURECE) Aclarar bien como es el tema de los probes en Arco Iris: que deben
			``interceptar'' los estímulos y presentamos dos \emph{posibles} formas: interceptores (si se puede tocar el sistema) u
			otro mecanismo como analizar logs, etc\ldots}
		\subsubsection{El Artefacto en la Auto Reparación}

			El \textbf{artefacto} se refiere al componente, sub sistema o parte del sistema afectada por el escenario. Dado que
			Rainbow trabaja con el modelo de la arquitectura del sistema descripto en el lenguaje Acme, contaremos con la
			especificación de las propiedades de los componentes y los conectores del sistema, entonces en el escenario de Arco Iris
			podremos contar con una vinculación directa con los componentes afectados. Al seleccionar un artefacto, el usuario de
			Arco Iris no estará más que eligiendo un componente o conector de la arquitectura del sistema, esto será utilizado
			para acotar las propiedades sobre las cuales podrá predicar la \textbf{cuantificación de la respuesta}
			(ver \ref{sec:responseMeasure}).

			La arquitectura presentada en Znn servirá para ejemplificar el concepto de artefacto, cabe recordar que se trata de
			una arquitectura cliente-servidor, de la cual en este caso importa la especificación del componente cliente
			definido como \emph{ClientT}, a saber:

			\begin{Verbatim}[gobble=4]
				Component Type ClientT extends ArchElementT with {

				  Property deploymentLocation : string <<  default : string = "localhost"; >> ;

				  Property experRespTime : float <<  default : float = 100.0; >> ;

				  Property requestRate : float <<  default : float = 0.0; >> ;
				}
			\end{Verbatim}

			Suponiendo que se define el siguiente escenario:

			\label{escenarioPerformance}
			\begin{quote}
				Znn news debe servir el contenido de las noticias a los clientes en un tiempo de respuesta menor a 3 segundos en un
				entorno de operación normal.
			\end{quote}

			Claramente en este ejemplo \emph{ClientT} es el artefacto sobre el cual ha de predicar la verificación de validez de
			este escenario, más adelante, en la sección \ref{sec:responseMeasure} se podrá observar cómo se configura dicha
			restricción.

			La sección \ref{sec:arcoIrisUI} explica en detalle cómo se podrá emplear esta información para mejorar la
			experiencia de los \emph{stakeholders} a la hora de especificar escenarios mediante la herramienta visual presentada
			junto a Arco Iris: \textbf{Arco Iris UI}

		\subsubsection{El Entorno en la Auto Reparación}
		\label{sec:environment}
		
			Dentro de la definición de escenario, el \textbf{entorno} se refiere al estado en el que el sistema se encuentra
			cuando recibe el estímulo que desencadena el escenario; por ejemplo, al recibir una solicitud de creación de una
			cuenta bancaria el sistema puede encontrarse en ``operatoria normal'' o en ``alta carga''. El entorno condiciona la
			validez del escenario en cuestión a que el sistema se encuentre en un determinado estado. Una respuesta esperada
			aceptable o fácil de cumplir bajo un entorno puede ser inaceptable o muy costosa de cumplir en otro entorno. 
			
			En el escenario planteado anteriormente en la sección \ref{escenarioPerformance}, si el sistema se encuentra en un
			entorno de ``alta carga'' el escenario automáticamente se cumple, ya que para considerar dicho escenario el sistema
			debería encontrarse en un entorno de ``operación normal''. 
			
			Por otro lado, el entorno del escenario permite a Arco Iris optimizar la búsqueda de escenarios que no se satisfagan ya
			que se ignorarán los escenarios cuyo entorno posea condiciones que no se cumplan en el estado del sistema en el instante
			en que se recibe el estímulo. Más adelante se profundizará sobre dichas condiciones.

			\todo{JONY: decidí dejar un env por escenario: se corresponde a la definición de ATAM, solo nos quedaría como trabajo			a futuro validar que las condiciones de los environments sean excluyentes. Necesitamos una constraint del tipo			Between}
			Arco Iris también provee la posibilidad de especificar, mediante la selección de un entorno preexistente denominado
			``ANY'', que un determinado escenario aplica bajo cualquier entorno, esto sería equivalente a que el entorno del
			escenario no posea ninguna condición, es decir, que el escenario aplica siempre, trivialmente, sin importar las
			condiciones actuales del sistema en ejecución. Esto puede resultar útil ya que simplifica la configuración del
			escenario, pero es importante tener en cuenta que reducirá el rendimiento de la auto reparación ya    que configurar un
			entorno específico por escenario otorga mayor precisión al permitir establecer las prioridades relativas de los
			\emph{concerns} según el estado en el que el sistema se encuentre.			El entorno ``ANY'' será asignado automáticamente al escenario si el usuario no escoge ningún entorno o, en su defecto,
			si decide explícitamente que el escenario aplique \textbf{en cualquier entorno de ejecución}. Para este entorno todos
			los \emph{concerns} poseerán el mismo peso,  evitando así ``inclinar la balanza'' hacia algún \emph{concern} en
			particular.
			\todo{JONY: no estoy de acuerdo en que los pesos sean equidistribuidos, debería poder configurarlo el usuario. Por
			ejemplo: un sistema financiero siempre va a dar mas prioridad a la performance, mientras que un e-commerce dará, por
			defecto, mas importancia a la seguridad. Al menos dejémoslo como trabajo a futuro.}

			Para ejemplificar la importancia de configurar un entorno correctamente y no abusar del entorno ``ANY'', considerar,
			por ejemplo, un sistema el cual se encuentra bajo excesiva carga, y los \emph{stakeholders} consideran que bajo tales
			circunstancias lo más prioritario es optimizar la \emph{performance} de un servicio en particular, en tal caso, de no
			especificar el entorno no podremos darle mayor peso a la \emph{performance} por sobre otros \emph{concerns}, quedando
			únicamente la opción de aumentar la prioridad del escenario tergiverzando así dicha información, ya que en realidad lo
			óptimo sería asignarle más peso al \emph{concern performance} en el entorno de ``Alta Carga''. En definitiva, al
			establecer que el escenario aplica bajo cualquier entorno, Arco Iris interpretará que el entorno carece de importancia,
			dejando de lado los pesos de los \emph{concerns} y distribuyendo equitativamente su importancia relativa, lo cual es
			equivalente a que no exista el concepto de \emph{concern}.
			La estructura del entorno consiste en:

			\begin{itemize}
				\item Un conjunto de condiciones, y
				\item Un mapa \verb@<$Concern, Peso$>@
			\end{itemize}
			Las condiciones fueron implementadas en base a un concepto de restricción presente en Rainbow, que permite definir
			precondiciones de aplicabilidad de las estrategias. En Arco Iris utilizaremos el mismo concepto para dos fines, ninguno
			de los cuales se corresponde exactamente con la concepción original de Rainbiow. Por una lado, lo utilizaremos para
			conocer el entorno en que se encuentra el sistema, y por otro, será utilizado en la cuantificación de la respuesta (ver
			\ref{sec:responseMeasure}) para decidir si el escenario se satisface o no. En dicha sección se explica la diferencia
			vital del concepto de restricción utilizado en Rainbow con el de Arco Iris. \todo{verificar si se explica esta			diferencia}
			El concepto de condición (o restricción) presentado en Arco Iris permite agregar nuevos tipos de restricciones
			simplemente implementando la interfaz \verb@Constraint@ \footnote{Dicha implementación deberá ser agregada al
			enumerado ConstraintType en Arco Iris UI para que la UI reconozca el nuevo tipo}. 
			
			En cuanto al mapa presente en la estructura del entorno, este deberá contener todos los \emph{concerns} definidos para
			el sistema, y obviamente la suma de los pesos debe ser igual a uno, ya que la utilidad del mapa es determinar la
			preponderencia relativa entre todos los \emph{concerns} de interés para el sistema. Se detallará cómo se utilizarán
			estos pesos para calcular el valor de un escenario al escoger una estrategia en la sección
			\ref{sec:arcoIrisStrategyScoring}.
			
			Todo lo visto hasta ahora carecería de sentido si no fuese posible determinar en qué entorno se encuentra el sistema
			en un instante dado. Ahora bien, para esto no sería suficiente chequear las condiciones definidas para el entorno
			tomando los datos actuales del sistema, ya que esta información es muy sensible al ``ruido'' provocado por posibles
			\emph{outliers}, pues para que el sistema se encuentre en un determinado estado es lógico esperar que dicho estado se
			mantenga por un tiempo mínimo. Entonces, para definir un valor más cercano a la realidad para las propiedades del			sistema tomamos los valores nuevos con un determinado peso, configurable, que nos permite ir adecuando los valores			del sistema de manera paulatina evitando el impacto excesivo de los nevos valores que puedan darse por alguna ocasión			excepcional, como por ejemplo algún cliente que experimenta un tiempo de respuesta elevado por algún problema es su			conexión o en su estación de trabajo. Para mitigar estos casos utilizaremos el mismo mecanismo utilizado por Rainbow			explicado en detalle en la sección \ref{sec:exponentialAverage}.
			Un valor recomendable para el factor de suavizado (\emph{alpha}) utilizado tanto en las pruebas de Rainbow como en las
			de Arco Iris es 0.3. Si se configura un valor demasiado bajo, Arco Iris tardará en adaptarse a los cambios en el entorno
			del sistema. Ésto podría ser útil, por ejemplo, en sistemas con bajo grado de dinamismo o en los cuales la adaptación
			pueda resultar muy costosa. Por el contrario, al configurar un valor elevado para \emph{alpha}, es probable que el
			sistema se vea afectado por unos pocos valores que se encuentran por fuera del rango considerado como normal, aunque de
			no ser costoso lanzar una adaptación o volverla atrás, podría lograrse un rendimiento aceptable del sistema de manera
			prácticamente inmediata.
		\subsubsection{La Cuantificación de la Respuesta en la Auto Reparación}
			\label{sec:responseMeasure}

			La \textbf{cuantificación de la respuesta} es quizás la propiedad más importante de un escenario: de ella surgen las
			restricciones que deben ser evaluadas para que, en caso de no cumplirse, se lance la auto reparación. De hecho, para
			que un escenario se considere bien formado debe quedar claro cual es la métrica o manifestación observable de su
			respuesta que se debe satisfacer. Latencia y \emph{throughput} son ejemplos de las manifestaciones sobre las cuales
			puede predicar la cuantificación de la respuesta. En pocas palabras, la cuantificación será la métrica según la cual
			se decida la aceptación de una respuesta del sistema ante un determinado estímulo.

			Para graficar la importancia de contar con una cuantificación de la respuesta precisa, supongamos que contamos con la
			siguiente definición:

			\begin{quote}
				``Modificar el sistema para incorporar un nuevo generador de eventos discretos''
			\end{quote}

			Esta premisa no es suficiente para medir el éxito de la incorporación de la nueva funcionalidad solicitada, ya que
			con suficiente tiempo y recursos, cualquier modificación es posible. Este escenario requiere una métrica, como por
			ejemplo: ``Utilizando 160 horas hombre''. Esto fuerza al arquitecto a asegurar que el sistema sea modificable
			basándose en un criterio bien definido y con una métrica aplicable.

			Con respecto a la implementación, cabe mencionar que Arco Iris reutiliza las restricciones genéricas brindadas
			por Rainbow, sitúandolas en el contexto de un escenario de atributo de calidad, proveyendo así mayor visibilidad a
			los \emph{stakeholders} sobre estas restricciones, anteriormente sólo conocidas por los arquitectos y/o técnicos
			responsables de configurar Rainbow, ya que en Rainbow eran implementadas en el modelo de la arquitectura descrito en
			Acme.

			El siguiente ejemplo ha sido extraído de la arquitectura de Znn (también expresada utilizando Acme), allí se puede
			observar cómo se implementan las restricciones al utilizar Rainbow, las que pasan a formar parte de la cuantificación
			de la respuesta del escenario al utilizar Arco Iris:
			
			\begin{Verbatim}[gobble=4] 
				Component Type ClientT {
					Property experRespTime : float <<  default : float = 100.0; >> ;
					rule primaryConstraint = invariant self.experRespTime <= 1000;
				}
			\end{Verbatim}

			Es importante recordar que en Rainbow, una vez que se detectó que la auto reparación debe ser lanzada debido a una
			restricción que dejó de cumplirse, se volverán a ejecutar todas las restricciones definidas en las precondiciones de
			las estrategias para verificar si aplican o no dependiendo del estado actual del sistema. A continuación se muestra
			un ejemplo extraído de Znn de una estrategia y su precondición:

			\begin{Verbatim}[gobble=4]
                define boolean cViolation =
                    exists c : T.ClientT in M.components | c.experRespTime > 1000;

                strategy BruteReduceResponseTime
                [ cViolation ] {
  					...
  					do some tactic
  					...
                }
			\end{Verbatim}

			Como se puede observar, tanto la restricción del modelo que desencadenó la auto reparación como la precondición de la
			estrategia son equivalentes, por lo que se duplica la lógica aumentando el costo de procesamiento, haciendo que la
			reparación sea más costosa y menos escalable.

			En Arco Iris no será necesario contar con las precondiciones de las estrategias, ya que el conocimiento de cuáles
			estrategias son capaces de reparar una determinada condición se encuentra plasmado en cada escenario. En definitiva, al
			utilizar Arco Iris el usuario no tendrá más que configurar la cuantificación de la respuesta de cada escenario, tarea
			que se ve sumamente facilitada al utilizar Arco Iris UI (ver sección \ref{sec:arcoIrisUI} en la			página \pageref{sec:arcoIrisUI}).
			Otra diferencia vital con respecto al uso de las mencionadas restricciones entre la visión de Rainbow y de Arco Iris
			consiste en el momento en que se aplican. Rainbow posee un componente llamado \emph{``Architecture Evaluator''}, cuya
			responsabilidad consiste en verificar la arquitectura del modelo de a intervalos y de manera asincrónica, siempre y
			cuando este haya sido modificado y la auto reparación no se encuentre ya en ejecución, esto implica verificar
			absolutamente todas las restricciones del modelo. Arco Iris, en cambio, al descubrir un cambio en el modelo,
			verifica que los escenarios se satisfagan, pero no todos los escenarios, sino solamente los que coincidan en su
			estímulo con el estímulo que desencadenó el cambio en el modelo, optimizando así de manera drástica la cantidad
			de restricciones a verificar, lo que hace mucho más escalable la auto reparación.

			Dado al cambio en el manejo de restricciones, Arco Iris implementa el concepto de \emph{Constraint} como una interfaz,
			dando así la posibilidad de extender el \emph{framework} con el tipo de \emph{Constraint} que el usuario considere
			necesario. La interfaz presentada es la siguiente:
			\begin{Verbatim}[gobble=4]
                public interface Constraint {

                    boolean holds(Number value);

                    String getFullyQualifiedPropertyName();
                }
			\end{Verbatim}

			Donde el método \emph{holds} será el encargado de determinar si la \emph{Constraint} se cumple o no, recibiendo como
			parámetro el valor actual de la propiedad del modelo de la arquitectura sobre el cual predica la cuantificación de
			la respuesta, por ejemplo; mientras que el método \emph{getFullyQualifiedPropertyName} retornará el nombre completo
			cualificado de la propiedad sobre la que predica, incluyendo el sistema y el componente al que pertenece,
			\emph{ZNewsSys.ClientT.experRespTime} es un ejemplo extraido de Znn.

			Para el presente trabajo se utilizó	una única implementación de la interfaz \emph{Constraint}, consistente en una
			relación binaria de orden (igual, mayor, mayor o igual, menor o menor o igual) entre una propiedad de la arquitectura
			(e.g. \verb@server1.responseTime@) y un valor fijo (puede ser entero o flotante) preestablecido al configurar la
			cuantificación de la respuesta del escenario. Esta restricción será configurada mediante un cuantificador, el cual
			provee actualmente dos opciones: sumatoria y promedio, las que especifican respectivamente si la condición debe
			cumplirse para la suma de todas las instancias en \emph{runtime} de dicha propiedad o si la condición debe darse ``en
			promedio'' para todas las instancias. La implementación mencionada recibe el nombre de
			\emph{NumericBinaryRelationalConstraint} y puede verse su código en el apéndice
			\ref{sec:numericBinaryRelationalConstraintCode}.

	\subsection{Modelo Extendido de ATAM}
	\label{sec:modeloExtensionATAM}

		Hasta aquí se ha detallado el uso que Arco Iris hará del modelo básico de ATAM, pero como se mencionó anteriormente,
		es necesario extender este modelo para agregar información de auto reparación propiamente dicha. 
		
		En la figura \ref{fig:Arco_Iris_ATAM_Model} se puede observar cómo se modela el \textbf{escenario de auto reparación}
		(\verb@SelfHealingScenario@), el cual además de ser un escenario de ATAM tiene todo la información y la lógica
		necesaria para que Arco Iris pueda llevar a cabo su objetivo de flexibilizar la auto reparación. 

		\todo{Turco: Cambiar List por Set en conditions de environment}\\
		\todo{Jony: Por? en el código es List\ldots no queremos evaluarlas en orden?}\\
		\todo{El orden no deberia importar}
		
		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/Arco_Iris_ATAM_Model.png}
			\caption{Modelo de Arco Iris}
			\label{fig:Arco_Iris_ATAM_Model}
		\end{figure}}

		Los escenarios de auto reparación pueden ser deshabilitados, considerando Arco Iris solamente los escenarios
		habilitados al momento de reparar el sistema. 
		
		Otra propiedad utilizada por Arco Iris y que no forma parte de la definición original brindada por ATAM, es la
		prioridad. Cada \verb@SelfHealingScenario@ tiene preestablecida su prioridad (ver sección \ref{sec:priority} para más
		detalle). Un escenario de Arco Iris también tiene el conocimiento necesario para determinar si él mismo se satisface		según las condiciones actuales del sistema, y si se seguirá satisfaciendo luego de una potencial aplicación de una		estrategia.		
		Otra extensión a los escenarios utilizada por Arco Iris para optimizar la auto reparación consiste en que cada
		escenario conozca las estrategias que el arquitecto del sistema y los \emph{stakeholders} consideran son capaces de
		reparar el escenario en caso de que este haya dejado de satisfacerse en el entorno actual de ejecución del sistema. En
		la sección \ref{sec:strategies} puede verse en detalle cómo Arco Iris explota esta información.
		Por último, es importante mencionar que se ha extendido el concepto de \textbf{entorno} utilizado por ATAM, el cual
		pasa a contar, además de con su nombre, con un conjunto de condiciones que serán utilizadas para saber si un determinado
		escenario aplica, dado su entorno, para las condiciones actuales del sistema, y además será capaz de determinar la		importancia de cada \emph{concern} para el caso en el que el sistema en ejecución se encuentre en este entorno. Esta		extensión ya fue explicada en detalle en la sección \ref{sec:environment}.
	\subsection{Configuración de Arco Iris}
	
		\todo{Explicar SelfHealingConfiguration y su archivo de configuracion. No profundizar en los temas, sólo poner
		referencias a las secciones(tal vez haya que agregar mas secciones)}
		
		\todo{Esta subseccion no es mejor dejarla para el final de la seccion? Algo del estilo ``Para configurar todo lo
		visto en esta seccion utilizaremos Arco Iris UI''. De hecho es Arco Iris UI tiene una subseccion llamada
		``Formato de salida: XML''}
		
		\todo{Mencionar que dicha configuración es administrada por SelfHealingConfigurationManager}

		\subsubsection{Actualización Dinámica de Configuración}
		\label{sec:actualizacionDinamicaConfig}

			Una de las principales limitaciones de Rainbow es la imposibilidad de actualizar la configuración del \emph{framework}
			sin tener que reiniciar su ejecución. A fin de superar (al menos parcialmente) tal limitación, proponemos un simple
			mecanismo de detección de cambios en el archivo de configuración de Arco Iris, el cual, al detectar cualquier cambio en
			dicho archivo, \textbf{reemplazará dinámicamente la configuración de Arco Iris cargada en memoria por la nueva
			configuración}; todo esto sin necesidad de reiniciar el \emph{framework}.
			El mecanismo se ejecuta periódicamente cada $X$ milisegundos, siendo $X$ configurable utilizando el archivo de
			configuración estándar de Rainbow \verb@rainbow.properties@. La propiedad a configurar recibe el nombre
			de \verb@customize.scenarios.reloadInterval@, cuyo valor inicial por defecto será $5000$, es decir, el mecanismo de
			actualización se ejecutará cada 5 segundos.

			Se utiliza el patrón \emph{Observer}\footnote{Para más información acerca del patrón Observer, visitar
			\url{http://en.wikipedia.org/wiki/Observer_pattern}} como modo de notificar a todos aquellos objetos interesados en
			llevar a cabo alguna acción como consecuencia de un cambio en la configuración. El componente (\emph{observer}
			siguiendo la nomenclatura utilizada comúnmente en el patrón) más interesado en conocer cuando un cambio en la
			configuración tiene lugar es el denominado \textbf{SelfHealingConfigurationManager}, el cual, en ese caso, descarta
			toda la configuración de los escenarios cargada en memoria, tomando luego la nueva configuración del archivo
			recientemente actualizado. A partir de este momento Arco Iris continuará trabajando con la nueva configuración de
			escenarios sin detener en ningún momento su ejecución.
			
			El mecanismo descrito en este apartado se encuentra implementado en la clase\\
			\mbox{\textbf{FileSelfHealingConfiguracionDao}} y podemos ver su código a continuación:

			\begin{Verbatim}[gobble=4]
				private static final long CONFIG_RELOAD_INTERVAL_MS =
					Long.valueOf(Rainbow.property("customize.scenarios.reloadInterval"));

				private static final String SELF_HEALING_CONFIG_FILE_NAME =
					Rainbow.property("customize.scenarios.path");

				private static final File SELF_HEALING_CONFIG_FILE =
					Util.getRelativeToPath(Rainbow.instance().getTargetPath(), SELF_HEALING_CONFIG_FILE_NAME);
				(...)
				public FileSelfHealingConfigurationDao() {
					super();
					this.listeners = new HashSet<SelfHealingConfigurationChangeListener>();
					this.loadSelfHealingConfigurationFromFile();

					TimerTask task = new FileChangeDetector(SELF_HEALING_CONFIG_FILE) {
						@Override
						protected void onChange(File file) {
							logger.info(SELF_HEALING_CONFIG_FILE_NAME +
								" has just changed, reloading Self Healing Configuration!");
							loadSelfHealingConfigurationFromFile();
							notifyListeners();
						}
					};

					Timer timer = new Timer();
					timer.schedule(task, new Date(), CONFIG_RELOAD_INTERVAL_MS);
				}
				
				public void register(SelfHealingConfigurationChangeListener listener) {
					this.listeners.add(listener);
				}
				
				protected void notifyListeners() {
					for (SelfHealingConfigurationChangeListener listener : this.listeners) {
						listener.selfHealingConfigurationHasChanged();
					}
				}
								
				(...)
			\end{Verbatim}

	\subsection{Prioridades entre Escenarios}
	\label{sec:priority}
	
		\todo{Continuar revisando desde aca}

		Rainbow también maneja el concepto de escenario, aunque no es equivalente al manejado por Arco Iris, el cual toma el
		concepto de Escenario de QAW de la definición de ATAM. Desde la perspectiva de Rainbow, el escenario es algo
		configurable pero estático, es decir, no ofrece la posibilidad de adaptarse a los cambios del entorno, por lo que el
		arquitecto deberá configurar el escenario\todo{Turco: el siguiente footnote no es redundante? ya se aclaró esto dos
		oraciones más atrás\ldots si lo es, please borralo nomas} \footnote{Recordar que aquí``escenario'' no se refiere a los
		Escenarios de QAW utilizados por Arco Iris, tan sólo se reutiliza con la finalidad de explicar el funcionamiento de
		Rainbow.} previo a iniciar Rainbow, intentando vislumbrar cuales serán las condiciones en las que la aplicación deberá
		responder, para lo cual configurará la importancia de cada uno de los \emph{concerns} del sistema. A continuación se
		muestra cómo se realiza dicha configuración en Rainbow\label{rainbowScenario}:

		\begin{Verbatim}[gobble=4]
				weights:
					scenario 1:
						uR: 0.35
						uF: 0.4
						uC: 0.25
					scenario 2:
						uR: 0.5
						uF: 0.3
						uC: 0.2
					scenario 2b:
						uR: 0.5
						uF: 0.2
						uC: 0.3
		\end{Verbatim}

		Cada una de las líneas representa el valor que se le asigna a cada \emph{concern}, en donde uR representa al Tiempo de
		Respuesta, uF a la Fidelidad de la información y uC al Costo. Notar que la sumatoria de los pesos de los distintos
		\emph{concern} debe ser igual a 1 dentro de cada escenario, al igual que sucede en el \emph{Entorno} al configurar Arco Iris.

		Esto es lo que veremos, entre otras cosas, en el archivo de configuración \emph{utilities.yml} utilizado por Rainbow.
		Aquí, como vemos, existe más de una configuracion del escenario, luego se deberá seleccionar una de estas opciones en
		el archivo de configuración \verb@rainbow.properties@. Estos valores serán luego utilizados por Rainbow a la hora de
		seleccionar una estrategia, veremos en detalle su utilización en la sección \ref{sec:strategySelection}.

		Presentado ya el concepto de escenario utilizado por Rainbow, pasaremos estas ideas a su contrapartida en Arco Iris.
		Como hemos visto anteriormente, en Arco Iris existen los conceptos de \emph{Entorno} y \emph{Escenario}, los cuales
		respetan al pie de la letra los conceptos introducidos por ATAM (ver sección \ref{sec:atam}). El concepto de escenario
		utilizado por Rainbow se asemeja mucho más al concepto de \emph{Entorno} de ATAM que al de \emph{Escenario}. La
		diferencia fundamental radica en que en Arco Iris no se requiere que el usuario configure en qué entorno se encuentra
		el sistema, sino que el usuario debe detallar cuales son las condiciones que definen al entorno, y, en caso de
		cumplirse dichas condiciones, cuales serán los pesos que tomarán cada uno de los \emph{concerns} del sistema.

		Dicho esto podemos introducirnos directamente en la relación de prioriades entre escenarios, sin confundir los
		conceptos manejados en ambos \emph{frameworks}.

		En resumen, Rainbow permite priorizar básicamente por \emph{concerns}, y de manera estática, mientras que Arco Iris
		permite priorizar escenarios asignandoles prioridades relativas, de modo tal que al momento de escoger una estrategia
		de autoreparación la estrategia seleccionada no comprometa a alguna otra funcionalidad de la aplicación considerada
		más importante según la visión de los \emph{stakeholders}.

		Para lograr esto, cada escenario tendrá asignada una prioridad, la cual estará dada por un entero mayor a cero
		cuyo valor es inversamente proporcional a la prioridad que se desea asignar a un escenario. Por ejemplo, un escenario
		con prioridad 2 es considerado más prioritario que otro con prioridad 6. Si bien se ofrece esta posibilidad al
		usuario, la misma debe manejarse con sumo cuidado ya que es probable que, al configurar escenarios con prioridades
		muy grandes, éstos no tengan prácticamente ningún peso a la hora de seleccionar la estrategia de autoreparación a
		aplicar, por lo cual dichos escenarios nunca serán reparados, careciendo de sentido así su existencia.

		La prioridad del escenario es una propiedad fundamental para el correcto funcionamiento de Arco Iris, veremos su
		importancia al detallar cómo Arco Iris selecciona la estrategia que aplicará para reparar el sistema en la sección
		\ref{sec:strategySelection}. Por esta razón será de extrema importancia el configurar a conciencia cuales serán los
		escenarios prioritarios: éstos deberán reflejar la importancia fundamental de los servicios ofrecidos por el sistema
		según las expectativas de los usuarios finales. Se recomienda realizar la asignación de la prioridad de cada escenario
		como un paso más del Quality Attribute Workshop (QAW), para más detalle ver la sección \ref{sec:QAS}.

	\subsection{Estrategias y su Relación con los Escenarios}
	\label{sec:strategies}

		Antes de sumergirnos en cómo Arco iris utiliza las estrategias implementadas para reparar escenarios, recordemos
		brevemente su utilización en Rainbow.

		Las estrategias en Rainbow tienen un conjunto de precondiciones que nos indican si dicha estrategia puede ser
		utilizada para reparar el sistema en un determinado momento. Esto implica que, en cuanto Rainbow detecta un problema
		en el sistema, deba recorrer todas las estrategias existentes para ver si son aplicables para las condiciones
		actuales, o sea que Rainbow no tiene manera de determinar a priori la utilidad de una estrategia en un momento dado.
		Por otro lado, la solución está atada a la detección del problema, entonces, al no poder modularizar en detección del
		problema y solución, se deben repetir las precondiciones por cada solución (estrategia) implementada.

		En Arco Iris se propone desacoplar la detección del problema de la solución, y para lograr esto utilizaremos los
		escenarios. Allí se definirán las condiciones de detección del problema, y se referenciarán las posibles estrategias
		de reparación a ser consideradas para su ejecución, en el caso de que el escenario en cuestión se vea comprometido,
		quedando así las estrategias exentas de conocer cuales son las circunstancias en las que su ejecución tiene sentido.
		Esto permite al arquitecto tener un mayor control sobre las estrategias a ejecutar en determinadas condiciones, ya que
		al situarse en un escenario concreto, él sabrá cuales serán las soluciones más adecuadas basándose en el entorno del
		sistema y en la prioridad del escenario actual. Obviamente, Arco Iris también ofrece la posibilidad de utilizar el
		comportamiento brindado por Rainbow, esto se logra simplemente indicando la opción que representa a todas las
		estrategias existentes (para más detalle ver \ref{sec:strategySelectionUI}) cuando se configura el escenario.
		Una ventaja derivada del agregado del concepto de \emph{Escenario} es que ahora los problemas y sus posibles
		soluciones (i.e. estrategias de reparación), pueden ser visibles a los usuarios y \emph{stakeholders} de la
		aplicación. Como ya sucedía en Rainbow, las estrategias poseen la información necesaria para permitir simular su
		aplicación y estimar en que condiciones quedaría el sistema luego de haber sido aplicadas (esta información será
		utilizada para la estimación de la nueva ``utilidad del sistema\footnote{Para más detalle acerca del concepto Utilidad
		del Sistema ver sección \ref{sec:systemUtility}}'').

		En Arco Iris, para poder escribir estrategias que involucren varias tácticas, el usuario contará con un mecanismo que
		le permitirá verificar si los escenarios de un determinado \emph{concern} y que han sido marcados para reparar, aún
		siguen sin cumplirse. En base a esta información la estrategia podrá decidir cómo continuar su ejecución. A
		continuación se muestra un ejemplo de su utilización:

		\begin{Verbatim}[gobble=4]
				define boolean RESP_TIME_STILL_BROKEN =
						ArcoIrisAdaptationManager.isConcernStillBroken("RESPONSE_TIME");

				/*
				 * This Strategy will drop fidelity once, observe, then drop again if necessary.
				 */
				strategy BruteReduceResponseTime
				[ styleApplies ] {
				  t0: (true) -> lowerFidelity(2, 100) @[5000 /*ms*/] {
				    t1: (!RESP_TIME_STILL_BROKEN) -> done;
				    t2: (RESP_TIME_STILL_BROKEN) -> lowerFidelity(2, 100) @[8000 /*ms*/] {
				      t2a: (!RESP_TIME_STILL_BROKEN) -> done;
				      t2b: (default) -> TNULL;  // in this case, we have no more steps to take
				    }
				  }
				}
			\end{Verbatim}

		Cómo se puede observar en el código, para que esto funcione es necesario tener definida la función
		\emph{isConcernStillBroken} en la clase \emph{ArcoIrisAdaptationManager}, a continuación vemos la implementación,
		notar que el usuario solamente deberá indicar cual es el \emph{concern} de su interés:

		\begin{Verbatim}[gobble=4]
				public static boolean isConcernStillBroken(String concernString) {
					Concern concern = Concern.valueOf(concernString);
					doLog(Level.INFO, "Is Concern " + concern + " Still Broken?");

					boolean result = false;
					for (SelfHealingScenario scenario : currentBrokenScenarios) {
						if (scenario.getConcern().equals(concern) &&
								scenarioBrokenDetector4CurrentSystemState.isBroken(scenario)) {
							result = true;
							break;
						}
					}
					doLog(Level.INFO, "Concern " + concern + (result == true ?
							" Still Broken!" : " Not Broken Anymore!!!"));
					return result;
				}
		\end{Verbatim}

	\subsection{Activación del Mecanismo de Auto Reparación}

		\todo{Explicar que cuando se lanza la adaptacion no se reciben mas actualizaciones al modelo hasta una vez finalizada
		la adaptacion comenzada}

		Con el nuevo enfoque presentado en este trabajo, dónde el \emph{Escenario} es el concepto central, es necesario
		establecer cambios en la lógica aplicada por el \emph{framework} a la hora de decidir en qué momento es necesario
		intentar auto reparar el sistema (i.e. evaluar sus restricciones o invariantes).

		En Rainbow, las restricciones del sistema se encuentran embebidas en la descripción arquitectónica de sus componentes,
		más precisamente en el modelo de la arquitectura, el cual se describe utilizando el lenguaje de descripción de
		arquitectura ACME (\ref{sec:acme}). Por ejemplo, para determinar que el tiempo de respuesta no debe exceder un
		umbral determinado es necesario definir un invariante en el componente que posee dicha propiedad, como se puede
		observar en el siguiente ejemplo tomado de la arquitectura de Znn:

		\begin{Verbatim}[gobble=4]
				Component Type ClientT extends ArchElementT with {

					Property experRespTime : float <<  default : float = 100.0; >> ;

					rule primaryConstraint = invariant self.experRespTime <= 1000;
				}
		\end{Verbatim}

		En Arco Iris ya no será necesario definir estas \emph{constraints} en la arquitectura, desacoplando así la arquitectura
		del sistema de la definición de condiciones a evaluar para lanzar la auto reparación. Ahora las restricciones estarán
		presentes en la \emph{Cuantificación de la Respuesta}(\ref{sec:responseMeasure}) de cada escenario. Al cambiar el modo
		de definir las \emph{constraints} se intenta además dar mayor visibilidad a los \emph{stakeholders} del sistema, para
		esto Arco Iris añade la posibilidad de definir las restricciones de manera visual utilizando Arco Iris UI
		(\ref{sec:arcoIrisUI}), para más detalle ver la sección \ref{sec:arcoIrisUI_constraints}. Todo esto hace que los
		\emph{stakeholders} puedan acceder de manera sencilla a las restricciones a las cuales debe acatarse el sistema,
		pudiendo editarlas sin la necesidad de poseer conocientos sobre las tecnologías utilizadas por el sistema o por el
		\emph{framework} de auto reparación.
		Para determinar si el sistema necesita auto repararse, Rainbow utiliza una funcionalidad ofrecida por ACME, que
		permite evaluar las restricciones descritas en el modelado de la arquitectura, para esto ACME provee una herramienta
		llamada \emph{Type Checker}. A continuación podemos observar cómo Rainbow se sirve de esta utilidad para decidir si
		debe lanzar la auto reparación o no:

		\begin{Verbatim}[gobble=4]
				public void evaluateConstraints () {
					IAcmeTypeChecker typechecker = m_acmeEnv.getTypeChecker();
					if (typechecker instanceof SynchronousTypeChecker) {
						SynchronousTypeChecker synchChecker = (SynchronousTypeChecker) typechecker;
						synchChecker.typecheckAllModelsNow();
						m_constraintViolated = !synchChecker.typechecks(m_acmeSys);
						if (m_constraintViolated) {
							Set<?> errors = m_acmeEnv.getAllRegisteredErrors();
							Oracle.instance().writeEvaluatorPanel(m_logger, errors.toString());
						}
					}
				}
		\end{Verbatim}

		Recordemos que en Arco Iris hemos desacoplado el modelado de la arquitectura de las restricciones que deben
		satisfacerse, por lo cual no podremos utilizar la funcionalidad provista por ACME. Para suplir esto, y también para
		poder permitir incluir toda la información necesaria en los escenarios y que la misma pueda ser visualizada y editada
		por todos los \emph{stakeholders} involucrados, hemos desarrollado nuestra propia implementación de las restricciones,
		la cual permiten expresar las mismas \emph{constraints} definidas en ACME, y en caso de ser necesario agregar un nuevo
		tipo de restricción permite fácilmente incorporar una nueva implementación implementando una interfaz muy sencilla
		(ver el apéndice \ref{sec:numericBinaryRelationalConstraintCode}). Estas \emph{constraints} serán de vital importancia
		a la hora de activar el mecanismo de auto reparación. Al iniciar, Arco Iris leerá todos los escenarios definidos, y
		armará un mapa que le permitirá optimizar las verificaciones recurrentes de los escenarios ante la llegada de cada
		estímulo. El mapa almacena todos los escenarios correspondientes a cada estímulo, así, ante la invocación de un
		estímulo en el sistema, Arco Iris sólo deberá verificar que se cumplan los escenarios relacionados con dicho estímulo,
		acotando así de manera sustancial la cantidad de chequeos a realizar. Recordar que en Rainbow, ante cualquier
		modificación en el estado de la arquitectura, es necesario verificar todas las restricciones definidas para la auto
		reparación.

		Paso a paso el proceso de activación de la auto reparación en Arco Iris consiste en lo siguiente:
		\begin{enumerate}
			\item El sistema en ejecución recibe la invocación de un estímulo.
			\item Se modifican las propiedades del Modelo de la Arquitectura del sistema como consecuencia del estímulo.
			\item Se buscan los escenarios que pueden verse afectados ante dicho estímulo.
			\item Una vez identificados los escenarios potencialmente afectados, se verifica que se cumplan sus restricciones,
			siempre y cuando el entorno del escenario coincida con el actual, de lo contrario el escenario se considera
			verificado automáticamente.
			\item En el caso de detectar que uno o más escenarios dejaron de cumplirse, se lanzará la auto reparación del
			sistema, para lo cual la primer tarea a realizar será decidir cual será la estrategia más conveniente a aplicar, o
			sea, cual estrategia maximiza la \emph{Utilidad del Sistema} en entorno de operación actual.
		\end{enumerate}

	\subsection{Selección de Estrategia}
	\label{sec:strategySelection}

		Arco Iris selecciona la estrategia a aplicar para reparar el sistema de un manera sustancialmente diferente con
		respecto a Rainbow. Para comenzar, Rainbow considerará todas las estrategias existentes mientras que Arco Iris se
		limitará a considerar las estrategias propuestas en el escenario que se ha dejado de satisfacer, esto obviamente
		reduce ampliamente el universo de posibilidades reduciendo así el tiempo de la autoreparación. Recordemos que la
		configuración de Arco Iris también ofrece la posibilidad de considerar todas las estrategias existentes, simulando
		así el comportamiento ofrecido por Rainbow evitándose el usuario de realizar una configuración más rigurosa en
		desmedro de la \emph{performance} de la autoreparación.

		Por su parte, Rainbow descartará las estrategias cuyas condiciones no se satisfagan, estás condiciones generalmente se
		corresponden con la restricción que ha dejado de cumplirse, por lo cual su lógica se encuentra duplicada en el
		modelado de la arquitectura y en la condición de la estrategia, consideremos la siguiente estrategia tomada de Znn a
		modo de ejemplo:

				\begin{Verbatim}[gobble=4]
				define boolean cViolation = exists c : T.ClientT in M.components |
						c.experRespTime > M.MAX_RESPTIME;

				strategy QuickDirtyReduceResponseTime
				[ cViolation ] {
				  t0: (/*hiLoad*/ cViolation) -> lowerFidelity(2, 100) @[2000 /*ms*/] {
				    t1: (!cViolation) -> done;
				  }
				}
				\end{Verbatim}

		Donde \emph{cViolation} representa la misma lógica dispuesta en el invariante determinado al modelar la
		arquitectura:
				\begin{Verbatim}[gobble=4]
				Component Type ClientT extends ArchElementT with {

			        Property experRespTime : float <<  default : float = 100.0; >> ;
					...
			        rule primaryConstraint = invariant self.experRespTime <= MAX_RESPTIME;
			    }
			    ...
			    Property MIN_RESPTIME : float = 100.0;

				\end{Verbatim}

		En Arco Iris, una vez que se ha detectado que un escenario ha dejado de satisfacerse, simplemente se toman como
		estrategias candidatas las definidas en él, evitando así el \emph{overhead} de volver a verificar las condiciones.

		Ahora bien, una vez determinado el subconjunto de estrategias a considerar, es necesario asignarle un valor a cada
		una para poder seleccionar la estrategia que luego de ser aplicada maximice el rendimiento del sistema, para esto
		definiremos el concepto de \emph{Utilidad del Sistema} y mostraremos la heurística propuesta para su cálculo tanto en
		Rainbow como en Arco Iris.

		\subsubsection{Utilidad del Sistema}
		\label{sec:systemUtility}

			Rainbow utiliza la teoría de la utilidad, concepto forjado en el estudio de la economía, que permite asignar una
			medida relativa de satisfacción sobre un sistema sobre el cual es necesario medir el impacto ante cambios
			determinados. Una vez definida esta medida, permite hablar con sentido sobre incrementar o decrementar la utilidad del
			sistema, y así explicar el impacto de una determinada decisión sobre el comportamiento del sistema.

			La idea principal al utilizar la teoría de la utilidad en Rainbow es enumerar explícitamente los atributos de calidad
			para las cuales se está evaluando la técnica de autoreparación; luego, indicar el peso dado a cada dimensión (ver
			\ref{rainbowScenario}). Por otro lado, al valor de cada atributo de calidad en el sistema se le aplicará la función
			de utilidad correspondiente, la cual se encuentra definida para cada \emph{concern} en el archivo de configuración de
			Rainbow llamado \emph{utilities.yml}. Ejemplo de función de utilidad correspondiente al tiempo de respuesta tomada de
			Znn:

				\begin{Verbatim}[gobble=4]
				utilities:
				  uR:
				    label: Average Response Time
				    mapping: "[EAvg]ClientT.experRespTime"
				    description: "Client experienced response time in milliseconds, R, defined as
				    				a float property 'ClientT.experRespTime' in the architecture"
				    utility:
				      0: 1.00
				      100: 1.00
				      200: 0.99
				      500: 0.90
				      1000: 0.75
				      1500: 0.50
				      2000: 0.25
				      4000: 0.00
				\end{Verbatim}

			Por último, Rainbow realizará la suma de estos valores ponderados por el peso de cada \emph{concern}, el resultado de
			esta suma recibirá el nombre de \emph{Utilidad del Sistema}. Pseudocódigo del cálculo de la utilidad del sistema en
			Rainbow:

			\begin{Verbatim}[gobble=4]
				puntaje = 0
				valoresPorConcern = valores actuales del sistema para cada concern
				Por cada concern
					uf = Funcion de Utilidad para el concern actual
					valorConcern = valoresPorConcern.get(concern)
					valorUtilidad = uf(valorConcern)
					valorPonderado = valorUtilidad * peso asignado al concern en la configuración estática de Rainbow
					puntaje = puntaje + valorPonderado
			\end{Verbatim}

			En el caso de Rainbow esta medida permitirá tener una noción de como impactará una determinada estrategia sobre el
			sistema, para lo cual cada táctica deberá explicitar los \emph{concerns} sobre los cuales impacta y en qué medida lo
			hace. Por ejemplo, en el caso de bajar un servidor en Znn se especifica la siguiente metainformación asociada a la
			táctica, representando el impacto estimado sobre el sistema:

			\begin{Verbatim}[gobble=4]
				dischargeServers:
					uR: +144
					uF: 0
					uC: -1.00
			\end{Verbatim}

			Esto significa que una vez ejecutada esta táctica, aproximadamente la \emph{performance} se verá degrada en 144
			milisegundos y la fidelidad permanecerá intacta, mientras que el costo se reduce en 1.

		\subsubsection{Puntuación de Estrategias según Rainbow}

			Una vez obtenido el subconjunto de estrategias aplicables, Rainbow procederá a asignarle un puntaje a cada
			una, el cual será un valor entre $0$ y $100$, y luego aplicará la estrategia de mayor puntaje.

			Para calcular el puntaje, lo primero que hará Rainbow será obtener los pesos asignados a cada \emph{concern}(e.g. costo,
			fidelidad, etc) según el escenario seleccionado (recordemos que el escenario ha sido configurado previo inicio de
			Rainbow), con los cuales pesará los valores estimados para cada \emph{concern} luego de la potencial aplicación de la
			estrategia y aplicados a la función de utilidad del respectivo \emph{concern}.

			La heurística aplicada por Rainbow para estimar el valor de cada \emph{concern} una vez aplicada la estrategia resulta
			de considerar la probabilidad que tiene cada rama de la estrategia de ser ejecutada y los atributos de las tácticas
			presentes en cada rama, esto es, el impacto que cada táctica representa sobre los \emph{concerns} del sistema, concepto
			explicado previamente en la sección \ref{sec:systemUtility}. Estos valores luego serán ponderados por el peso de cada
			\emph{concern} para el escenario seleccionado para obtener finalmente el puntaje de la estrategia. A continuación se
			muestra en pseudocódigo el cálculo de puntuación de una estrategia llevado a cabo por Rainbow:

			\begin{Verbatim}[gobble=4]
				puntaje = 0
				estimacionPorConcern = Estimar los valores para cada concern luego de aplicar la estrategia
				Por cada concern
					uf = Funcion de Utilidad para el concern actual
					estimacion = estimacionPorConcern.get(concern)
					valorUtilidad = uf(estimacion)
					valorPonderado = valorUtilidad * peso asignado al concern en la configuración estática de Rainbow
					puntaje = puntaje + valorPonderado
			\end{Verbatim}

		\subsubsection{Puntuación de Estrategias según Arco Iris}
		\label{sec:arcoIrisStrategyScoring}

			En el caso de Arco Iris el primer paso será calcular la utilidad del sistema antes de iniciar la autoreparación,
			asegurándose así de que la estrategia a aplicar no perjudique el rendimiento de la aplicación, i.e, la estrategia que
			resulte tener la puntuación máxima deberá mejorar la utilidad del sistema, de lo contrario Arco Iris no procederá a
			ejecutarla.

			La heurística aplicada por Arco Iris para el cálculo de la puntuación de una estrategia utilizará el conocimiento
			plasmado en los escenarios para determinar la mejor estrategia de reparación a aplicar, teniendo en cuenta, además
			del impacto estimado de la potencial ejecución de la estrategia sobre el sistema calculado ya por Rainbow, lo
			siguiente:
			\begin{itemize}
				\item el entorno de ejecución en el que se encuentra la aplicación y el peso que cada \emph{concern} tiene para
				dicho entorno,
				\item el \emph{concern} asociado al escenario, y
				\item las prioridades relativas entre los escenarios.
			\end{itemize}

			Es importante mencionar que para calcular la utilidad del sistema Arco Iris sólo considerará los escenarios
			habilitados.

			Para calcular la utilidad del sistema, Arco Iris asignará un determinado puntaje a cada escenario habilitado que se
			satisfaga, el resto de los escenarios serán ignorados, o lo que es equivalente, tendrán puntaje cero. Por cada escenario
			habilitado Arco Iris verificará si el mismo aplica para el entorno actual del sistema, en caso de no aplicar el
			escenario se satisface trivialmente, por lo que sumará a la utilidad del sistema. Para los escenarios que sí apliquen
			al entorno actual, Arco Iris evaluará si las condiciones del escenario se satisfacen y sólo en caso afirmativo sumarán a
			la utilidad del sistema.

			Ahora bien, una vez que se tienen los escenarios que pesarán sobre la utilidad del sistema, veamos cómo Arco Iris
			asignará un puntaje a cada uno.

			A continuación se puede ver plasmado en pseudocódigo el cálculo del puntaje de un escenario y como es utilizado para
			calcular el puntaje de la estrategia y a su vez como Arco Iris seleccionará la estrategia de mayor puntaje para
			reparar el sistema:

			\begin{Verbatim}[gobble=4]
				scoreMaximo = utilidad del sistema

				Por cada estrategia
					scoreStrategia = 0
					estimacionPorConcern = simular la aplicación de la estrategia y
							obtener el valor resultante para los concerns

					Por cada escenario habilitado
						Si se satisface
							prioridadRelativa = calcular prioridad relativa del escenario
							pesoConcern = peso que el entorno actual asigna al concern del escenario
							scenarioConcern = concern del escenario
							uf = funcion de utilidad para el concern del escenario
							utilidad = uf(estimacionPorConcern(scenarioConcern))
							puntajeEscenario = utilidad * prioridadRelativa * pesoConcern
							scoreStrategia = scoreStrategia + puntajeEscenario
						Fin
					Fin

					Si scoreStrategia > scoreMaximo
						estrategiaSeleccionada = estrategia actual
					Fin
				Fin
			\end{Verbatim}

			Como se puede observar, el primer paso es calcular la utilidad del sistema, ya que para que una estrategia sea
			seleccionada para reparar el sistema su aplicación debe mejorar al sistema en su conjunto, de lo contrario Arco Iris
			no efectuará ninguna acción de autoreparación. Luego, por cada estrategia, Arco Iris simulará su aplicación
			reutilizando para este punto la implementación de Rainbow. Lo importante de la simulación es obtener los valores
			estimados para cada \emph{concern}.

			Una vez obtenidos los valores estimados, Arco Iris iterará por los escenarios habilitados y por cada escenario que se
			satisfaga primero se deberá calcular la prioridad relativa del escenario, recordemos que cada escenario tiene una
			prioridad asignada, pero esa prioridad no puede ser tomada directamente para calcular la Utilidad del Sistema ya que los
			escenarios cuyas prioridades son valores menores representan una mayor importacia para los \emph{stakeholders}. Para
			calcular la prioridad relativa y permitir extender y/o modificar su lógica se ha definido la interfaz
			\verb@ScenarioRelativePriorityAssigner@, la cual define el siguiente método:


			\begin{Verbatim}[gobble=4]
				public abstract int relativePriority(SelfHealingScenario scenario);
			\end{Verbatim}

			Por defecto se provee la implementación \verb@DefaultScenarioRelativePriorityAssigner@, que calcula la prioridad
			relativa pesando los valores absolutos de las prioridades de los escenarios contra el escenario de menor prioridad,
			esto es, el escenario cuya prioridad tiene el máximo valor asignado de entre todos los escenarios:

			\begin{Verbatim}[gobble=4]
				public class DefaultScenarioRelativePriorityAssigner
						implements ScenarioRelativePriorityAssigner {

					@Override
					public int relativePriority(SelfHealingScenario scenario) {
						return (maxPriority - scenario.getPriority()) / maxPriority;
					}

					public DefaultScenarioRelativePriorityAssigner(int maxScenarioPriority) {
						this.maxPriority = maxScenarioPriority + 1;
					}

					private int maxPriority;

			}
			\end{Verbatim}

			Vale aclarar que se toma como prioridad máxima la del escenario menos prioritario más uno, para evitar que la
			prioridad relativa de dicho escenario sea cero y que sea ignorado en el cálculo de la Utilidad del Sistema.

			Una vez calculada la prioridad relativa del escenario, el siguiente paso será obtener el peso que el entorno actual
			asigna al \emph{concern} del escenario en cuestión. Por ejemplo, si el entorno actual es de alta carga, es lógico que
			los escenarios de \emph{performance} tengan un mayor peso que los escenarios de costo, por esto se pesan los escenarios según
			su \emph{concern} y el entorno en el que se encuentra el sistema.

			Luego, al igual que Rainbow, Arco Iris calculará la utilidad de los \emph{concerns} mediante la función de utilidad
			en base al valor estimado por la simulación para el \emph{concern} del escenario, pero además de pesar luego la
			utilidad por el peso del \emph{concern} (que en Rainbow es estático mientras que en Arco Iris dependerá del entorno
			actual del sistema), Arco Iris lo pesará con la prioridad relativa del escenario. Una vez obtenido este valor, será
			acumulado al puntaje de la estrategia, escogiendo finalmente la estrategia de mayor puntaje para reparar el sistema.

	\subsection{Modelo de Arco Iris}

		\todo{Turco: La idea de esta sección es la de mostrar el modelo de la extensión de una manera consolidada. No tiene
		sentido ponerlo al principio de la sección cuando muchos de los conceptos que se ven todavía no fueron explicados.}
		
		\todo{Jony: estoy de acuerdo pero tampoco esta bueno contar todo el cuentito sin graficos que ilustren, veamoslo\ldots}

		\todo{Hacer otro modelo con: ScenarioScoreAssigner,	BaseScenarioScoreAssigner,
		ScenarioScoreAssigner4CurrentSystemState, ScenarioScoreAssigner4StrategyScoring, ScenarioBrokenDetector,
		ScenarioRelativePriorityAssigner, DefaultScenarioRelativePriorityAssigner, etc?}