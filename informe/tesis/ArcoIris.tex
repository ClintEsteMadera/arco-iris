\section{Extensión a Rainbow: Arco Iris}

	\subsection{Introducción}

		Como ya se ha comentado anteriormente, la idea de este trabajo es extender el \emph{framework} Rainbow para poder
		lograr un mecanismo de auto reparación más flexible y con mayor capacidad expresiva, y con el objetivo de proveer visibilidad
		a los \emph{stakeholders} de la aplicación sobre dicho proceso, permitiéndoles involucrarse en la definición de
		escenarios de atributos de calidad del sistema, de sus prioridades relativas y de las estrategias a considerar en la		auto reparación del sistema cuando un escenario deja de cumplirse.
		A fin de lograr lo antedicho, se propone extender el \emph{framework} Rainbow, con la anuencia y apoyo de los
		integrantes del proyecto ABLE, quienes poseen su propiedad intelectual.

	\subsection{Rainbow \emph{out of the box}}

		En el diagrama de colaboración de objetos que se muestra en la Figura \ref{fig:Rainbow_Architecture} se pueden 		observar los principales componentes de la arquitectura de Rainbow.
		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/Rainbow_Architecture.png}
			\caption{Arquitectura de Rainbow}
			\label{fig:Rainbow_Architecture}
		\end{figure}}
		
		Observamos que, en Rainbow, una persona con rol de arquitecto (o similar) es el encargado de configurar el 
		\emph{framework} utilizando, básicamente, dos vías:
		\begin{enumerate}
			\item la creación de un modelo de la arquitectura del sistema al cual Rainbow va a adaptar. Dicho modelo se
			especifica utilizando el estilo de componentes y conectores (C\&C) y el lenguaje de descripción de arquitecturas
			ACME (ver sección \ref{sec:acme}). En dicho lenguaje, los componentes y conectores poseen propiedades (con valores
			asociados), restricciones y también se ofrece la posibilidad de especificar invariantes a nivel de sistema o sub
			sistema. Dichos invariantes y restricciones serán evaluados periódicamente por Rainbow para verificar que el sistema
			funcione dentro de los límites determinados como normales.
			\item la generación de un conjunto de archivos de configuración que especifican diversos aspectos relacionados con
			la definición del sistema a auto reparar, como por ejemplo: ubicación física del archivo ACME que describe la
			arquitectura del sistema, archivos de tácticas y estrategias de reparación (escritos en \emph{Stitch}), datos para
			la configuración de la conexión de Rainbow con el sistema en \emph{runtime}, etc.
		\end{enumerate}

		Podemos ver también en el gráfico anterior que los denominados \emph{Probes} son los componentes designados para
		interactuar directamente con el sistema a adaptar (el \emph{Target System}), obteniendo así información relevante a los
		fines de su auto reparación. Dicha información no es interpretada dentro de los \emph{probes}, sino que ellos delegan
		dicha tarea a los denominados \emph{Gauges}. Estos componentes son los encargados de interpretar la información provista por
		los \emph{probes} y traducirla a pares \verb@<Propiedad,Valor>@ donde \verb@Propiedad@ refiere al nombre de una
		propiedad correspondiente a un componente o conector de la arquitectura del sistema a adaptar, mientras que
		\verb@Valor@ es el nuevo valor que poseerá dicha propiedad.

		Normalmente, por cada tipo relevante de \emph{concern} que interese ser monitoreado en tiempo de ejecución existe un
		par \verb@<Gauge,Probe>@ asociado. Un ejemplo de \emph{concern} podría ser: ``tiempo de respuesta experimentado por el
		usuario'', el cual es un \emph{concern} relacionado al atributo de calidad \emph{performance}.

		El \emph{Gauge Coordinator}, tal como su nombre lo sugiere, coordina la información provista por todos los
		\emph{gauges} y se encarga de notificar los cambios en el sistema en ejecución al componente \emph{Rainbow Model}.
	
		\emph{Rainbow Model}, componente clave en la arquitectura del \emph{framework}, tiene como principal responsabilidad
		hacer efectiva la actualización de los valores de la propiedades de los componentes, conectores, sub sistemas o
		sistemas del modelo de arquitectura de la aplicación a adaptar. También es quien tiene el conocimiento necesario para
		detectar violaciones a las restricciones e invariantes presentes en el modelo de arquitectura con el cual el
		\emph{framework} ha sido configurado.

		Por otra parte, existe otro componente llamado \emph{Architecture Evaluator}, el cual consulta periódicamente a
		\emph{Rainbow Model} para tomar conocimiento de violaciones a restricciones definidas en el modelo de la arquitectura.
		En el caso de existir alguna violación, el \emph{Architecture Evaluator} dispara el mecanismo de adaptación invocando
		al \emph{Adaptation Manager}.

		El \emph{Adaptation Manager}, uno de los componentes más importantes de Rainbow, sigue una lógica un tanto compleja
		(explicada en detalle en la sección \ref{sec:strategySelection}) para determinar la estrategia de reparación que deja
		al sistema en el mejor estado posible, para luego ejecutarla.
		
		La \emph{Estrategia} contiene la lógica necesaria para reparar el sistema en ejecución mediante el uso de
		\emph{Tácticas}, que a su vez, utilizan a los denominados \emph{Effectors}, los cuales son componentes que realizan
		acciones simples y concretas sobre el sistema en ejecución, como por ejemplo ``aumentar el nivel de logging de un
		componente determinado''.

	\subsection{Rainbow + Escenarios = ``Arco Iris''}

			En el presente apartado se presenta someramente las características principales de la arquitectura de Rainbow
			luego de incorporar las extensiones planteadas en el presente trabajo, a las cuales denominamos ``Arco Iris''.

		\subsubsection{Arquitectura de Arco Iris}

			En la figura \ref{fig:Rainbow_Architecture_With_Scenarios} podemos observar como luce la arquitectura
			del \emph{framework} con la incorporación de las extensiones realizadas.

			\afterpage{\clearpage
			\begin{figure}[H]
				\centering
				\includegraphics[width=1.00\textwidth]{images/Arco_Iris_Architecture.png}
				\caption{Arquitectura de Arco Iris}
				\label{fig:Rainbow_Architecture_With_Scenarios}
			\end{figure}}

			El arquitecto sigue realizando las mismas tareas que realizaba en Rainbow (i.e. ``alimentarlo'' con el
			modelo de la arquitectura del sistema a adaptar y con archivos de configuración requeridos por Rainbow) pero ahora se
			le suma una tarea más: el configurar los escenarios de atributos de calidad; tarea que realiza en conjunto con una o
			más personas que asumen distintos roles que normalmente se engloban en la palabra \emph{stakeholders} (e.g. analistas
			funcionales, usuarios del sistema, líderes, clientes, el \emph{sponsor} del proyecto, etc.)

			En la versión original de Rainbow (i.e. sin extensiones) el \emph{framework} deja al usuario (e.g. el arquitecto) la
			responsabilidad de codificar los \emph{probes} y \emph{gauges} que recolectarán información del sistema a adaptar y
			traducirán esa información a cambios en los valores de las propiedades del sistema. Esto sigue siendo igual en
			Rainbow con las extensiones provistas por Arco Iris, es decir, el usuario sigue siendo el encargado de crear los
			componentes que en tiempo de ejecución encuestan al sistema periódicamente para obtener información relevante y
			mantener actualizado el modelo de la arquitectura subyacente.

			En el diagrama se puede observar que, en Arco Iris, tanto los \emph{probes} como los \emph{gauges} ahora poseen
			conocimiento del concepto de \textbf{estímulo} (tal cual es descrito en los escenarios de atributos de calidad de ATAM).
			A diferencia de los utilizados en Rainbow, los \emph{probes} implementados para trabajar con Arco Iris deberán
			indicar el estímulo al cual están asociados, mientras que los \emph{gauges} deberán interpretar esta información y
			notificar al \emph{Arco Iris Model} de la actualización sobre el modelo indicando el estímulo desencadenante. Las			novedades sobre los cambios ocurridos en el sistema en \emph{runtime} serán informados con el siguiente formato:			\verb@<Propiedad,Valor,Estímulo>@
			En función de las modificaciones al modelo original de Rainbow descritas en el párrafo anterior, el componente
			\emph{Gauge Coordinator} ha sido extendido (i.e. \emph{Arco Iris Gauge Coordinator}) conservando el comportamiento			original provisto por Rainbow. De esta manera, Arco Iris puede coordinar información proveniente de \emph{gauges} de			Rainbow y/o de Arco Iris con su correspondiente conocimiento sobre el estímulo originario de la modificación.
			De la misma manera, el componente \emph{Arco Iris Model} es una extensión de \emph{Rainbow Model}
			que permite manipular información de estímulos proveniente del \emph{Arco Iris Gauge Coordinator} sin perder el
			soporte original provisto por \emph{Rainbow Model}.

			Cuando \emph{Arco Iris Model} es notificado de que un estímulo ha sido invocado en el sistema solicita
			al \emph{Self Healing Configuration Manager} el subconjunto de escenarios habilitados que poseen dicho estímulo y que
			a su vez han dejado de cumplirse\footnote{De ahora en más, diremos equivalentemente que el escenario en esta
			situación se encuentra ``roto''.}. Luego de obtener este subconjunto de escenarios, invocará al \emph{Arco Iris
			Adaptation Manager}, extensión del componente original \emph{Adaptation Manager}, indicando el conjunto de escenarios
			detectados como ``rotos'' a los cuales debe intentar reparar considerando diversas variables como por ejemplo sus
			prioridades relativas.
			
			Además de detectar los escenarios rotos para un determinado estímulo, el componente \emph{Self Healing Configuration
			Manager} carga la denominada \emph{Self Healing Configuration}, una abstracción de la mayor parte de la información
			referente a auto reparación utilizada por Arco Iris. Esto incluye, por supuesto, los escenarios creados por los			\emph{stakeholders} y arquitectos.
		\subsubsection{Modelo de Restricciones en Arco Iris}
		\label{sec:modeloRestriccionesArcoIris}

			Tanto Rainbow como Arco Iris, hacen uso del concepto de \textbf{restricción}, que si bien se utiliza en distintos
			contextos debido a que ambos \emph{frameworks} enfocan la auto reparación desde distintos ángulos, ambos responden a
			la misma finalidad.
			
			Arco Iris utiliza restricciones en dos contextos distintos. Por un lado, las condiciones para conocer
			el entorno en que se encuentra el sistema no son más que meras restricciones, y por otro, la cuantificación de la
			respuesta no es más que una restricción que determina la condición necesaria para que el escenario se satisfaga.

			Rainbow utiliza el concepto de \emph{restricción} para:
			\begin{itemize}
				\item imponer condiciones sobre el modelo de la arquitectura que el sistema debe satisfacer en tiempo de ejecución,
				idealmente, en todo momento. Estas condiciones pueden predicar sobre propiedades de componentes, conectores, sub
				sistemas o directamente sobre todo el sistema.
				\item especificar precondiciones a la ejecución de tácticas y estrategias, así como también, para condicionar el
				algoritmo de cada estrategia.
			\end{itemize} 

			En el primer caso, las restricciones se encuentran expresadas en el lenguaje \textbf{Acme}. Si bien, se provee un
			modelo en Java de los distintos tipos de restricciones que un usuario del lenguaje normalmente querría expresar,
			dicha implementación se encuentra fuertemente acoplada a la lógica de \emph{parseo} utilizada por el lenguaje, lo
			cual imposibilitó su reutilización en Arco Iris.

			En el segundo caso, las restricciones se encuentran expresadas en el lenguaje \textbf{Stitch} y no poseen una
			contraparte en el lenguaje Java.

			Consecuentemente, Arco Iris implementa su propio modelo simplificado de restricciones, el cual se encuentra inspirado en
			el modelo de Acme, aunque desacoplado de cualquier otra lógica externa. Así, el concepto de restricción presentado en
			Arco Iris permite agregar nuevos tipos de restricciones simplemente implementando la interfaz \verb@Constraint@
			\footnote{Dicha implementación deberá ser agregada al enumerado ConstraintType en Arco Iris UI para que la UI reconozca
			el nuevo tipo}. La interfaz definida es la siguiente:

			\begin{Verbatim}[gobble=4]
                public interface Constraint {

                    boolean holds(Number value);

                    String getFullyQualifiedPropertyName();
                }
			\end{Verbatim}

			Mediante el método \verb@holds@, se define como responsabilidad de la misma \verb@Constraint@ el determinar si se
			cumple o no, recibiendo como parámetro el valor actual de la propiedad del modelo de la arquitectura sobre el cual
			predica la cuantificación de la respuesta. Es de notar que en el futuro esta interfaz podría ser modificada para
			soportar propiedades cuyos valores no sean numéricos.
			
			El método \verb@getFullyQualifiedPropertyName@ retornará el nombre completo calificado de la propiedad sobre la
			que predica, incluyendo el sistema y el componente al que pertenece, por ejemplo, \verb@ZNewsSys.ClientT.experRespTime@
			alude a la propiedad \verb@experRespTime@ de todos los componentes del sistema \verb@ZNewsSys@ que sean de tipo
			\verb@ClientT@. De la misma manera, se pueden referenciar propiedades de \textbf{instancias} particulares como por
			ejemplo: \verb@ZNewsSys.Server2.cost@.
			
			Para el presente trabajo se utilizó	una única implementación de esta interfaz, consistente en una
			relación binaria de orden ($=$, $>$, $>=$, $<$ o $<=$ ) entre una propiedad de un componente, conector, etc. de la
			arquitectura (e.g. \verb@server1.responseTime@) y una constante numérica. La implementación mencionada recibe el
			nombre de \emph{NumericBinaryRelationalConstraint} y su código puede verse en el apéndice
			\ref{sec:numericBinaryRelationalConstraintCode}.
			
			Dado que, como hemos mencionado anteriormente, las restricciones predican sobre propiedades del sistema en ejecución,
			cuyos valores son sensibles al ``ruido'' producido por la presencia de posibles \emph{outliers}, Arco Iris utiliza,
			al igual que Rainbow, el concepto de \emph{Exponential Moving Average} (presentado en la sección
			\ref{sec:exponentialAverage}) para evitar este efecto negativo que afecta tanto a la detección del entorno actual
			como a la verificación de los escenarios.
			
			\subsubsubsection{Cuantificación de las Restricciones}

				Rainbow utiliza las reglas e invariantes provistas en el lenguaje Acme para definir restricciones sobre el modelo de
				la arquitectura del sistema a reparar. Estas reglas e invariantes, se limitan a predicar únicamente sobre una
				instancia específica o bien sobre todas las instancias de un determinado tipo de componente.
				
				Ahora bien, en Rainbow, cuando la restricción aplica a un \textbf{tipo} de componente de la arquitectura, pueden
				darse dos casos: que se predique sobre el \textbf{valor promedio} de todas las instancias de dicho tipo de
				componente o bien sobre la \textbf{sumatoria}. Para implementar estos casos, Rainbow opta por interpretar las
				restricciones impuestas sobre el modelo en Acme como si predicaran implícitamente sobre el \emph{promedio} de todos
				los valores; y por otro lado, ofrece como mecanismo para expresar restricciones sobre la \emph{sumatoria} de
				todos los valores, la definición de precondiciones dentro de las estrategias de reparación definidas en en lenguaje
				\emph{Stitch}. El siguiente, es un ejemplo de cómo Znn impone restricciones sobre la sumatoria del costo de los
				servidores del sistema:
				
				\begin{Verbatim}[gobble=5]
					import op "org.sa.rainbow.stitch.lib.Model";
					...
					define float totalCost = Model.sumOverProperty("cost", servers);
					define boolean hiCost = totalCost >= M.THRESHOLD_COST;
					...
					/* This Strategy is triggered by the total server costs rising above acceptable
					 * threshold; this Strategy reduces the number of active servers
					 */
					strategy ReduceOverallCost
					[ hiCost ] {
					  t0: (hiCost) -> dischargeServers(1) @[2000 /*ms*/] {
					    t1: (!hiCost) -> done;
					    t2: (lowRespTime && hiCost) -> do[2] t0;
					    t3: (default) -> TNULL;
					  }
					}
					...
				\end{Verbatim}

				Se observa la utilización de una clase Java (\verb@Model.sumOverProperty("cost", servers)@) para obtener la
				sumatoria de los costos de los servidores. Esta forma de establecer restricciones (el ``qué'') se encuentra
				claramente acoplada con la forma de reparar el sistema (``el cómo'') y además, no existe una forma única de definir
				restricciones sobre el modelo, lo cual puede conducir a confusiones y potenciales inconsistencias; así como también
				redunda en poca flexibilidad para el usuario que define restricciones sobre el modelo, ya que esta manera de hacerlo
				requiere conocimiento técnico no trivial.

				Para subsanar esta falencia de diseño, Arco Iris agrega a las restricciones numéricas el concepto de				\textbf{Cuantificador}. El cual es extensible y actualmente soporta dos opciones: \textbf{sumatoria} o				\textbf{promedio}, los que especifican respectivamente si la condición predica sobre la sumatoria o el promedio de				los valores de una determinada propiedad, para todas las instancias en \emph{runtime} de un determinado componente.

	\subsection{Flexibilización de la Auto Reparación con QAS}

		Actualmente Rainbow posee conocimiento sobre el sistema a adaptar mediante el modelo de su arquitectura expresado en
		el lenguaje de descripción de arquitecturas Acme. En dicho modelo también se encuentran definidos invariantes y
		restricciones sobre el comportamiento esperado del sistema, información que luego es utilizada por Rainbow para
		detectar cuándo el sistema se encuentra en un estado no deseado. Existen algunos problemas con respecto a cómo Rainbow
		lleva a cabo esta tarea:
		\begin{itemize}
			\item Rainbow verifica que se satisfagan \textbf{todos} los invariantes y restricciones del modelo. En caso de
			detectar que alguna de estas condiciones no se satisfacen, no existe un correlato directo entre la restricción o
			invariante que deja de cumplirse con la o las estrategias de reparación que solucionan dicho problema. 
			\item Como consecuencia del punto anterior, Rainbow debe considerar todas las estrategias definidas para el sistema
			al momento de determinar la mejor estrategia de reparación a ejecutar.
			\item A fin de establecer un correlato indirecto entre aquello que causó el funcionamiento no esperado del sistema y
			las estrategias de reparación candidatas, se \textbf{replican} las restricciones o invariantes ya definidas en el
			modelo como precondiciones en las estrategias.
		\end{itemize}
		
		Se observa que este esquema es poco flexible ya que ante cualquier modificación en los requerimientos de auto
		reparación definidos para el sistema, el usuario deberá modificar tanto el modelo de la arquitectura como las
		estrategias de reparación asociadas. Esta redundancia, además de significar un trabajo de configuración innecesario
		para el usuario, puede llevar a inconsistencias que provocarían un comportamiento indeseado en la auto reparación del
		sistema.

		Por otro lado, el modificar el comportamiento de la auto reparación en Rainbow requiere un conocimiento técnico no
		trivial, por lo que el cambio debería ser realizado por el arquitecto del sistema, esto hace a Rainbow menos flexible
		ante cambios en los requerimientos de los usuarios no técnicos, ya que éstos no podrían llevar a cabo la modificación
		de requerimientos sin la asistencia activa de un usuario técnico.

 		Con el objetivo de subsanar las falencias anteriormente comentadas, Arco Iris extiende el conocimiento que
 		Rainbow posee sobre el sistema y lo organiza de una manera más adecuada. Esencialmente, se incluye información sobre
		los atributos de calidad del sistema que son relevantes para los \emph{stakeholders}. Se permite, por ejemplo, poder
		describir la importancia relativa de la \emph{performance}, la disponibilidad, etc.; definiendo así una serie de
		\emph{tradeoffs} entre distintos atributos de calidad requeridos para el sistema. El enfoque propuesto para lograr
		esto consiste en especificar \textbf{Escenarios de Atributos de Calidad}, tal cual fueron descritos en la sección
		\ref{sec:QAS}, extendiendo el concepto con información orientada a flexibilizar la auto reparación. Esta extensión es		explicada en detalle en la sección \ref{sec:modeloExtensionQAS}.
		
		A continuación se detallan las soluciones introducidas por Arco Iris para solucionar los problemas que
		posee Rainbow mencionados anteriormente:
		\begin{itemize}
			\item Gracias al uso de QAS, el invariante o restricción que en Rainbow se encontraba descrito en el modelo de la
			arquitectura, pasa a formar parte del \emph{response measure}. Luego, para solucionar la falta de correlato entre la
			detección del problema y su reparación, Arco Iris extiende el concepto de escenario, agregándole el conocimiento de
			cuáles son las estrategias de reparación candidatas para reparar el sistema.
			\item  Conforme a lo explicado en el punto anterior, se evita la necesidad de considerar todas las estrategias como
			candidatas, tal cual era el comportamiento original de Rainbow.
			\item Al contar con el correlato explícito entre el problema y sus posibles soluciones, ya no es necesario especificar
			precondiciones a las estrategias de reparación, flexibilizando y simplificando de esta manera el uso del
			\emph{framework} así como también eliminando la existencia de posibles inconsistencias en su configuración.		\end{itemize}

		En la Figura \ref{fig:QAS_Model} se puede observar el modelo diseñado para representar los QAS en Arco Iris. Este
		modelo cumple una tarea fundamental ya que toda esta información será manipulada constantemente por Arco Iris para
		llevar a cabo la auto reparación en base a las expectativas plasmadas por los \emph{stakeholders} al crear los escenarios.

		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/QAS_Model.png}
			\caption{Modelo de QAS}
			\label{fig:QAS_Model}
		\end{figure}}		
		
		De todos los atributos que posee un QAS, el \textbf{Estímulo}, el \textbf{Artefacto}, el \textbf{Entorno} y la
		\textbf{Cuantificación de la Respuesta} son particularmente relevantes a los fines de establecer información útil para
		el mecanismo de auto reparación. A lo largo de las próximas secciones se detalla el uso que hace Arco Iris de esta
		información para modificar, optimizar y flexibilizar la auto reparación llevada a cabo por Rainbow.

		\subsubsection{El Estímulo en la Auto Reparación}

			El \textbf{estímulo} de un escenario normalmente se asocia a un evento desencadenado en el sistema por la acción del
			alguno de sus usuarios. Dicho evento es el punto de entrada del escenario, el disparador (interno o externo) que
			inicia la interacción con el sistema, y más particularmente, con el artefacto del escenario en cuestión. Por ejemplo,
			supongamos que en un sistema de administración de cuentas bancarias un cliente intenta hacer una transferencia, en
			este caso la fuente del estímulo sería el cliente y el estímulo en sí mismo sería \emph{realizar transferencia}.
			En términos de auto reparación, generalmente el estímulo se encuentra asociado a una operación provista por el
			artefacto del sistema, el cual puede ser un componente, un conector o un sub sistema.

			Saber cuál es el estímulo de cada escenario permite optimizar la auto reparación, ya que habiendo ocurrido
			determinado estímulo, Arco Iris podrá detectar cuáles son los potenciales escenarios que pueden verse afectados y
			trabajará verificando dicho subconjunto, acotando así la cantidad de restricciones a verificar y, consecuentemente,
			optimizando el tiempo de la auto reparación.

			Cabe destacar que también se ofrece la posibilidad de no especificar el estímulo al configurar un escenario, es decir,
			se permite la opción de que el escenario aplique siempre, independientemente del estímulo que haya impactado al sistema.
			Esto puede ser útil para casos genéricos, por ejemplo, si se requiere que el tiempo de respuesta experimentado por el
			usuario nunca sobrepase determinado umbral sin importar la funcionalidad del sistema que el usuario esté utilizando.
			En particular, se podría no configurar ningún estímulo en ningún escenario, y en ese caso, Arco Iris verificará que
			se satisfagan todos los escenarios en cada iteración de la auto reparación cada vez que un estímulo perteneciente a
			cualquier escenario impacte sobre el sistema. Como puede se observar, es recomendable configurar el estímulo
			específico para cada escenario a fin de conseguir un funcionamiento más preciso del \emph{framework}.			Entonces, a diferencia de Rainbow, quien debe verificar todas las restricciones en todo momento, Arco Iris permite
			refinar el conjunto de escenarios que pueden verse afectados por efecto del estímulo que ocasiona el problema,
			reduciendo así la cantidad de restricciones e invariantes a verificar.

			Para notificar sobre el estímulo desencadente fue necesario extender los \emph{probes}, que, como ya mencionamos
			anteriormente, son los componentes encargados de extraer del sistema información referente a un
			determinado \emph{concern}, siendo los responsables también de volcar dicha información en un \emph{bus} compartido
			con otros \emph{probes}. De este bus, los \emph{gauges} consumirán la información para luego interpretarla y
			transformarla en cambios en los valores de propiedades del modelo de la arquitectura.
			
			La extensión de los \emph{probes} implicó la necesidad de extender los \emph{gauges} de manera tal que puedan
			interpretar la nueva información sobre estímulos agregada en cada uno de los mensajes creados por los \emph{probes}.
			
			Debido a que en el diseño original de Rainbow, los mensajes que los \emph{probes} envían a los \emph{gauges} son
			meras cadenas de texto, las extensiones realizadas a ambos componentes no presentaron mayores inconvenientes.
						Para graficar la diferencia en la implementación que genera el agregar el estímulo en la auto reparación, se
			ejemplificará una extensión a un \emph{probe} utilizado por Znn. El \emph{probe} escogido para extender y así poder
			ser utilizado en Arco Iris consiste simplemente en invocar un servicio, esperar su respuesta y medir el tiempo
			transcurrido entre la invocación y la respuesta; ésta será la información que el \emph{probe} reportará en el
			\emph{bus} que luego consultará e interpretará el \emph{gauge} correspondiente.
			
			A continuación se puede observar la configuración original utilizada en Znn para instanciar un \emph{probe} del tipo
			ClientProxyProbe, esta configuración se puede encontrar en el archivo \verb@probes.yml@, donde se declaran todos los
			\emph{probes} que serán instanciados al iniciar Rainbow:

			\begin{Verbatim}[gobble=4]
				probes: 
				ClientProxyProbe0: 
					alias: clientproxy 
					location: "localhost"
					type: java 
					javaInfo:
						class: org.sa.rainbow.translator.znews.probes.ClientProxyProbe
						period: 2000
						args.length: 1
						args.0: "http://delegate.oracle/"
			\end{Verbatim}

			Un ejemplo de la información que reporta un \verb@ClientProxyProbe@ con la configuración presentada
			anteriormente podría ser:
			
			\begin{Verbatim}[gobble=4]
				[fri may 13 22:15:04 2011]<clientproxy> localhost: 1532 ms
			\end{Verbatim}
			
			Tanto la configuración como la implementación de \verb@ClientProxy@ son muy similares a las de su contraparte de Arco
			Iris, \verb@ClientProxyWithStimulus@. En el apéndice \ref{sec:probesCode} se pueden observar ambas implementaciones,
			mientras que la configuración de una instancia de \verb@ClientProxyWithStimulus@ se puede observar a continuación:

			\begin{Verbatim}[gobble=4]
				ClientProxyProbeWithStimulus0:
					alias: clientproxyWithStimulus
					location: "localhost" 
					type: java 
					javaInfo:
						class: ar.uba.dc.arcoiris.znn.probes.ClientProxyProbeWithStimulus
						period: 2000
						args.length: 2
						args.0: "http://delegate.oracle/"
						args.1: "delegateStimulus"
			\end{Verbatim}

			Por último, se muestra la información reportada por una instancia de\\
			\verb@ClientProxyWithStimulus@ con la configuración que se acaba de presentar:
			
			\begin{Verbatim}[gobble=3]
			[fri may 13 22:15:04 2011]<clientproxyWithStimulus> localhost<stimulus:delegateStimulus>: 1532 ms
			\end{Verbatim}

			Algunas formas posibles de implementar \emph{probes} son:
			\begin{itemize}
			  \item Parseo e interpretación de información existente en archivos de logs del sistema o en el servidor en el cual
			  se ejecuta.
			  \item Invocaciones idempotentes a servicios provistos por el sistema, con el fin de obtener métricas sobre las
			  respuestas.
			  \item El sistema a adaptar puede ofrecer servicios específicos que provean información relevante para su auto
			  reparación.
			\end{itemize}

		\subsubsection{El Artefacto en la Auto Reparación}

			El \textbf{artefacto} se refiere al componente, conector o sub sistema afectado por el escenario, cualesquiera de
			ellos se encuentran descritos en el modelo de la arquitectura.

			La asociación de un artefacto particular a un escenario permite acotar las propiedades sobre las cuales podrá
			predicar la \textbf{cuantificación de la respuesta} (ver sección \ref{sec:responseMeasure}).

			La arquitectura presentada en Znn servirá para ejemplificar el concepto de artefacto. Cabe recordar que se trata
			de una arquitectura de estilo cliente-servidor, donde el componente de tipo \emph{ClientT} se define de la siguiente
			manera:

			\begin{Verbatim}[gobble=4]
				Component Type ClientT extends ArchElementT with {

				  Property deploymentLocation : string <<  default : string = "localhost"; >> ;

				  Property experRespTime : float <<  default : float = 100.0; >> ;

				  Property requestRate : float <<  default : float = 0.0; >> ;
				}
			\end{Verbatim}

			Suponiendo que se define el siguiente escenario:

			\begin{Quote}
				``Znn news debe servir el contenido de las noticias a los clientes en un tiempo de respuesta menor a 3 segundos en un
				entorno de operación normal.''
			\end{Quote}

			Dado que en la arquitectura de Znn se modela a los clientes como componentes de la arquitectura, con una
			propiedad específica \verb@experRespTime@ que representa el tiempo de respuesta experimentado por el usuario,
			claramente se observa que en este ejemplo \emph{ClientT} es el artefacto sobre el cual ha de predicar la verificación
			de validez del escenario anteriormente detallado. Más adelante, en la sección \ref{sec:responseMeasure}, se podrá
			observar cómo se configura dicha restricción en un escenario de atributos de calidad.

		\subsubsection{El Entorno en la Auto Reparación}
		\label{sec:environment}
		
			\subsubsubsection{El Concepto de Entorno en Rainbow}
			
				Si bien Rainbow utiliza el concepto de entorno y, para contribuir a la confusión del lector, lo llama
				\emph{scenario}, el mismo es configurable aunque estático, es decir, no se adapta dinámicamente a los cambios
				que experimenta el sistema en tiempo de ejecución.
				Rainbow implementa el entorno como una distribución específica de pesos relativos entre los distintos
				\emph{concerns} del sistema. A continuación se muestra un ejemplo de un entorno (\emph{scenario}) de Rainbow
				utilizado por Znn:
		
				\begin{Verbatim}[gobble=3]
					weights:
						scenario 1:
							uR: 0.35
							uF: 0.4
							uC: 0.25
						scenario 2:
							uR: 0.5
							uF: 0.3
							uC: 0.2
						scenario 2b:
							uR: 0.5
							uF: 0.2
							uC: 0.3
				\end{Verbatim}
				
				Observar que cada entorno asigna un valor a cada \emph{concern} del sistema, en donde, en este caso, \verb@uR@
				representa al Tiempo de Respuesta, \verb@uF@ a la Fidelidad de la información y \verb@uC@ al Costo. Notar que la
				sumatoria de los pesos de los distintos \emph{concerns} para cada entorno debe ser igual a 1.

				Esta información debe ser configurada en el archivo de configuración \emph{utilities.yml} utilizado por Rainbow. Aquí,
				como se puede observar, se definen más de un entorno, uno de los cuales luego deberá ser seleccionado por el
				arquitecto en el archivo de configuración \verb@rainbow.properties@ previo a la inicialización, intentando
				predecir cuáles serán las condiciones en las que el sistema deberá responder. Este entorno es utilizado por
				Rainbow al momento de seleccionar una estrategia para reparar el sistema. En la sección \ref{sec:strategySelection}
				se explica en detalle su utilización.

			\subsubsubsection{El Entorno en Arco Iris y su Importancia para la Auto Reparación}

				El concepto de \emph{scenario} de Rainbow es similar al concepto de Entorno planteada por QAS, el cual, a su vez
				ha sido extendido por Arco Iris. La diferencia fundamental radica en que, mientras en Rainbow el usuario debe
				predecir en qué entorno operará el sistema, Arco Iris lo detectará automáticamente. Más adelante en esta sección, se
				explicará en detalle cómo se lleva a cabo esta tarea.

				Concentrándonos ahora únicamente en Arco Iris, y de acuerdo a la definición de QAS, se define al \textbf{Entorno de
				Ejecución}, o simplemente, \textbf{Entorno} como el estado en el que el sistema se encuentra cuando recibe el
				estímulo que desencadena el escenario. A modo de ejemplo: al recibir una solicitud de creación de una cuenta
				bancaria el sistema puede encontrarse en ``operatoria normal'', en ``alta carga'' o quizás tal vez se encuentre
				``fuera de operación''.
				
				El entorno condiciona la validez del escenario en cuestión a que el sistema se encuentre en un determinado estado,
				ya que, por ejemplo, una respuesta esperada aceptable o fácil de cumplir bajo un entorno puede ser inaceptable o muy
				costosa en otro.
	
				En el escenario planteado en la sección anterior, si el sistema se encontrase en un entorno de ``alta carga'' el
				escenario se satisfaría trivialmente, ya que para considerar dicho escenario el sistema debería encontrarse en un
				entorno de ``operación normal''.
				
				De esta manera, el entorno del escenario es un elemento que permite a Arco Iris optimizar la búsqueda de escenarios
				que no se satisfacen en un determinado instante ante la recepción de un estímulo, ya que se ignorarán aquellos
				escenarios cuyo entorno posea condiciones que no se cumplen en dicho instante. Más adelante se profundizará sobre
				dichas condiciones.

			\subsubsubsection{Escenarios modelados con varios entornos}

				Si bien el concepto de escenario de atributo calidad, tal cual fue definido en la sección \ref{sec:QAS}, incluye
				únicamente un sólo entorno, en Arco Iris se ha decidido modelar al escenario con una \textbf{colección de
				entornos}. A fin de justificar esta decisión de diseño, supongamos que un \emph{stakeholder} desea que un
				determinado escenario sea válido en varios entornos. En ese caso, siguiendo la definición estricta de QAS dónde un
				escenario sólo posee un entorno, el \emph{stakeholder} debería crear varios escenarios idénticos, todos ellos
				difiriendo únicamente en su entorno. Esto es claramente inconveniente, más aún considerando que la cantidad de
				entornos configurables por el usuario no está acotada, lo cual podría llevar a una explosión innecesaria de
				escenarios cuasi idénticos.
				
				Ahora bien, habiendo dicho lo anterior, también puede ocurrir la situación dónde, de acuerdo al entorno de
				ejecución, se desea tener en cuenta subconjuntos distintos de estrategias de reparación. En este caso, no existe
				otra opción más que configurar distintos escenarios.
				
				Cabe destacar que, a fines de simplificar el problema y acotar así el alcance de este trabajo, en el modelo de
				Arco Iris se establece una restricción no poco importante: se presupone que el usuario de Arco Iris no cargará en el
				sistema entornos cuyas condiciones de aplicabilidad tengan intersección no nula. Esta simplificación, si bien no
				representa mayor problema a los fines de este trabajo, sí restringe futuras extensiones del mismo. La naturaleza de
				tal restricción y una posible solución son abordadas en detalle en la sección \ref{sec:flexibilizacionEntorno}.

			\subsubsubsection{Estructura y Características del Entorno}
				La estructura del entorno consiste en:
	
				\begin{itemize}
					\item Un nombre,
					\item Un conjunto de condiciones, y
					\item Un mapa \verb@<Concern, Peso>@
				\end{itemize}
	
				El \textbf{nombre} es simplemente una cadena de texto que sirve para rápidamente identificarlo.
	
				Las \textbf{condiciones} son predicados que predican sobre los valores de las propiedades del modelo de la
				arquitectura del sistema en tiempo de ejecución. Para que un sistema en ejecución se encuentre en un determinado
				entorno, deben satisfacerse \textbf{todas} sus condiciones. Para más información sobre la implementación en Arco
				Iris de las condiciones del entorno, ver la sección \ref{sec:modeloRestriccionesArcoIris}.
								
				El objetivo del \textbf{mapa de pesos} presente en la estructura del entorno es el de definir la importancia
				relativa de cada \emph{concern} cuando el sistema se encuentra en el entorno en cuestión. Dicho mapa debe contener
				todos los \emph{concerns} definidos para el sistema y la suma de sus pesos debe ser igual a uno. En la sección
				\ref{sec:arcoIrisStrategyScoring} se detalla de qué manera Arco Iris hace uso de estos pesos para escoger la mejor
				estrategia de reparación.
							
			\subsubsubsection{El Entorno ``ANY''}

				Una característica particular de Arco Iris es la de permitir expresar, mediante la selección de un pseudo-entorno
				preexistente denominado ``ANY'', que un determinado escenario aplica bajo cualquier entorno. Esto es equivalente a que
				el entorno del escenario no posea condición alguna, es decir, que el escenario aplica siempre, trivialmente, sin
				importar las condiciones actuales del sistema en ejecución. Esto puede resultar útil en algunos casos ya que simplifica
				la configuración del escenario, pero es importante tener en cuenta que, por otro lado, el rendimiento de la auto
				reparación se verá reducido puesto que el configurar uno o más entornos específicos por escenario otorga mayor precisión
				al permitir establecer la importancia (peso relativo) de cada \emph{concern} según el estado en el que el sistema se				encuentre.	
				El entorno ``ANY'' será asignado automáticamente al escenario si el usuario no especifica ningún entorno o, si por
				el contrario, decide explícitamente que el escenario aplique \textbf{en cualquier entorno de ejecución}. En
				cualquiera de los dos casos, Arco Iris asignará a todos los \emph{concerns} el mismo peso, con la intención de
				evitar otorgarle más importancia a algún \emph{concern} en particular. Esta decisión de equidistribuír los pesos
				relativos por \emph{concern} es, desde ya, arbitraria y se reconoce una posibilidad de mejora en vistas de un
				trabajo futuro. Para más información, ver \ref{asignacionEquidistribuidaPesos}.
	
				Para ejemplificar la importancia de configurar un entorno correctamente y no hacer abuso del pseudo-entorno ``ANY'',
				considerar, por ejemplo, un sistema el cual se encuentra bajo excesiva carga, y los \emph{stakeholders} consideran
				que bajo tales circunstancias lo más prioritario es optimizar la \emph{performance} del sistema. En ese caso, de no
				especificar el entorno no será posible otorgarle mayor peso a la \emph{performance} por sobre otros \emph{concerns},
				quedando únicamente la opción de aumentar la prioridad\footnote{se profundizará sobre este tema en la sección
				\ref{sec:priority}} de todos los escenarios relacionados con dicho \emph{concern}, tergiversando así dicha
				información, ya que en realidad lo óptimo sería asignarle más peso al \emph{concern performance} en el entorno de
				``Alta Carga''. Puesto de otra manera, el establecer que un escenario aplica en cualquier entorno, tiene como
				consecuencia que Arco Iris interprete que el entorno carece de importancia, dejando de lado los pesos de los
				\emph{concerns} y distribuyendo equitativamente su importancia relativa, lo cual es equivalente a que el concepto de
				\emph{concern} no exista.

		\subsubsection{La Cuantificación de la Respuesta en la Auto Reparación}
			\label{sec:responseMeasure}

			La \textbf{cuantificación de la respuesta} (o, en inglés, \emph{Response Measure}) es quizás la propiedad más
			importante de un escenario, de ella surgen las restricciones que deben ser evaluadas para que, en caso de no
			cumplirse, se lance la auto reparación. En pocas palabras, la cuantificación de la respuesta se define como la
			métrica según la cual se decide si la respuesta del sistema ante un determinado estímulo es aceptable o no.
			
			Para que un escenario se considere bien formado debe quedar claro cuál es la métrica o manifestación observable de su
			respuesta que se debe satisfacer. Latencia y \emph{throughput} son ejemplos de manifestaciones sobre las cuales puede
			predicar la cuantificación de la respuesta.

			Para graficar la importancia de contar con una cuantificación de la respuesta precisa, supongamos que contamos con la
			siguiente definición:

			\begin{Quote}
				``El sistema debe ser modificable para poder incorporar un nuevo generador de eventos discretos''
			\end{Quote}

			Esta premisa no es suficiente para medir el éxito de la incorporación de la nueva funcionalidad solicitada, ya que
			con suficiente tiempo y recursos, casi cualquier modificación es posible. Este escenario requiere una métrica, como
			por ejemplo: \emph{``Utilizando 160 horas/hombre''}. Esto fuerza al arquitecto a asegurar que el sistema sea
			modificable basándose en un criterio bien definido y con una métrica aplicable.

			Con respecto a la implementación, el componente más importante de la cuantificación de la respuesta es la
			restricción, cuyo modelo en Arco Iris fue anteriormente explicado en la sección
			\ref{sec:modeloRestriccionesArcoIris}.
			
			En Arco Iris las restricciones se sitúan en el contexto de un escenario de atributo de calidad, proveyendo así mayor
			visibilidad a los \emph{stakeholders}, las cuales antes se encontraban implementadas en el modelo de la arquitectura
			utilizando el lenguaje Acme, y consecuentemente, eran sólo conocidas y modificadas por los arquitectos y/o técnicos
			responsables de configurar el \emph{framework}.

			El siguiente ejemplo ha sido extraído de la arquitectura de Znn. Aquí se puede observar de qué manera se implementan
			las restricciones al utilizar Rainbow:
			
			\begin{Verbatim}[gobble=4] 
				Component Type ClientT {
					Property experRespTime : float <<  default : float = 100.0; >> ;
					rule primaryConstraint = invariant self.experRespTime <= 1000;
				}
			\end{Verbatim}

			Es importante recordar que en Rainbow, una vez que se detectó que la auto reparación debe ser lanzada debido a una
			restricción que dejó de cumplirse, se volverán a evaluar todas las restricciones definidas en las precondiciones de
			\textbf{todas las estrategias} para verificar si aplican o no dependiendo del estado actual del sistema. A
			continuación se muestra un ejemplo extraído de Znn de una estrategia y su precondición:

			\begin{Verbatim}[gobble=4]
				import model "ZNewsSys.acme" { ZNewsSys as M};
				...
				define boolean cViolation =
				    exists c : ClientT in M.components | c.experRespTime > 1000;
				...
				strategy BruteReduceResponseTime
				[ cViolation ] {
					...
					execute some tactic...
					...
				}
			\end{Verbatim}

			Como se puede observar, tanto la restricción en el modelo que desencadenó la auto reparación como la precondición de
			la estrategia son equivalentes, por lo que se duplica la lógica aumentando el costo de procesamiento, haciendo que la
			reparación sea más costosa y menos escalable. Además al duplicar la configuración, el costo de mantener el
			\emph{framework} es mayor.

			En Arco Iris no será necesario contar con las precondiciones de las estrategias, ya que el conocimiento de cuáles
			estrategias son capaces de reparar una determinada condición se encuentra plasmado en cada escenario. En definitiva, al
			utilizar Arco Iris el usuario accede a la posibilidad de configurar el comportamiento esperado del sistema mediante			la cuantificación de la respuesta de cada escenario, tarea que se ve sumamente facilitada al utilizar Arco Iris UI			(ver sección \ref{sec:arcoIrisUI}).
			Otra diferencia esencial con respecto al uso que Rainbow y Arco Iris hacen de las restricciones, es el momento en
			el que se aplican. Hemos visto anteriormente que Rainbow posee un componente llamado \emph{``Architecture
			Evaluator''}, cuya responsabilidad consiste en verificar de a intervalos la arquitectura del modelo, siempre y			cuando éste haya sufrido algunas modificación y no se esté ya ejecutando un proceso de auto reparación, esto implica			verificar absolutamente todas las restricciones del modelo. Arco Iris, en cambio, al descubrir un cambio en el			modelo, verifica que los escenarios se satisfagan, pero no todos los escenarios, sino solamente aquellos cuyo			estímulo coincida con el que desencadenó la actualización del modelo, optimizando así de manera drástica la cantidad			de restricciones a verificar, lo que hace más escalable la auto reparación.
	\subsection{Modelo Extendido de QAS}
	\label{sec:modeloExtensionQAS}
	
		Hasta aquí se ha detallado el uso que Arco Iris hace del modelo básico de QAS, pero como se mencionó anteriormente,
		es necesario extender este modelo para agregar información de auto reparación propiamente dicha.
		
		En la figura \ref{fig:Arco_Iris_QAS_Model} se puede observar el modelo del \textbf{escenario de auto reparación}\\
		(\verb@SelfHealingScenario@), el cual, además de ser un QAS tiene toda la información y la lógica necesaria para que
		Arco Iris pueda llevar a cabo su objetivo de flexibilizar la auto reparación.

		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/Arco_Iris_QAS_Model.png}
			\caption{Modelo de Arco Iris}
			\label{fig:Arco_Iris_QAS_Model}
		\end{figure}}

		Los escenarios de auto reparación pueden ser deshabilitados, considerando Arco Iris solamente aquellos escenarios
		habilitados al momento de reparar el sistema.

		Otra propiedad utilizada por Arco Iris y que no forma parte de la definición original de un QAS, es la prioridad. Cada
		\verb@SelfHealingScenario@ tiene preestablecida su prioridad (ver sección \ref{sec:priority} para más detalle). Un		escenario de Arco Iris también tiene el conocimiento necesario para determinar si se satisface según las condiciones		actuales del sistema, y también para predecir si seguirá satisfaciendose luego de una potencial aplicación de una		estrategia en particular.
		Otra extensión a QAS implementada por Arco Iris para optimizar la auto reparación consiste en que cada escenario
		conozca las estrategias que el arquitecto del sistema y los \emph{stakeholders} consideran son capaces de reparar el
		escenario en caso de que este haya dejado de satisfacerse. En la sección \ref{sec:strategies} puede verse en detalle		cómo Arco Iris explota esta información.
		Por último, es importante recordar que se ha extendido el concepto de \textbf{entorno} utilizado por QAS, el cual
		pasa a contar, además de con su nombre, con un conjunto de condiciones que serán utilizadas para saber si un determinado
		escenario aplica, dado su entorno, para las condiciones actuales del sistema, y además será capaz de determinar la		importancia de cada \emph{concern} para el caso en el que el sistema en ejecución se encuentre en este entorno. Esta		extensión ya fue explicada en detalle en la sección \ref{sec:environment}.	


	\subsection{Prioridades entre Escenarios}
	\label{sec:priority}
	
		\todo{TURCO Y JONY: continuar revisando desde aca}

		Una característica distintiva de Arco Iris, la cual no posee contraparte alguna en Rainbow, es la de ofrecer la
		posibilidad de \textbf{priorizar escenarios} asignándoles prioridades relativas, de modo tal que al momento de escoger
		una estrategia de auto reparación la estrategia seleccionada no comprometa a alguna otra funcionalidad de la aplicación
		considerada más importante según la visión de los \emph{stakeholders}.

		Para lograr lo antedicho, a cada escenario se le asigna una prioridad, representada por un valor numérico entero
		positivo que es inversamente proporcional a la importancia que se desea asignarle al escenario. Por ejemplo, un
		escenario con prioridad 2 es considerado más prioritario que otro con prioridad 6.
		
		Si bien esta nueva funcionalidad abre nuevas posibilidades al usuario, por otro lado, la misma debe manejarse con sumo
		cuidado ya que es probable que, al configurar escenarios con prioridades \emph{muy grandes}, éstos no tengan
		prácticamente ningún peso al momento de seleccionar la estrategia de auto reparación a aplicar, con lo cual dichos
		escenarios nunca serán reparados, careciendo de sentido así su existencia.

		La prioridad del escenario es una propiedad fundamental para el correcto funcionamiento de Arco Iris, veremos su
		importancia al detallar de qué manera Arco Iris selecciona la estrategia que aplicará para reparar el sistema en la
		sección \ref{sec:strategySelection}. Por esta razón será de extrema importancia la correcta configuración de cuáles
		serán los escenarios prioritarios: éstos deberán reflejar la importancia fundamental de los servicios ofrecidos por el
		sistema según las expectativas de los usuarios finales. Se recomienda realizar la asignación de la prioridad de cada
		escenario como un paso más del Quality Attribute Workshop (QAW), para más detalle ver la sección \ref{sec:QAW}.

	\subsection{Estrategias y su Relación con los Escenarios}
	\label{sec:strategies}

		Antes de profundizar en cómo Arco iris utiliza las estrategias implementadas para reparar escenarios, recordemos
		brevemente cómo se utilizan las mismas en Rainbow.

		Las estrategias en Rainbow tienen un conjunto de precondiciones que nos indican si dicha estrategia puede ser
		utilizada para reparar el sistema en un determinado momento. Esto implica que, en cuanto Rainbow detecta un problema
		en el sistema, deba recorrer todas las estrategias existentes para ver si son aplicables para las condiciones
		actuales. En otras palabras, Rainbow no tiene forma de determinar \textbf{a priori} la utilidad de una estrategia en
		el preciso momento en que una o más restricciones sobre el modelo de la arquitectura del sistema se dejan de cumplir.
		
		Por ejemplo, para que una estrategia que soluciona problemas de \emph{performance} no sea tenida en cuenta al reparar un
		escenario relacionado a un atributo de calidad distinto, como por ejemplo el costo, debe agregarse una precondición como
		la siguiente en la estrategia:

		\begin{Verbatim}[gobble=4]
			strategy SimpleReduceResponseTime
			  [ responseTimeConstraintViolation ] {
			  ...
			}
		\end{Verbatim}

		Donde \emph{responseTimeConstraintViolation} es un predicado que permite determinar si existe algún cliente cuyo tiempo
		de respuesta haya sobrepasado el tiempo de respuesta máximo permitido:

		\begin{Verbatim}[gobble=4]
			define boolean responseTimeConstraintViolation =
				exists c : T.ClientT in M.components | c.experRespTime > M.MAX_RESPTIME;
		\end{Verbatim}

		Con respecto al anterior ejemplo, es importante remarcar que, en caso de que el problema que se está intentando reparar
		no tenga relación con la \emph{performance}, Rainbow deberá de todos modos chequear el tiempo de respuesta de todos los
		clientes, mientras que en Arco Iris existe la posibilidad de evitarlo al configurar correctamente las estrategias
		asociadas a cada escenario.
			
		Como ya se ha mencionado, en Arco Iris si bien se utilizan el mismo tipo de tácticas y estrategias que en Rainbow (i.e.
		modeladas con Stitch), se propone desacoplar la detección del problema de su solución utilizando como medio para ello
		los escenarios de atributos de calidad. Allí se definen las condiciones para la detección del problema (restricciones
		dentro de la cuantificación de la respuesta) y se referenciarán las posibles estrategias de reparación a ser
		consideradas para su ejecución, en el caso de que el escenario en cuestión se vea comprometido. De esta forma, las
		estrategias quedan exentas de conocer cuáles son las circunstancias en las que su ejecución tiene sentido. Esto permite
		al arquitecto tener un mayor control sobre las estrategias a ejecutar en determinadas condiciones, ya que al situarse en
		un escenario concreto, él sabrá cuales serán las soluciones más adecuadas basándose en el entorno del sistema y en la
		prioridad del escenario en cuestión.				
		Cabe acotar que Arco Iris también ofrece la posibilidad de configurar el mismo comportamiento brindado por Rainbow: esto
		se logra simplemente indicando la opción que representa a ``todas las estrategias existentes'' cuando se configura el
		escenario (una forma sencilla de especificar ésto, utilizando Arco Iris UI, se explica en la sección
		\ref{sec:strategySelectionUI}).
				
		Al igual que en Rainbow, las estrategias poseen la información necesaria para permitir \textbf{simular su aplicación} y
		estimar en que condiciones quedaría el sistema luego de haber sido aplicadas. Esta información será utilizada para la
		estimación de la nueva ``utilidad del sistema'', concepto sobre el cual, se profundizará en la sección
		\ref{sec:systemUtility}.
		En Arco Iris, para poder escribir estrategias que involucren varias tácticas, el usuario contará con un mecanismo que
		le permitirá verificar si los escenarios de un determinado \emph{concern}, y que han sido marcados para reparar,
		siguen aún sin cumplirse. En base a esta información la estrategia podrá decidir cómo continuar su ejecución. A
		continuación se muestra un ejemplo de su utilización:

		\begin{Verbatim}[gobble=4]
				import op "org.sa.rainbow.adaptation.ArcoIrisAdaptationManager";
				...
				define boolean RESP_TIME_STILL_BROKEN =
						ArcoIrisAdaptationManager.isConcernStillBroken("RESPONSE_TIME");
				...
				/*
				 * This Strategy will drop fidelity once, observe, then drop again if necessary.
				 */
				strategy BruteReduceResponseTime
				[ styleApplies ] {
				  t0: (true) -> lowerFidelity(2, 100) @[5000 /*ms*/] {
				    t1: (!RESP_TIME_STILL_BROKEN) -> done;
				    t2: (RESP_TIME_STILL_BROKEN) -> lowerFidelity(2, 100) @[8000 /*ms*/] {
				      t2a: (!RESP_TIME_STILL_BROKEN) -> done;
				      t2b: (default) -> TNULL;  // in this case, we have no more steps to take
				    }
				  }
				}
				...
			\end{Verbatim}

		Cómo se puede observar en el código, para que este mecanismo funcione, es necesario importar la función
		\verb@isConcernStillBroken@ de la clase \verb@ArcoIrisAdaptationManager@, cuya implementación se verá a continuación.
		Notar que el usuario solamente deberá indicar cual es el \emph{concern} de su interés:

		\begin{Verbatim}[gobble=4]
				public static boolean isConcernStillBroken(String concernString) {
					Concern concern = Concern.valueOf(concernString);
					doLog(Level.INFO, "Is Concern " + concern + " Still Broken?");

					boolean result = false;
					for (SelfHealingScenario scenario : currentBrokenScenarios) {
						if (scenario.getConcern().equals(concern) &&
								scenarioBrokenDetector4CurrentSystemState.isBroken(scenario)) {
							result = true;
							break;
						}
					}
					doLog(Level.INFO, "Concern " + concern + (result == true ?
							" Still Broken!" : " Not Broken Anymore!!!"));
					return result;
				}
		\end{Verbatim}

	\subsection{Activación del Mecanismo de Auto Reparación}

		\todo{Explicar que cuando se lanza la adaptacion no se reciben mas actualizaciones al modelo hasta una vez finalizada
		la adaptacion comenzada}

		Con el nuevo enfoque presentado en este trabajo, dónde el \emph{Escenario} es el concepto central, es necesario
		establecer cambios en la lógica aplicada por el \emph{framework} a la hora de decidir en qué momento es necesario
		intentar auto reparar el sistema (i.e. evaluar sus restricciones o invariantes).

		En Rainbow, las restricciones del sistema se encuentran embebidas en la descripción arquitectónica de sus componentes,
		más precisamente en el modelo de la arquitectura, el cual se describe utilizando el lenguaje de descripción de
		arquitectura ACME (\ref{sec:acme}). Por ejemplo, para determinar que el tiempo de respuesta no debe exceder un umbral
		determinado es necesario definir una restricción en el componente que posee dicha propiedad, como se puede observar en
		el siguiente ejemplo tomado de la arquitectura de Znn:

		\begin{Verbatim}[gobble=4]
				Component Type ClientT extends ArchElementT with {

					Property experRespTime : float <<  default : float = 100.0; >> ;

					rule primaryConstraint = invariant self.experRespTime <= 1000;
				}
		\end{Verbatim}

		En Arco Iris ya no será necesario definir estas \emph{constraints} en la arquitectura, desacoplando así la arquitectura
		del sistema de la definición de condiciones a evaluar para lanzar la auto reparación. Ahora las restricciones estarán
		presentes en la \emph{Cuantificación de la Respuesta}(\ref{sec:responseMeasure}) de cada escenario. Al cambiar el modo
		de definir las \emph{constraints} se intenta además dar mayor visibilidad a los \emph{stakeholders} del sistema, para
		esto Arco Iris añade la posibilidad de definir las restricciones de manera visual utilizando Arco Iris UI
		(\ref{sec:arcoIrisUI}), para más detalle ver la sección \ref{sec:arcoIrisUI_constraints}. Todo esto hace que los
		\emph{stakeholders} puedan acceder de manera sencilla a las restricciones a las cuales debe acatarse el sistema,
		pudiendo editarlas sin la necesidad de poseer conocientos sobre las tecnologías utilizadas por el sistema o por el
		\emph{framework} de auto reparación.
		Para determinar si el sistema necesita auto repararse, Rainbow utiliza una funcionalidad ofrecida por ACME, que
		permite evaluar las restricciones descritas en el modelado de la arquitectura, para esto ACME provee una herramienta
		llamada \emph{Type Checker}. A continuación podemos observar cómo Rainbow se sirve de esta utilidad para decidir si
		debe lanzar la auto reparación o no:

		\begin{Verbatim}[gobble=4]
				public void evaluateConstraints () {
					IAcmeTypeChecker typechecker = m_acmeEnv.getTypeChecker();
					if (typechecker instanceof SynchronousTypeChecker) {
						SynchronousTypeChecker synchChecker = (SynchronousTypeChecker) typechecker;
						synchChecker.typecheckAllModelsNow();
						m_constraintViolated = !synchChecker.typechecks(m_acmeSys);
						if (m_constraintViolated) {
							Set<?> errors = m_acmeEnv.getAllRegisteredErrors();
							Oracle.instance().writeEvaluatorPanel(m_logger, errors.toString());
						}
					}
				}
		\end{Verbatim}

		Recordemos que en Arco Iris hemos desacoplado el modelado de la arquitectura de las restricciones que deben
		satisfacerse, por lo cual no podremos utilizar la funcionalidad provista por ACME. Para suplir esto, y también para
		poder permitir incluir toda la información necesaria en los escenarios y que la misma pueda ser visualizada y editada
		por todos los \emph{stakeholders} involucrados, hemos desarrollado nuestra propia implementación de las restricciones,
		la cual permiten expresar las mismas \emph{constraints} definidas en ACME, y en caso de ser necesario agregar un nuevo
		tipo de restricción permite fácilmente incorporar una nueva implementación implementando una interfaz muy sencilla
		(ver el apéndice \ref{sec:numericBinaryRelationalConstraintCode}). Estas \emph{constraints} serán de vital importancia
		a la hora de activar el mecanismo de auto reparación. Al iniciar, Arco Iris leerá todos los escenarios definidos, y
		armará un mapa que le permitirá optimizar las verificaciones recurrentes de los escenarios ante la llegada de cada
		estímulo. El mapa almacena todos los escenarios correspondientes a cada estímulo, así, ante la invocación de un
		estímulo en el sistema, Arco Iris sólo deberá verificar que se cumplan los escenarios relacionados con dicho estímulo,
		acotando así de manera sustancial la cantidad de chequeos a realizar. Recordar que en Rainbow, ante cualquier
		modificación en el estado de la arquitectura, es necesario verificar todas las restricciones definidas para la auto
		reparación.

		Paso a paso el proceso de activación de la auto reparación en Arco Iris consiste en lo siguiente:
		\begin{enumerate}
			\item El sistema en ejecución recibe la invocación de un estímulo.
			\item Se modifican las propiedades del Modelo de la Arquitectura del sistema como consecuencia del estímulo.
			\item Se buscan los escenarios que pueden verse afectados ante dicho estímulo.
			\item Una vez identificados los escenarios potencialmente afectados, se verifica que se cumplan sus restricciones,
			siempre y cuando el entorno del escenario coincida con el actual, de lo contrario el escenario se considera
			verificado automáticamente.
			\item En el caso de detectar que uno o más escenarios dejaron de cumplirse, se lanzará la auto reparación del
			sistema, para lo cual la primer tarea a realizar será decidir cual será la estrategia más conveniente a aplicar, o
			sea, cual estrategia maximiza la \emph{Utilidad del Sistema} en entorno de operación actual.
		\end{enumerate}

	\subsection{Selección de Estrategia}
	\label{sec:strategySelection}

		Arco Iris selecciona la estrategia a aplicar para reparar el sistema de un manera sustancialmente diferente con
		respecto a Rainbow. Para comenzar, Rainbow considerará todas las estrategias existentes mientras que Arco Iris se
		limitará a considerar las estrategias propuestas en el escenario que se ha dejado de satisfacer, esto obviamente
		reduce ampliamente el universo de posibilidades reduciendo así el tiempo de la autoreparación. Recordemos que la
		configuración de Arco Iris también ofrece la posibilidad de considerar todas las estrategias existentes, simulando
		así el comportamiento ofrecido por Rainbow evitándose el usuario de realizar una configuración más rigurosa en
		desmedro de la \emph{performance} de la autoreparación.

		Por su parte, Rainbow descartará las estrategias cuyas condiciones no se satisfagan, estás condiciones generalmente se
		corresponden con la restricción que ha dejado de cumplirse, por lo cual su lógica se encuentra duplicada en el
		modelado de la arquitectura y en la condición de la estrategia, consideremos la siguiente estrategia tomada de Znn a
		modo de ejemplo:

		\begin{Verbatim}[gobble=3]
			define boolean cViolation = exists c : T.ClientT in M.components |
					c.experRespTime > M.MAX_RESPTIME;
	
			strategy QuickDirtyReduceResponseTime
			[ cViolation ] {
			  t0: (/*hiLoad*/ cViolation) -> lowerFidelity(2, 100) @[2000 /*ms*/] {
			    t1: (!cViolation) -> done;
			  }
			}
		\end{Verbatim}

		Donde \emph{cViolation} representa la misma lógica dispuesta en el invariante determinado al modelar la arquitectura:
		\begin{Verbatim}[gobble=3]
			Component Type ClientT extends ArchElementT with {
	
		        Property experRespTime : float <<  default : float = 100.0; >> ;
				...
		        rule primaryConstraint = invariant self.experRespTime <= MAX_RESPTIME;
		    }
		    ...
		    Property MIN_RESPTIME : float = 100.0;
		\end{Verbatim}

		En Arco Iris, una vez que se ha detectado que un escenario ha dejado de satisfacerse, simplemente se toman como
		estrategias candidatas las definidas en él, evitando así el \emph{overhead} de volver a verificar las condiciones.

		Ahora bien, una vez determinado el subconjunto de estrategias a considerar, es necesario asignarle un valor a cada
		una para poder seleccionar la estrategia que luego de ser aplicada maximice el rendimiento del sistema, para esto
		definiremos el concepto de \emph{Utilidad del Sistema} y mostraremos la heurística propuesta para su cálculo tanto en
		Rainbow como en Arco Iris.

		\subsubsection{Utilidad del Sistema}
		\label{sec:systemUtility}

			Rainbow utiliza la teoría de la utilidad, concepto forjado en el estudio de la economía, que permite asignar una
			medida relativa de satisfacción sobre un sistema sobre el cual es necesario medir el impacto ante cambios
			determinados. Una vez definida esta medida, permite hablar con sentido sobre incrementar o decrementar la utilidad del
			sistema, y así explicar el impacto de una determinada decisión sobre el comportamiento del sistema.

			La idea principal al utilizar la teoría de la utilidad en Rainbow es enumerar explícitamente los atributos de calidad
			para las cuales se está evaluando la técnica de autoreparación; luego, indicar el peso dado a cada dimensión (ver
			\ref{sec:priority}). Por otro lado, al valor de cada atributo de calidad en el sistema se le aplicará la función
			de utilidad correspondiente, la cual se encuentra definida para cada \emph{concern} en el archivo de configuración de
			Rainbow llamado \emph{utilities.yml}. Ejemplo de función de utilidad correspondiente al tiempo de respuesta tomada de
			Znn:

				\begin{Verbatim}[gobble=4]
				utilities:
				  uR:
				    label: Average Response Time
				    mapping: "[EAvg]ClientT.experRespTime"
				    description: "Client experienced response time in milliseconds, R, defined as
				    				a float property 'ClientT.experRespTime' in the architecture"
				    utility:
				      0: 1.00
				      100: 1.00
				      200: 0.99
				      500: 0.90
				      1000: 0.75
				      1500: 0.50
				      2000: 0.25
				      4000: 0.00
				\end{Verbatim}

			Por último, Rainbow realizará la suma de estos valores ponderados por el peso de cada \emph{concern}, el resultado de
			esta suma recibirá el nombre de \emph{Utilidad del Sistema}. Pseudocódigo del cálculo de la utilidad del sistema en
			Rainbow:

			\begin{Verbatim}[gobble=4]
				puntaje = 0
				valoresPorConcern = valores actuales del sistema para cada concern
				Por cada concern
					uf = Funcion de Utilidad para el concern actual
					valorConcern = valoresPorConcern.get(concern)
					valorUtilidad = uf(valorConcern)
					valorPonderado = valorUtilidad * peso asignado al concern en la configuración estática de Rainbow
					puntaje = puntaje + valorPonderado
			\end{Verbatim}

			En el caso de Rainbow esta medida permitirá tener una noción de como impactará una determinada estrategia sobre el
			sistema, para lo cual cada táctica deberá explicitar los \emph{concerns} sobre los cuales impacta y en qué medida lo
			hace. Por ejemplo, en el caso de bajar un servidor en Znn se especifica la siguiente metainformación asociada a la
			táctica, representando el impacto estimado sobre el sistema:

			\begin{Verbatim}[gobble=4]
				dischargeServers:
					uR: +144
					uF: 0
					uC: -1.00
			\end{Verbatim}

			Esto significa que una vez ejecutada esta táctica, aproximadamente la \emph{performance} se verá degrada en 144
			milisegundos y la fidelidad permanecerá intacta, mientras que el costo se reduce en 1.

		\subsubsection{Puntuación de Estrategias según Rainbow}

			Una vez obtenido el subconjunto de estrategias aplicables, Rainbow procederá a asignarle un puntaje a cada
			una, el cual será un valor entre $0$ y $100$, y luego aplicará la estrategia de mayor puntaje.

			Para calcular el puntaje, lo primero que hará Rainbow será obtener los pesos asignados a cada \emph{concern}(e.g. costo,
			fidelidad, etc) según el escenario seleccionado (recordemos que el escenario ha sido configurado previo inicio de
			Rainbow), con los cuales pesará los valores estimados para cada \emph{concern} luego de la potencial aplicación de la
			estrategia y aplicados a la función de utilidad del respectivo \emph{concern}.

			La heurística aplicada por Rainbow para estimar el valor de cada \emph{concern} una vez aplicada la estrategia resulta
			de considerar la probabilidad que tiene cada rama de la estrategia de ser ejecutada y los atributos de las tácticas
			presentes en cada rama, esto es, el impacto que cada táctica representa sobre los \emph{concerns} del sistema, concepto
			explicado previamente en la sección \ref{sec:systemUtility}. Estos valores luego serán ponderados por el peso de cada
			\emph{concern} para el escenario seleccionado para obtener finalmente el puntaje de la estrategia. A continuación se
			muestra en pseudocódigo el cálculo de puntuación de una estrategia llevado a cabo por Rainbow:

			\begin{Verbatim}[gobble=4]
				puntaje = 0
				estimacionPorConcern = Estimar los valores para cada concern luego de aplicar la estrategia
				Por cada concern
					uf = Funcion de Utilidad para el concern actual
					estimacion = estimacionPorConcern.get(concern)
					valorUtilidad = uf(estimacion)
					valorPonderado = valorUtilidad * peso asignado al concern en la configuración estática de Rainbow
					puntaje = puntaje + valorPonderado
			\end{Verbatim}

		\subsubsection{Puntuación de Estrategias según Arco Iris}
		\label{sec:arcoIrisStrategyScoring}

			En el caso de Arco Iris el primer paso será calcular la utilidad del sistema antes de iniciar la autoreparación,
			asegurándose así de que la estrategia a aplicar no perjudique el rendimiento de la aplicación, i.e, la estrategia que
			resulte tener la puntuación máxima deberá mejorar la utilidad del sistema, de lo contrario Arco Iris no procederá a
			ejecutarla.

			La heurística aplicada por Arco Iris para el cálculo de la puntuación de una estrategia utilizará el conocimiento
			plasmado en los escenarios para determinar la mejor estrategia de reparación a aplicar, teniendo en cuenta, además
			del impacto estimado de la potencial ejecución de la estrategia sobre el sistema calculado ya por Rainbow, lo
			siguiente:
			\begin{itemize}
				\item el entorno de ejecución en el que se encuentra la aplicación y el peso que cada \emph{concern} tiene para
				dicho entorno,
				\item el \emph{concern} asociado al escenario, y
				\item las prioridades relativas entre los escenarios.
			\end{itemize}

			Es importante mencionar que para calcular la utilidad del sistema Arco Iris sólo considerará los escenarios
			habilitados.

			Para calcular la utilidad del sistema, Arco Iris asignará un determinado puntaje a cada escenario habilitado que se
			satisfaga, el resto de los escenarios serán ignorados, o lo que es equivalente, tendrán puntaje cero. Por cada escenario
			habilitado Arco Iris verificará si el mismo aplica para el entorno actual del sistema, en caso de no aplicar el
			escenario se satisface trivialmente, por lo que sumará a la utilidad del sistema. Para los escenarios que sí apliquen
			al entorno actual, Arco Iris evaluará si las condiciones del escenario se satisfacen y sólo en caso afirmativo sumarán a
			la utilidad del sistema.

			Ahora bien, una vez que se tienen los escenarios que pesarán sobre la utilidad del sistema, veamos cómo Arco Iris
			asignará un puntaje a cada uno.

			A continuación se puede ver plasmado en pseudocódigo el cálculo del puntaje de un escenario y como es utilizado para
			calcular el puntaje de la estrategia y a su vez como Arco Iris seleccionará la estrategia de mayor puntaje para
			reparar el sistema:

			\begin{Verbatim}[gobble=4]
				scoreMaximo = utilidad del sistema

				Por cada estrategia
					scoreStrategia = 0
					estimacionPorConcern = simular la aplicación de la estrategia y
							obtener el valor resultante para los concerns

					Por cada escenario habilitado
						Si se satisface
							prioridadRelativa = calcular prioridad relativa del escenario
							pesoConcern = peso que el entorno actual asigna al concern del escenario
							scenarioConcern = concern del escenario
							uf = funcion de utilidad para el concern del escenario
							utilidad = uf(estimacionPorConcern(scenarioConcern))
							puntajeEscenario = utilidad * prioridadRelativa * pesoConcern
							scoreStrategia = scoreStrategia + puntajeEscenario
						Fin
					Fin

					Si scoreStrategia > scoreMaximo
						estrategiaSeleccionada = estrategia actual
					Fin
				Fin
			\end{Verbatim}

			Como se puede observar, el primer paso es calcular la utilidad del sistema, ya que para que una estrategia sea
			seleccionada para reparar el sistema su aplicación debe mejorar al sistema en su conjunto, de lo contrario Arco Iris
			no efectuará ninguna acción de autoreparación. Luego, por cada estrategia, Arco Iris simulará su aplicación
			reutilizando para este punto la implementación de Rainbow. Lo importante de la simulación es obtener los valores
			estimados para cada \emph{concern}.

			Una vez obtenidos los valores estimados, Arco Iris iterará por los escenarios habilitados y por cada escenario que se
			satisfaga primero se deberá calcular la prioridad relativa del escenario, recordemos que cada escenario tiene una
			prioridad asignada, pero esa prioridad no puede ser tomada directamente para calcular la Utilidad del Sistema ya que los
			escenarios cuyas prioridades son valores menores representan una mayor importacia para los \emph{stakeholders}. Para
			calcular la prioridad relativa y permitir extender y/o modificar su lógica se ha definido la interfaz
			\verb@ScenarioRelativePriorityAssigner@, la cual define el siguiente método:


			\begin{Verbatim}[gobble=4]
				public abstract int relativePriority(SelfHealingScenario scenario);
			\end{Verbatim}

			Por defecto se provee la implementación \verb@DefaultScenarioRelativePriorityAssigner@, que calcula la prioridad
			relativa pesando los valores absolutos de las prioridades de los escenarios contra el escenario de menor prioridad,
			esto es, el escenario cuya prioridad tiene el máximo valor asignado de entre todos los escenarios:

			\begin{Verbatim}[gobble=4]
				public class DefaultScenarioRelativePriorityAssigner
						implements ScenarioRelativePriorityAssigner {

					@Override
					public int relativePriority(SelfHealingScenario scenario) {
						return (maxPriority - scenario.getPriority()) / maxPriority;
					}

					public DefaultScenarioRelativePriorityAssigner(int maxScenarioPriority) {
						this.maxPriority = maxScenarioPriority + 1;
					}

					private int maxPriority;

			}
			\end{Verbatim}

			Vale aclarar que se toma como prioridad máxima la del escenario menos prioritario más uno, para evitar que la
			prioridad relativa de dicho escenario sea cero y que sea ignorado en el cálculo de la Utilidad del Sistema.

			Una vez calculada la prioridad relativa del escenario, el siguiente paso será obtener el peso que el entorno actual
			asigna al \emph{concern} del escenario en cuestión. Por ejemplo, si el entorno actual es de alta carga, es lógico que
			los escenarios de \emph{performance} tengan un mayor peso que los escenarios de costo, por esto se pesan los escenarios según
			su \emph{concern} y el entorno en el que se encuentra el sistema.

			Luego, al igual que Rainbow, Arco Iris calculará la utilidad de los \emph{concerns} mediante la función de utilidad
			en base al valor estimado por la simulación para el \emph{concern} del escenario, pero además de pesar luego la
			utilidad por el peso del \emph{concern} (que en Rainbow es estático mientras que en Arco Iris dependerá del entorno
			actual del sistema), Arco Iris lo pesará con la prioridad relativa del escenario. Una vez obtenido este valor, será
			acumulado al puntaje de la estrategia, escogiendo finalmente la estrategia de mayor puntaje para reparar el sistema.

	\subsection{Modelo de Adaptación de Arco Iris}

		
		\todo{Turco: La idea de esta sección es la de mostrar el modelo de la extensión de una manera consolidada}
		
		\todo{Jony: no entiendo que se puede mostrar que no esté ya en Arco Iris QAS Model.png y en
		Arco Iris Architecture.png, agregué un modelo de la adaptación realizada por Arco Iris. No mencioné que hay un Score
		Assigner para el estado actual y otro para scorear la estrategia, cuando lleguemos acá vemos si ya se explicó.}
		
		En la figura \ref{fig:Arco_Iris_Adaptation_Model} se presenta el modelo conceptual de la adaptación
		llevada a cabo por Arco Iris, el cual ha sido desarrollado en detalle hasta aquí.
		
		\afterpage{\clearpage
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/Arco_Iris_Adaptation_Model.png}
			\caption{Modelo de Adaptación de Arco Iris}
			\label{fig:Arco_Iris_Adaptation_Model}
		\end{figure}}


	\subsection{Configuración de Arco Iris}
	
		\todo{Explicar SelfHealingConfiguration y su archivo de configuracion. No profundizar en los temas ya que se acaban de
		explicar (Traer subseccion ``Formato de salida: XML'' de ArcoIrisUI)}
		
		\todo{Mencionar que dicha configuración es administrada por SelfHealingConfigurationManager}

		\todo{Explicar: ``Para configurar todo lo visto en esta seccion de una manera mas amena el usuario podrá utilizar Arco
		Iris UI''}

		\subsubsection{Actualización Dinámica de Configuración}
		\label{sec:actualizacionDinamicaConfig}

			Una de las principales limitaciones de Rainbow es la imposibilidad de actualizar la configuración del \emph{framework}
			sin tener que reiniciar su ejecución. A fin de superar (al menos parcialmente) tal limitación, proponemos un simple
			mecanismo de detección de cambios en el archivo de configuración de Arco Iris, el cual, al detectar cualquier cambio en
			dicho archivo, \textbf{reemplazará dinámicamente la configuración de Arco Iris cargada en memoria por la nueva
			configuración}; todo esto sin necesidad de reiniciar el \emph{framework}.

			El mecanismo se ejecuta periódicamente cada $X$ milisegundos, siendo $X$ configurable utilizando el archivo de
			configuración estándar de Rainbow \verb@rainbow.properties@. La propiedad a configurar recibe el nombre
			de \verb@customize.scenarios.reloadInterval@, cuyo valor inicial por defecto será $5000$, es decir, el mecanismo de
			actualización se ejecutará cada 5 segundos.

			Se utiliza el patrón \emph{Observer}\footnote{Para más información acerca del patrón Observer, visitar
			\url{http://en.wikipedia.org/wiki/Observer_pattern}} como modo de notificar a todos aquellos objetos interesados en
			llevar a cabo alguna acción como consecuencia de un cambio en la configuración. El componente (\emph{observer}
			siguiendo la nomenclatura utilizada comúnmente en el patrón) más interesado en conocer cuando un cambio en la
			configuración tiene lugar es el denominado \textbf{SelfHealingConfigurationManager}, el cual, en ese caso, descarta
			toda la configuración de los escenarios cargada en memoria, tomando luego la nueva configuración del archivo
			recientemente actualizado. A partir de este momento Arco Iris continuará trabajando con la nueva configuración de
			escenarios sin detener en ningún momento su ejecución.
			
			El mecanismo descrito en este apartado se encuentra implementado en la clase\\
			\mbox{\textbf{FileSelfHealingConfiguracionDao}} y podemos ver su código a continuación:

			\begin{Verbatim}[gobble=4]
				private static final long CONFIG_RELOAD_INTERVAL_MS =
					Long.valueOf(Rainbow.property("customize.scenarios.reloadInterval"));

				private static final String SELF_HEALING_CONFIG_FILE_NAME =
					Rainbow.property("customize.scenarios.path");

				private static final File SELF_HEALING_CONFIG_FILE =
					Util.getRelativeToPath(Rainbow.instance().getTargetPath(), SELF_HEALING_CONFIG_FILE_NAME);
				(...)
				public FileSelfHealingConfigurationDao() {
					super();
					this.listeners = new HashSet<SelfHealingConfigurationChangeListener>();
					this.loadSelfHealingConfigurationFromFile();

					TimerTask task = new FileChangeDetector(SELF_HEALING_CONFIG_FILE) {
						@Override
						protected void onChange(File file) {
							logger.info(SELF_HEALING_CONFIG_FILE_NAME +
								" has just changed, reloading Self Healing Configuration!");
							loadSelfHealingConfigurationFromFile();
							notifyListeners();
						}
					};

					Timer timer = new Timer();
					timer.schedule(task, new Date(), CONFIG_RELOAD_INTERVAL_MS);
				}
				
				public void register(SelfHealingConfigurationChangeListener listener) {
					this.listeners.add(listener);
				}
				
				protected void notifyListeners() {
					for (SelfHealingConfigurationChangeListener listener : this.listeners) {
						listener.selfHealingConfigurationHasChanged();
					}
				}
								
				(...)
			\end{Verbatim}
