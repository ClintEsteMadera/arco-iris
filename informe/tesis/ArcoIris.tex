\section{Extensión a Rainbow: Arco Iris}

	\subsection{Introducción}

		Como ya se ha comentado anteriormente, la idea de este trabajo es extender el \emph{framework} ``Rainbow'' para poder
		lograr un mecanismo de auto reparación más flexible y con mayor capacidad expresiva, con el objetivo de proveer mayor
		visibilidad a los \emph{stakeholders} de la aplicación sobre dicho proceso, permitiéndoles así involucrarse en la
		definición de escenarios de uso real del sistema, incluyendo la relación de estos últimos con los atributos de
		calidad requeridos. La solución intenta involucrarlos también en la definición de prioridades de los escenarios
		y/o estrategias a considerar en la auto reparación del sistema cuando uno de los escenarios no se cumple.

		A fin de lograr lo antedicho, se consideró necesario extender el \emph{framework} Rainbow, cuyo código se encuentra
		escrito mayormente en el lenguaje de programación Java.

		Los integrantes del proyecto ABLE, que son quienes poseen propiedad intelectual sobre el \emph{framework}, no
		sólo decidieron proveer el código fuente completo para poder realizar esta extensión, sino que estuvieron dispuestos
		en todo momento a colaborar, responder dudas e inquietudes, hacer sugerencias, etc.

	\subsection{Rainbow ``out of the box''}

		El primer paso fue inspeccionar el código del framework y leer su documentación (la cual no es abundante, por
		cierto). Luego de ese primer paso, se tuvo una buena noción sobre el funcionamiento de Rainbow y sus componentes principales
		de arquitectura, las cuales se pueden observar en el siguiente diagrama de colaboración de objetos:

		\begin{center}
			\includegraphics[width=1.00\textwidth]{images/Rainbow_Architecture.png}
		\end{center}

		Observamos que, en Rainbow, una persona con rol de arquitecto (o similar) es el encargado de configurar el framework
		utilizando, básicamente, dos vías:
		\begin{enumerate}
			\item la creación de un modelo de la arquitectura del sistema al cual Rainbow va a adaptar. Dicho modelo se
			especifica utilizando el estilo de componentes y conectores (C\&C) y el lenguaje de descripción de arquitecturas
			ACME, ya descripto en el presente trabajo. En dicho lenguaje, los componentes y conectores poseen propiedades (con
			valores asociados), \emph{constraints} y también existe la posibilidad de especificar invariantes a nivel de sistema
			o sub sistema. Dichos invariantes serán evaluados periódicamente por Rainbow para verificar que el sistema funcione
			dentro de los límites determinados como normales.
			\item la generación de un conjunto de archivos de configuración que especifican diversos aspectos relacionados con
			la definición del sistema a auto-reparar, como por ejemplo: ubicación física del archivo ACME que describe la
			arquitectura de este último, archivos de tácticas y estrategias de reparación (estos escritos en un lenguaje de
			\emph{scripting} de propósito específico llamado ``stitch''), datos para la configuración de la conexión de Rainbow
			con el sistema en \emph{runtime}, etc.
		\end{enumerate}

		Podemos ver también en el gráfico anterior, cómo los denominados \emph{Probes} son los componentes designados en
		Rainbow para interactuar directamente con el sistema a adaptar (el \emph{Target System}), obteniendo así información
		relevante a los fines de su auto-reparación. Dicha información no es interpretada dentro de los probes sino que ellos
		delegan dicha tarea a los denominados \emph{Gauges}. Estos componentes son los encargados de entender la información
		provista por los gauges y traducirla a pares $<$Propiedad,Valor$>$ dónde la \emph{Propiedad} refiere al nombre de una
		propiedad correspondiente a un componente (o conector o subsistema, etc\ldots) de la arquitectura del sistema a
		adaptar; y \emph{Valor} es ni más ni menos que el nuevo valor que posee dicha propiedad.

		Normalmente, existe un par $<$Gauge, Probe$>$ distinto (que a nivel implementativo son clases Java) por cada tipo
		relevante de \emph{concern} que interese ser monitoreado en tiempo de ejecución. Un ejemplo de \emph{concern} podría
		ser: ``tiempo de respuesta experimentado por el usuario'', el cual es un \emph{concern} relacionado al atributo de
		calidad \emph{performance}.

		Asociado al tipo de componente \emph{Gauge}, se encuentra el \emph{Gauge Coordinator} el cual, tal como su nombre lo
		sugiere, coordina la información provista por todos los gauges e invoca a la operación \verb@update property@ del
		componente \emph{Rainbow Model}.

		\emph{Rainbow Model}, componente clave en la arquitectura del \emph{framework}, tiene, entre otras cosas, la
		responsabilidad de hacer efectiva la actualización de los valores de la propiedades de los componentes, conectores,
		sub-sistemas o sistemas del modelo de arquitectura de la aplicación a adaptar. También verifica periódicamente si se
		ha violado alguna de las \emph{constraints} presentes en el modelo de arquitectura con el cual el \emph{framework} ha
		sido inicializado.

		Por otra parte, existe otro componente llamado \emph{Architecture Evaluator}, el cual consulta periódicamente a
		\emph{Rainbow Model} sobre si se ha violado alguna constraint. En ese caso, el \emph{Architecture Evaluator} dispara
		el mecanismo de adaptación invocando al \emph{Adaptation Manager} (este último, junto con el \emph{Rainbow Model}, el
		componente más importante de todos).

		El \emph{Adaptation Manager} sigue una lógica un tanto compleja (que luego explicaremos en detalle) para determinar la
		mejor estrategia de reparación a realizar y luego, mediante \emph{Effectors} (no mostrados en el gráfico anterior por
		claridad), la lógica embebida en las estrategias de reparación impactan en el sistema a ser adaptado, siempre
		intentando acercar el estado del sistema a sus invariantes pre-establecidos.

	\subsection{Rainbow + Escenarios = ``Arco Iris''}

			En el presente apartado repasaremos someramente las características principales de la arquitectura de Rainbow
			luego de incorporar las extensiones planteadas en el presente trabajo, a las cuales denominamos ``Arco Iris''.

		\subsubsection{Compatibilidad hacia atrás}

			Uno de los objetivos de diseño más importantes planteados al momento de pensar ``Arco Iris'' fue sin
			duda el intentar que la presente extensión fuera ``compatible hacia atrás'' con \emph{Rainbow}, es decir, es
			altamente deseable que la extensión se inserte en el \emph{framework} (conceptualmente hablando) de manera similar a
			cómo un \emph{plug-in} trabaja en cualquier otro sistema de software; pudiendo en este caso el usuario de manera
			relativamente simple poder elegir entre utilizar los mecanismos de auto reparación provistos por ``Arco Iris'' solos,
			conjuntamente con los de Rainbow, o usar unicamente Rainbow original sin extensión alguna.  La implementación de
			``Arco Iris'' cumple con dicho requerimiento ya que en la misma se extienden (en el sentido estricto de la palabra)
			componentes, sin cambiar su lógica original. Es importante notar que para que la extensión sea fácilmente adicionable
			y/o removible se necesitaría que los creadores de Rainbow hagan mínimos cambios a la visibilidad de algunos
			componentes del \emph{framework} (i.e. clases Java), ya que su implementación está hecha de tal manera que impide la
			extensión, ya sea vía herencia o composición de clases.

		\subsubsection{Arquitectura de Arco Iris}

			A continuación, veremos cómo luce la arquitectura del framework con la incorporación de las extensiones realizadas:

			\begin{center}
				\includegraphics[width=1.00\textwidth]{images/Rainbow_Architecture_With_Scenarios.png}
			\end{center}

			El arquitecto sigue realizando las mismas tareas que realizaba en Rainbow (i.e. ``alimentar'' a Rainbow con un
			modelo de la arquitectura del sistema a adaptar y archivos de configuración) pero ahora se le suma una tarea más: el
			configurar los escenarios de atributos de calidad; tarea que realiza en conjunto con una o más personas que asumen
			distintos roles que normalmente se engloban en la palabra \emph{stakeholders} (e.g. analistas funcionales, usuarios
			del sistema, líderes y sponsors del proyecto, clientes, etc.)

			En Rainbow original (i.e. sin extensiones) el framework deja al usuario final la responsabilidad por codificar los
			\emph{probes} y \emph{gauges} que recolectarán información del sistema a adaptar y traducirán esa información a
			cambios en los valores de las propiedades del sistema. Esto sigue siendo igual en Rainbow con las extensiones
			provistas por Arco Iris, es decir, el usuario final sigue siendo el encargado de crear los componentes
			que en tiempo de ejecución encuestan al sistema periódicamente para obtener información relevante.

			Así, en el anterior diagrama podemos observar que tanto el \emph{probe} como el \emph{gauge} normalmente tendrán que
			tener conocimiento del concepto de ``estímulo'' (tal cual está descrito por ATAM en sus escenarios de atributos de
			calidad).

			Puesto que en la presente extensión el componente \emph{Gauge} ahora provee información sobre los estímulos que
			desencadenaron un cambio de propiedades en el sistema ejecutándose, el componente \emph{Gauge Coordinator} ha sido
			extendido (ahora llamado \emph{Gauge Coordinator With Scenarios}) para soportar dicho agregado de información, sin
			perder el comportamiento original provisto por Rainbow. Esto hace que este componente siga pudiendo coordinar información
			proveniente de \emph{gauges} de Rainbow y \emph{gauges} con conocimiento sobre el estímulo invocado en el sistema en
			ejecución.

			De la misma manera anterior, el componente \emph{Rainbow Model With Scenarios} ha sido extendido para manejar
			información de estímulos proveniente del \emph{Gauge Coordinator With Scenarios} sin perder el soporte original
			provisto por \emph{Rainbow Model}. También, \emph{Rainbow Model With Scenarios} es el componente que carga los
			escenarios de atributos de calidad creados por los \emph{stakeholders} y arquitecto(s).

			En el caso de que el \emph{Rainbow Model} detecte que un estímulo ha sido invocado en el sistema en ejecución,
			procederá a recabar el subconjunto de escenarios habilitados que poseen dicho estímulo y que a su vez se encuentran
			no cumpliéndose\footnote{De ahora en más, diremos que el escenario en esta situación se encuentra ``roto''.}. Luego
			de obtener este subconjunto de escenarios, procederá a invocar al \emph{Adaptation Manager With Scenarios}, extensión
			del componente original que soporta tanto invocaciones desde el \emph{Architecture Evaluator} original de Rainbow,
			como así también invocaciones con un conjunto de escenarios detectados como ``rotos'' a los cuales debe intentar
			reparar considerando diversas variables como por ejemplo sus prioridades relativas.

		\subsubsection{Actualización dinámica de cambios de configuración}

			Una de las principales limitaciones de Rainbow es la imposibilidad de actualizar la configuración del
			\emph{framework} sin tener que reiniciar su ejecución. A fin de superar (al menos parcialmente) tal limitación,
			proponemos un simple mecanismo de detección de cambios en el archivo de configuración de Arco Iris \todo{poner una
			referencia a la parte del doc donde se explica en detalle este archivo}, el cual, al detectar cualquier cambio en
			dicho archivo, \textbf{reemplazará dinámicamente la configuración de Arco Iris cargada en memoria por la nueva
			configuración}; todo esto sin necesidad de reiniciar el \emph{framework}.
			
			El mecanismo se ejecuta periódicamente cada $X$ milisegundos dónde $X$ es configurable utilizando el archivo de
			configuración estándar de Rainbow (inicialmente, $X = 5000$, es decir, el mecanismo se ejecuta cada 5 segundos).
			
			Se utiliza el patrón \emph{Observer}\footnote{Para más información acerca de Eclipse, visitar
			\url{http://en.wikipedia.org/wiki/Observer_pattern}} como modo de notificar a todos aquellos objetos interesados en
			llevar alguna acción a cabo como consecuencia de un cambio en la configuración. El componente más interesado en
			conocer cuando un cambio en la configuración tiene lugar es el denominado \textbf{SelfHealingConfigurationManager},
			el cual, en ese caso, recalcula una variada cantidad de información guardada en memoria para que pueda ser usada
			instantáneamente por el componente \textbf{RainbowModelWithScenarios}.
			
			El mecanismo descripto en este apartado se encuentra implementado en la clase\\
			\mbox{\textbf{FileSelfHealingConfiguracionDao}} y podemos ver su código a continuación:
			
			\begin{Verbatim}[gobble=4]
				private static final long CONFIG_RELOAD_INTERVAL_MS =
					Long.valueOf(Rainbow.property("customize.scenarios.reloadInterval"));
			
				private static final String SELF_HEALING_CONFIG_FILE_NAME =
					Rainbow.property("customize.scenarios.path");
			
				private static final File SELF_HEALING_CONFIG_FILE =
					Util.getRelativeToPath(Rainbow.instance().getTargetPath(), SELF_HEALING_CONFIG_FILE_NAME);
				(...)
				public FileSelfHealingConfigurationDao() {
					super();
					this.listeners = new HashSet<SelfHealingConfigurationChangeListener>();
					this.loadSelfHealingConfigurationFromFile();
			
					TimerTask task = new FileChangeDetector(SELF_HEALING_CONFIG_FILE) {
						@Override
						protected void onChange(File file) {
							logger.info(SELF_HEALING_CONFIG_FILE_NAME +
								" has just changed, reloading Self Healing Configuration!");
							loadSelfHealingConfigurationFromFile();
							notifyListeners();
						}
					};
			
					Timer timer = new Timer();
					timer.schedule(task, new Date(), CONFIG_RELOAD_INTERVAL_MS);
				}
				(...)
			\end{Verbatim}

	\subsection{ATAM para Flexibilizar la Auto Reparación}

		Actualmente Rainbow posee conocimiento sobre la arquitectura del sistema a adaptar mediante un modelo de su arquitectura
		expresado en el lenguaje de descripción de arquitecturas Acme. Uno de los objetivos de Arco Iris es extender el
		conocimiento que el \emph{framework} tiene sobre el sistema en general. Este nuevo conocimiento será utilizado por Arco
		Iris en tiempo de ejecución para refinar y optimizar la auto reparación.

		Esencialmente, se incluye información sobre los atributos de calidad del sistema que son relevantes para los
		\emph{stakeholders} del sistema en tiempo de ejecución. Se permite, por ejemplo, poder describir la importancia relativa
		de la \emph{performance}, la usabilidad, la disponibilidad, etc.; definiendo así una serie de \emph{tradeoffs} entre
		distintos atributos de calidad requeridos por el sistema. El enfoque propuesto para lograr esto consiste en especificar
		\textbf{Escenarios de Atributos de Calidad} \cite{Scenarios} (de ahora en más, simplemente ``Escenarios''), tal cual
		fueron descriptos anteriormente, aunque con algunos agregados de información orientados a la auto reparación.

		Como ya vimos anteriormente, un Escenario modela una situación concreta y real de uso del sistema ante la cual debe
		comportarse de una manera esperada. Los escenarios contienen la siguiente información:
		\begin{itemize}
			\item Fuente del Estímulo
			\item Estímulo
			\item Artefacto
			\item Entorno
			\item Respuesta
			\item Cuantificación de la Respuesta
		\end{itemize}

		Supongamos que tenemos el siguiente escenario:

		\begin{quote}
			Un proceso del sistema recibe un mensaje externo no anticipado durante un modo de operación normal. El
			proceso informa al operador y continúa su operación sin caídas.
		\end{quote}

		Veamos cómo se desgloza la información de este escenario según la descomposición antes mencionada:

		\begin{itemize}
			\item Fuente: Sistema externo
			\item Estímulo: Mensaje no anticipado
			\item Entorno: Operación normal
			\item Artefacto: Proceso interno
			\item Respuesta: Informar al operador y seguir operando
			\item Medición de la respuesta: sin caídas (downtime)
		\end{itemize}

		\indent De todos estos atributos, el \textbf{Estímulo}, el \textbf{Artefacto}, el \textbf{Entorno} y la
		\textbf{Cuantificación de la Respuesta} son particularmente relevantes a los fines de establecer información útil para
		el mecanismo de auto reparación. A lo largo de las próximas subsecciones mostraremos cómo Arco Iris hace uso de esta
		información para modificar, optimizar y refinar la auto reparación realizada por Rainbow.


		\subsubsection{El Estímulo en la Auto Reparación}

			El \textbf{Estímulo} de un escenario normalmente se asocia a un evento desencadenado en el sistema por la acción del
			alguno de sus usuarios. Dicho evento es el punto de entrada del escenario, el disparador (interno o externo) que
			inicia la interacción con el sistema, y más particularmente, con el artefacto del escenario en cuestión. Por ejemplo,
			supongamos que en un sistema de administración de cuentas bancarias un cliente intenta hacer una transferencia, en
			este caso la fuente del estímulo sería el cliente y el estímulo en sí mismo sería realizar transferencia.

			Saber cual es el estímulo de cada escenario permite optimizar la auto reparación, ya que habiendo ocurrido determinado
			estímulo, Arco Iris podrá detectar cuales son los potenciales escenarios que pueden verse afectados y trabajará
			verificando dicho subconjunto, evitando así chequeos innecesarios.

			Cabe destacar que también se ofrece la posibilidad de que el estímulo sea ``cualquiera'', es decir, que el escenario
			aplique siempre, independientemente del estímulo que haya impactado al sistema. Esto puede ser útil para casos más
			genéricos, por ejemplo, si se requiere que el tiempo de respuesta experimentado por el usuario nunca sobrepase
			determinado umbral sin importar la funcionalidad del sistema que el usuario esté utilizando. De no configurar ningún
			estímulo en ningún escenario, Arco Iris verificará que se satisfagan todos los escenarios en cada iteración. Esta es
			la manera en que trabaja Rainbow.

			Entonces, a diferencia de Rainbow, Arco Iris permite refinar el conjunto de escenarios que pudieron verse afectados por
			medio del estímulo que ocasionó el problema, reduciendo así la cantidad de escenarios a verificar y sobre todo la
			cantidad de estrategias a evaluar para intentar resolverlo, mientras que en Rainbow (en Arco Iris se mantiene esta
			posibilidad), la única manera de limitar el uso de las estrategias es agregar restricciones en la misma estrategia,
			siendo esto algo bastante técnico y quedando fuera del alcance de la mayor parte de los \emph{stakeholders} del
			sistema, por ejemplo, para que una estrategia que soluciona problemas de performance no sea tenida en cuenta al
			reparar un escenario relacionado a un atributo de calidad distinto, como por ejemplo el costo, debe agregarse una
			precondición como la siguiente en la estrategia:

			\begin{Verbatim}[gobble=4]
				strategy SimpleReduceResponseTime
				  [ styleApplies && responseTimeConstraintViolation ] {
				  ...
				}
			\end{Verbatim}

			Donde \emph{responseTimeConstraintViolation} es un predicado que permite determinar si existe algún cliente cuyo tiempo
			de respuesta haya sobrepasado el máximo tiempo de respuesta permitido:

			\begin{Verbatim}[gobble=4]
				define boolean responseTimeConstraintViolation =
					exists c : T.ClientT in M.components | c.experRespTime > M.MAX_RESPTIME;
			\end{Verbatim}

			Es importante remarcar que, en caso de que el problema que se está intentando reparar no esté relacionado con la
			performance, Rainbow deberá de todos modos chequear el tiempo de respuesta de todos los clientes, mientras que en
			Arco Iris existe la posibilidad de evitarlo al configurar correctamente los estímulos de cada escenario.

			Adentrándonos ya en la implementación, tengamos en cuenta que el estímulo era un concepto inexistente en Rainbow, por lo
			cual en Arco Iris debimos modificar algunos de los componentes existentes para poder tomar conocimiento de qué estímulo
			desencadenaba una determinada acción, así como también para interpretar luego dicha información.
			Dado a que Rainbow permite trabajar en modo simulación, fue necesario implementar dos soluciones para poder utilizar el
			concepto de estímulo en ambos escenarios.

			Al trabajar en el modo de simulación, dado que no participan ni los \emph{probes} ni los \emph{gauges}, fue necesario
			implementar un mecanismo ad hoc, que consistió en barrer todos los escenarios al iniciar Arco Iris, recogiendo en un
			mapa la información de qué estímulos eran los posibles responsables de las modificaciones causadas sobre cada una de las
			propiedades de los artefactos configurados en los escenarios. A continuación mostramos el concepto de dicha
			implementación en pseudocódigo:

			\begin{Verbatim}[gobble=4]
				por cada escenario habilitado
				  por cada constraint del escenario
				    por cada propiedad involucrada en el constraint
				      escenariosPorEstimulo.agregar(escenario.estimulo, escenario)
				      estimulosPorPropiedades.agregar(propiedad, escenario.estimulo)
			\end{Verbatim}

			El modo simulación funciona notificando los cambios en las propiedades de interés, las cuales son
			determinadas a la hora de implementar la simulación. Entonces, al contar los estímulos relacionados con cada
			propiedad y los escenarios por cada estímulo, podemos acotar la cantidad de escenarios a verificar en cada
			ejecución de la auto reparación.

			En modo real, o sea sin simulación, para notificar el estímulo desencadente fue necesario extender los
			\emph{probes}, que son los componentes encargados de testear una determinada funcionalidad del sistema,
			siendo el responsable también de medir la respuesta y de reportar dicha información a un bus, del cual
			luego la consumirán los \emph{gauges}, quienes interpretarán los datos transformándolos en cambios en el
			modelo de la arquitectura. Obviamente también fue necesario extender la funcionalidad de los \emph{gauges}
			para poder intrepretar la información de estímulo agregada en cada uno de los \emph{probes}. En ambos
			casos, y gracias al mecanismo empleado por Rainbow, no fue necesario modificar las interfaces ni de los
			\emph{probes} ni de los \emph{gauges}, ya que éstos se comunican mediante cadenas de texto, justamente
			para ofrecer una amplia libertad a la hora de implementarlos ya que pueden existir maneras muy diversas de
			testear y tomar métricas de las distintas funcionalidades de los sistemas. Luego, una vez obtenido el estímulo
			correspondiente, no resta más que recurrir al mapa de escenarios por estímulos (utilizado también en el modo
			simulación) para acotar la cantidad de escenarios a comprobar.

			\todo{agregar comparación de info reportada por los Probes con estimulos y sin estimulos}

		\subsubsection{El Artefacto en la Auto Reparación}

			El \textbf{Artefacto} se refiere al componente, subsistema o parte del sistema afectada por el escenario. Dado que
			Rainbow trabaja con el modelo de la arquitectura del sistema descripto en el lenguaje Acme, contaremos con la
			especificación de las propiedades de los componentes y los conectores del sistema, entonces en el escenario de Arco Iris
			podremos contar con una vinculación directa con los componentes afectados. Al seleccionar un artefacto, el usuario de
			Arco Iris no estará más que eligiendo un componente o conector de la arquitectura del sistema, esto lo aprovecharemos
			para acotar las propiedades sobre las cuales podrá predicar la \textbf{Cuantificación de la Respuesta}.

			Para ejemplificar el concepto de artefacto utilizaremos la arquitectura presentada en Znn, recordemos que es una
			arquitectura cliente-servidor, de la cual en este caso tomaremos la especificación del componente cliente definido como
			\emph{ClientT}, a saber:

			\begin{Verbatim}[gobble=4]
				Component Type ClientT extends ArchElementT with {

				  Property deploymentLocation : string <<  default : string = "localhost"; >> ;

				  Property experRespTime : float <<  default : float = 100.0; >> ;

				  Property reqRate : float <<  default : float = 0.0; >> ;
				}
			\end{Verbatim}

			Y supongamos que se define el siguiente escenario:

			\label{escenarioPerformance}
			\begin{quote}
				Znn news debe servir el contenido de las noticias a los clientes en un tiempo de respuesta menor a 3 segundos en un
				entorno de operación normal.
			\end{quote}

			Claramente en este ejemplo \emph{ClientT} será el artefacto sobre el cual predicará la verificación de validez de
			este escenario, más adelante veremos cómo se configurará dicha restricción.

			En la sección \ref{sec:scenariosUI} se explicará en más detalle cómo se podrá emplear esta información para mejorar
			la experiencia de los \emph{stakeholders} a la hora de especificar escenarios mediante la herramienta visual
			presentada junto a Arco Iris: \textbf{scenarios UI}


		\subsubsection{El Entorno en la Auto Reparación}

			Dentro de la definición de escenario, el \textbf{Entorno} se refiere al estado en el que el sistema se encuentra cuando
			se recibe el estímulo que desencadena el escenario, por ejemplo, al recibir una solicitud de creación de una cuenta
			bancaria el sistema puede encontrarse en ``operatoria normal'' o en ``alta carga''. El entorno condiciona la validez del
			escenario en cuestión a que el sistema se encuentre en un determinado estado. Una respuesta aceptable o fácil de cumplir
			bajo un entorno puede ser inaceptable o muy costosa de cumplir en un entorno diferente. En el escenario planteado
			anteriormente en la sección \ref{escenarioPerformance}, si el sistema se encuentra en un entorno de ``alta carga'' el
			escenario automáticamente se cumple, ya que para considerar dicho escenario el sistema debería encontrarse en un entorno
			de ``operación normal''.
			Por otro lado, el entorno del escenario permite a Arco Iris optimizar la búsqueda de escenarios que no se satisfagan ya
			que se ignorarán los escenarios cuyo entorno posea condiciones que no se cumplan en el estado del sistema en el instante
			en que se recibe el estímulo. Es importante mencionar que si bien según la definición de ATAM, cada escenario posee			un único entorno, en Arco Iris hemos decidido, por razones de flexibilidad, permitir configurar varios escenarios,			siendo obligatorio indicar al menos uno.
			Arco Iris también provee la posibilidad de especificar que un determinado escenario aplica bajo cualquier entorno,
			esto sería equivalente a que el entorno del escenario tenga como única condición subyacente \verb@true@. Esto puede
			ser útil para simplificar la configuración del escenario, pero se debe tener en cuenta que esto acota la posibilidad
			de obtener un rendimiento más óptimo del sistema, ya que al configurar un entorno se puede ser más específico sobre
			las prioridades relativas de los \emph{concerns} según el escenario y el estado del sistema.

			Supongamos que el sistema se encuentra bajo una carga excesiva, y los \emph{stakeholders} consideran que bajo tales
			circunstancias lo más prioritario es optimizar la \emph{performance} de un servicio en particular, en tal caso, de no
			especificar el entorno no podremos darle mayor peso a la \emph{performance} por sobre otros \emph{concerns}, quedando
			únicamente la opción de aumentar la prioridad del escenario tergiverzando así dicha información, ya que en realidad lo
			óptimo era darle más peso a la \emph{performance} en el entorno de ``Alta Carga''.
			En definitiva, al establecer que el escenario aplica para cualquier entorno, Arco Iris estará interpretando que el
			entorno carece de importancia, dejando así de lado los pesos de los \emph{concerns} y distribuyendo equitativamente			su importancia relativa, lo cual es equivalente a que no exista el concepto de \emph{concern}.
			La estructura del entorno estará formada de la siguiente manera:
			\begin{itemize}
				\item Un conjunto de condiciones, y
				\item Un mapa $<$Concern, Peso$>$
			\end{itemize}

			Estas condiciones fueron implementadas en base a un concepto de restricción presente en Rainbow, que permite definir
			precondiciones de aplicabilidad de las estrategias. En Arco Iris, en cambio, utilizaremos el mismo concepto con dos
			fines, ninguno de los cuales se corresponde exactamente con la concepción original. Por una lado lo utilizaremos para
			conocer el entorno en que se encuentra el sistema, y por el otro será utilizado en la cuantificación de la respuesta
			(ver \ref{sec:responseMeasure}) para decidir si el escenario se satisface o no. En dicha sección se explicará la
			diferencia vital del concepto de restricción utilizado en Rainbow con el de Arco Iris.

			El concepto de condición (o restricción) presentado en Arco Iris permite agregar nuevos tipos de restricciones
			simplemente implementando la interface \verb@Constraint@ \footnote{Dicha implementación deberá ser agregada al
			enumerado ConstraintType en Scenarios UI para que la UI reconozca el nuevo tipo}.
			En cuanto al mapa presente en la estructura del entorno, deberá contener todos los \emph{concerns} definidos para el
			sistema, y obviamente la suma de los pesos debe ser igual a uno, ya que la utilidad del mapa es determinar la			preponderencia relativa entre los \emph{concerns}. Se detallará cómo se utilizan estos pesos para calcular el valor			de un escenaio en la sección \ref{sec:scenarioWeight}.
			A la hora de decidir en que entorno se encuentra el sistema, no sería suficiente chequear las condiciones definidas para
			el entorno tomando los datos actuales del sistema, ya que deberíamos eliminar el ruido provocados por los
			\emph{outlier}, pues para que el sistema se encuentre en un determinado estado es lógico esperar que dicho estado se
			mantenga por un tiempo mínimo. Entonces, para definir el valor más real para las propiedades del sistema tomamos los
			valores nuevos con un determinado peso, configurable, que nos permite ir adecuando los valores del sistema de manera
			paulatina evitando el impacto de los valores que puedan darse por alguna ocasión excepcional, como por ejemplo algún
			cliente que experimenta un tiempo de respuesta excesivo por algún problema es su conexión o en estación de trabajo.
			Para mitigar estos casos, utilizaremos el mismo mecanismo utilizado por Rainbow explicado ya en la sección
			\ref{sec:exponentialAverage}.

			Un valor recomendable para el factor de suavizado utilizado tanto en las pruebas de Rainbow como en las de Arco Iris
			es 0.3. Si se configura un valor muy pequeño Arco Iris tardará en adaptarse a los cambios en el entorno del sistema,
			aunque ésto podría ser útil sistemas no muy dinámicos o en los cuales la adaptación pueda resultar muy costosa. En el
			caso contrario, o sea, al configurar un alpha muy elevado, es probable que el sistema se vea afectado por unos pocos
			valores que estén muy por fuera del rango considerado como normal, aunque de no ser costoso lanzar una adaptación o
			volverla atrás, puede llegar a lograrse un rendimiento muy óptimo y dinámico del sistema.
		\subsubsection{La Cuantificación de la Respuesta en la Auto Reparación}
			\label{sec:responseMeasure}

			La \textbf{Cuantificación de la Respuesta} es quizás la propiedad más importante de un escenario: de ella surgen las
			restricciones que deben ser evaluadas para que, en caso de no cumplirse, se lance la auto reparación. De hecho, para
			que un escenario se considere bien formado debe quedar claro cual es la métrica o manifestación observable de su
			respuesta que se debe satisfacer. Latencia y \emph{throughput} son ejemplos de las manifestaciones sobre las cuales
			puede predicar la cuantificación de la respuesta. En pocas palabras, la cuantificación será la métrica según la cual
			se decida la aceptación de una respuesta del sistema ante un determinado estímulo.

			Para graficar la importancia de contar con una cuantificación de la respuesta precisa, supongamos que contamos con la
			siguiente definición:

			\begin{quote}
				``Modificar el sistema para incorporar un nuevo generador de eventos discretos''
			\end{quote}

			Esta premisa no es suficiente para medir el éxito de la incorporación de la nueva funcionalidad, ya que con
			suficiente tiempo y dinero, cualquier modificación es posible. En este escenario se necesitaría una métrica del
			siguiente tipo por ejemplo: ``Utilizando 160 horas hombre''. Esto forzaría al arquitecto a asegurar que el sistema
			sea modificable basándose en un criterio bien particular y con una métrica aplicable.

			Sumergiéndonos ya en la implementación, cabe mencionar que Arco Iris reutiliza las restricciones genéricas brindadas
			por Rainbow, poniéndolas en el contexto de un Escenario de Atributo de Calidad, proveyendo así mayor visibilidad a los
			\emph{stakeholders} sobre estas restricciones, anteriormente sólo conocidas por los arquitectos o encargados de
			configurar Rainbow, ya que dichas restricciones en Rainbow terminaban siendo implementadas en el modelo
			de la arquitectura descripto en el lenguaje Acme, perdiendo toda correlación con su estímulo desencadenador. Veamos			un ejemplo extraído de Znn de cómo se implementan dichas restricciones al utilizar Rainbow:
			\begin{Verbatim}[gobble=4]
                Component Type ClientT {
                    Property experRespTime : float <<  default : float = 100.0; >> ;
                    rule primaryConstraint = invariant self.experRespTime <= MAX_RESPTIME;
                }
			\end{Verbatim}

			Es importante recordar que en Rainbow, una vez que se detectó que la auto reparación debe ser ejecutada, se volverán
			a ejecutar todas las restricciones dictadas en la precondición de las estrategias para saber si las mismas aplican
			en el estado actual del sistema, volvemos a tomar un ejemplo de Znn:

			\begin{Verbatim}[gobble=4]
                define boolean cViolation =
                    exists c : T.ClientT in M.components | c.experRespTime > M.MAX_RESPTIME;

                strategy BruteReduceResponseTime
                [ cViolation ] {
  					...
  					do some tactic
  					...
                }
			\end{Verbatim}

			En Arco Iris no será necesario contar con éstas últimas restricciones ya que el conocimiento de cuales estrategias
			son capaces de reparar una determinada condición ya están plasmado en cada escenario. En definitiva, al utilizar Arco
			Iris el usuario no tendrá más que configurar la Cuantificación de la respuesta de cada escenario, tarea que se ve
			sumamente facilitada al utilizar UI Scenarios (ver sección~\ref{sec:scenariosUI} en la
			página~\pageref{sec:scenariosUI}).

			Otra diferencia vital ante el uso de las mencionados restricciones entre la visión de Rainbow y de Arco Iris consiste
			en el momento en que se aplican. Rainbow posee un componente llamado \emph{``Architecture Evaluator''}, cuya
			responsabilidad consiste en chequear la arquitectura del modelo de a intervalos y de manera asincrónica, siempre y
			cuando este haya sido modificado y la auto reparación no se encuentre ya en ejecución, esto implica verificar
			absolutamente todas las restricciones. Mientras que Arco Iris, al descubrir un cambio en el modelo de la
			arquitectura, la acción que tomará consistirá en verificar los escenarios, pero no cualquier escenario, solamente los
			que coincidan en su estímulo con el estímulo que desencadenó el cambio en el modelo de la arquitectura, optimizando
			así de manera determinante la cantidad de restricciones a verificar, lo que hace mucho más escalable la auto reparación.
			Dado al cambio en el manejo de restricciones, en Arco Iris se implementó el concepto de Constraint como una
			interface, dando así la posibilidad de extender el \emph{framework} con el tipo de Constraint que el usuario
			considere necesario. La interface planteada presentada es la siguiente:

			\begin{Verbatim}[gobble=4]
                public interface Constraint {

                    boolean holds(Number value);

                    String getFullyQualifiedPropertyName();
                }
			\end{Verbatim}

			Donde el método \emph{holds} será el encargado de determinar si la Constraint se cumple o no, recibiendo como
			parámetro el valor de la propiedad a evaluar, mientras que el método \emph{getFullyQualifiedPropertyName} retornará
			el nombre completo cualificado de la propiedad sobre la que predica, incluyendo el sistema y el componente al que
			pertenece, un ejemplo tomado de Znn sería: \emph{ZNewsSys.ClientT.experRespTime}. 
			
			Para el presente trabajo se utilizó	una única implementación, que consiste en una relación binaria de orden (igual,
			mayor, mayor o igual, menor, menor o igual) entre una propiedad de la arquitectura (e.g. \verb@server1.responseTime@)
			y un valor fijo (puede ser entero o flotante) preestablecido al configurar la cuantificación de la respuesta del
			escenario. Esta restricción será configurada mediante un cuantificador, el cual provee dos opciones: sumatoria y
			promedio, los que especifican si la condición debe cumplirse para la suma de todas las instancias en \emph{runtime}
			de dicha propiedad o si la condición debe darse ``en promedio'' para todas las instancias; respectivamente.
			La implementación mencionada recibe el nombre de \emph{NumericBinaryRelationalConstraint} y puede verse su código
			en la sección \ref{sec:numericBinaryRelationalConstraintCode}.
			

	\subsection{Prioridades entre Escenarios}

		Rainbow también maneja el concepto de escenario, aunque no es equivalente al manejado por Arco Iris, el cual toma el
		concepto de Escenario de QAW de la definición de ATAM. Desde la perspectiva de Rainbow, el escenario es algo configurable pero
		estático, es decir, no ofrece la posibilidad de adaptarse a los cambios del entorno, por lo que el arquitecto deberá
		configurar el escenario\footnote{Recordar que aquí``escenario'' no se refiere a los Escenarios de QAW utilizados por
		Arco Iris, tan sólo se reutiliza con la finalidad de explicar el funcionamiento de Rainbow.} previo a iniciar Rainbow,
		intentando vislumbrar cuales serán las condiciones en las que la aplicación deberá responder, para lo cual configurará
		la importancia de cada uno de los concerns del sistema. A continuación se muestra cómo se realiza dicha configuración
		en Rainbow: \begin{Verbatim}[gobble=4] 
				weights: 
					scenario 1:
						uR: 0.35
						uF: 0.4
						uC: 0.25
					scenario 2:
						uR: 0.5
						uF: 0.3
						uC: 0.2
					scenario 2b:
						uR: 0.5
						uF: 0.2
						uC: 0.3
		\end{Verbatim}
		
		Cada una de las líneas representa el valor que se le asigna a cada \emph{concern}, en donde uR representa al Tiempo de
		Respuesta, uF a la Fidelidad de la información y uC al Costo. Notar que la sumatoria de los pesos de los distintos
		concern debe ser igual a 1 dentro de cada escenario, al igual que sucede en el \emph{Entorno} al configurar Arco Iris.
		
		Esto es lo que veremos, entre otras cosas, en el archivo de configuración \emph{utilities.yml} utilizado por Rainbow.
		Aquí, como vemos, existe más de una configuracion del escenario, luego se deberá seleccionar una de estas opciones en
		el archivo de configuración \emph{rainbow.properties}. Estos valores serán luego utilizados por Rainbow a la hora de
		seleccionar una estrategia, veremos en detalle su utilización en la sección \ref{sec:strategySelection}.
		
		Presentado ya el concepto de escenario utilizado por Rainbow, pasaremos estas ideas a su contrapartida en Arco Iris.
		Como hemos visto anteriormente, en Arco Iris existen los conceptos de \emph{Entorno} y \emph{Escenario}, los cuales
		respetan al pie de la letra los conceptos introducidos por ATAM (ver sección \ref{sec:atam}). El concepto de escenario
		utilizado por Rainbow se asemeja mucho más al concepto de \emph{Entorno} de ATAM que al de \emph{Escenario}. La
		diferencia fundamental radica en que en Arco Iris no se requiere que el usuario configure en qué entorno se encuentra
		el sistema, sino que el usuario debe detallar cuales son las condiciones que definen al entorno, y, en caso de
		cumplirse dichas condiciones, cuales serán los pesos que tomarán cada uno de los \emph{concerns} del sistema.
		
		Dicho esto podemos introducirnos de lleno en la relación de prioriades entre escenarios, sin confundir los
		conceptos manejados en ambos frameworks.

		En resumen, Rainbow permite priorizar básicamente por \emph{concerns}, y de manera estática, mientras que Arco Iris
		permite priorizar escenarios asignandoles prioridades relativas, de modo tal que al momento de escoger una estrategia
		de autoreparación la estrategia seleccionada no comprometa a alguna otra funcionalidad de la aplicación considerada
		más importante según la visión de los \emph{stakeholders}.

		Para lograr esto, cada escenario tendrá asignada una prioridad, la cual será un entero mayor a cero, uno será la
		prioridad máxima asignable, mientras que su valor máximo no estará acotado, permitiendo  así asignar valores muy grandes para
		escenarios de muy baja prioridad. Si bien se ofrece esta posibilidad al usuario, la misma debe manejarse con mucho
		cuidado, ya que es probable que, al configurar escenarios con prioridades tan grandes, éstos no tengan prácticamente
		ningún peso a la hora de seleccionar la estrategia de autoreparación a aplicar, por lo cual dichos escenarios nunca
		serán reparados, careciendo de sentido directamente su existencia.

		La prioridad del escenario es una propiedad fundamental para el correcto funcionamiento de Arco Iris, veremos su
		importancia al detallar cómo Arco Iris selecciona la estrategia que aplicará para reparar el sistema en la sección
		\ref{sec:strategySelection}. Por esta razón será muy importante realizar una configuración a conciencia de cuales
		serán los escenarios prioritarios: éstos deberán reflejar la importancia fundamental de los servicios ofrecidos por el
		sistema  según las expectativas de los usuarios finales. Se recomienda realizar la asignación de la prioridad de cada
		escenario como un paso más del Quality Attribute Workshop (QAW), para más detalle ver la sección \ref{sec:QAS}.

	\subsection{Estrategias y su Relación con los Escenarios}

		Antes de sumergirnos en cómo Arco iris utiliza las estrategias implementadas para reparar escenarios, recordemos
		brevemente su utilización en Rainbow.
		
		Las estrategias en Rainbow tienen un conjunto de precondiciones que nos indican si dicha estrategia puede ser
		utilizada para reparar el sistema en un determinado momento. Esto implica que, en cuanto Rainbow detecta un problema
		en el sistema, deba recorrer todas las estrategias existentes para ver si son aplicables para las condiciones
		actuales, o sea que Rainbow no tiene manera de determinar a priori la utilidad de una estrategia en un momento dado.
		Por otro lado, la solución está atada a la detección del problema, entonces, al no poder modularizar en detección del
		problema y solución, se deben repetir las precondiciones por cada solución (estrategia) implementada.
		
		En Arco Iris se propone desacoplar la detección del problema de la solución, y para lograr esto utilizaremos los
		escenarios. Allí se definirán las condiciones de detección del problema, y se referenciarán las posibles estrategias
		de reparación a ser consideradas para su ejecución, en el caso de que el escenario en cuestión se vea comprometido,
		quedando así las estrategias exentas de conocer cuales son las circunstancias en las que su ejecución tiene sentido.
		Esto permite al arquitecto tener un mayor control sobre las estrategias a ejecutar en determinadas condiciones, ya que
		al situarse en un escenario concreto, él sabrá cuales serán las soluciones más adecuadas basándose en el entorno del
		sistema y en la prioridad del escenario actual. Obviamente, Arco Iris también ofrece la posibilidad de utilizar el
		comportamiento brindado por Rainbow, esto se logra simplemente indicando la opción que representa a todas las
		estrategias existentes (para más detalle ver \ref{sec:strategySelectionUI}) cuando se configura el escenario.
		Una ventaja derivada del agregado del concepto de \emph{Escenario} es que ahora los problemas y sus posibles
		soluciones (i.e. estrategias de reparación), pueden ser visibles a los usuarios y stakeholders de la aplicación. Como
		ya sucedía en Rainbow, las estrategias poseen la información necesaria para permitir simular su aplicación y estimar
		en que condiciones quedaría el sistema luego de haber sido aplicadas (esta información será utilizada para la
		estimación de la nueva ``utilidad del sistema\footnote{Para más detalle acerca del concepto Utilidad del Sistema ver
		sección \ref{sec:systemUtility}}'').
		
		En Arco Iris, para poder escribir estrategias que involucren varias tácticas, el usuario contará con un mecanismo que
		le permitirá verificar si los escenarios de un determinado \emph{concern} y que han sido marcados para reparar, aún
		siguen sin cumplirse. En base a esta información la estrategia podrá decidir cómo continuar su ejecución. A
		continuación se muestra un ejemplo de su utilización:
		
		\begin{Verbatim}[gobble=4] 
				define boolean RESP_TIME_STILL_BROKEN = 
						AdaptationManagerWithScenarios.isConcernStillBroken("RESPONSE_TIME");
				
				/*
				 * This Strategy will drop fidelity once, observe, then drop again if necessary.
				 */
				strategy BruteReduceResponseTime
				[ styleApplies ] {
				  t0: (true) -> lowerFidelity(2, 100) @[5000 /*ms*/] {
				    t1: (!RESP_TIME_STILL_BROKEN) -> done;
				    t2: (RESP_TIME_STILL_BROKEN) -> lowerFidelity(2, 100) @[8000 /*ms*/] {
				      t2a: (!RESP_TIME_STILL_BROKEN) -> done;
				      t2b: (default) -> TNULL;  // in this case, we have no more steps to take
				    }
				  }
				}	
			\end{Verbatim}

		Cómo se puede observar en el código, para que esto funcione es necesario tener definida la función
		\emph{isConcernStillBroken} en la clase \emph{AdaptationManagerWithScenarios}, a continuación vemos la implementación,
		notar que el usuario solamente deberá indicar cual es el \emph{concern} de su interés:

		\begin{Verbatim}[gobble=4] 
				public static boolean isConcernStillBroken(String concernString) {
					Concern concern = Concern.valueOf(concernString);
					doLog(Level.INFO, "Is Concern " + concern + " Still Broken?");
		
					boolean result = false;
					for (SelfHealingScenario scenario : currentBrokenScenarios) {
						if (scenario.getConcern().equals(concern) &&
								scenarioBrokenDetector4CurrentSystemState.isBroken(scenario)) {
							result = true;
							break;
						}
					}
					doLog(Level.INFO, "Concern " + concern + (result == true ? 
							" Still Broken!" : " Not Broken Anymore!!!"));
					return result;
				}		
		\end{Verbatim}

	\subsection{Detección: cuando activar el mecanismo de auto reparación}

		Con el nuevo enfoque presentado en este trabajo, dónde el \emph{Escenario} es el concepto central, es necesario
		establecer cambios en la lógica aplicada por el \emph{framework} a la hora de decidir en qué momento es necesario
		intentar auto reparar el sistema (i.e. evaluar sus restricciones o invariantes).

		En Rainbow, las restricciones del sistema se encuentran embebidas en la descripción arquitectónica de sus componentes,
		más precisamente en el modelo de la arquitectura, el cual se describe utilizando el lenguaje de descripción de
		arquitectura ACME (\ref{sec:acme}). Por ejemplo, para determinar que el tiempo de respuesta no debe exceder un
		umbral determinado es necesario definir un invariante en el componente que posee dicha propiedad, como se puede
		observar en el siguiente ejemplo tomado de la arquitectura de Znn:
		
		\begin{Verbatim}[gobble=4] 
				Component Type ClientT extends ArchElementT with {
				
					Property experRespTime : float <<  default : float = 100.0; >> ;
				
					rule primaryConstraint = invariant self.experRespTime <= MAX_RESPTIME;
				}
				
				Property MAX_RESPTIME : float = 1000.0;
		\end{Verbatim}

		En Arco Iris ya no será necesario definir estas \emph{constraints} en la arquitectura, desacoplando así la arquitectura
		del sistema de la definición de condiciones a evaluar para lanzar la auto reparación. Ahora las restricciones estarán
		presentes en la \emph{Cuantificación de la Respuesta}(\ref{sec:responseMeasure}) de cada escenario. Al cambiar el modo
		de difinir las constraints, se logra dar mayor visibilidad a los \emph{stakeholders} del sistema. Arco Iris también
		añade la posibilidad de definir las restricciones de manera visual utilizando Scenarios UI (\ref{sec:scenariosUI}), para
		más detalle ver la sección \ref{sec:scenariosUI_constraints}. Todo esto hace que los \emph{stakeholders} puedan  
		acceder de manera sencilla a las restricciones a las cuales debe acatarse el sistema, pudiendo editarlas sin la  
		necesidad de poseer conocientos sobre las tecnologías utilizadas por el sistema o por el \emph{framework} de auto  
		reparación.		
		Para determinar si el sistema necesita auto repararse, Rainbow utilizará una funcionalidad ofrecida por ACME, que
		permite evaluar las restricciones descriptas en el modelado de la arquitectura, para esto ACME provee los \emph{Types
		Checkers}. A continuación podemos observar cómo Rainbow se sirve de esta utilidad para saber si debe lanzar la auto
		reparación:
		
		\begin{Verbatim}[gobble=4]
				public void evaluateConstraints () {
					IAcmeTypeChecker typechecker = m_acmeEnv.getTypeChecker();
					if (typechecker instanceof SynchronousTypeChecker) {
						SynchronousTypeChecker synchChecker = (SynchronousTypeChecker) typechecker;
						synchChecker.typecheckAllModelsNow();
						m_constraintViolated = !synchChecker.typechecks(m_acmeSys);
						if (m_constraintViolated) {
							Set<?> errors = m_acmeEnv.getAllRegisteredErrors();
							Oracle.instance().writeEvaluatorPanel(m_logger, errors.toString());
						}
					}
				}
		\end{Verbatim}

		Recordemos que en Arco Iris hemos desacoplado el modelado de la arquitectura de las restricciones que deben
		satisfacerse, por lo cual no podremos utilizar la funcionalidad provista por ACME. Para suplir esto, y también para
		poder permitir incluir toda la información necesaria en los escenarios y que la misma pueda ser visualizada y editada
		por todos los \emph{stakeholders} involucrados, hemos desarrollado nuestras propias implementación de las
		restricciones, las cuales permiten expresar las mismas \emph{constraints} definidas en ACME, y en caso de ser
		necesario agregar un nuevo tipo de restricción permite fácilmente agregar una nueva implementación. Estas
		\emph{constraints} serán vitales a la hora de activar el mecanismo de auto reparación.
		
		Al iniciar, Arco Iris leerá todos los escenarios definidos, y armará un mapa que le permitirá optimizar las
		verificaciones recurrentes de los escenarios ante la llegada de cada estímulo. El mapa almacena todos los escenarios
		correspondientes a cada estímulo, así, ante la invocación de un estímulo en el sistema, Arco Iris solo deberá
		verificar que se cumplan los escenarios relacionados con dicho estímulo, acotando así de manera sustancial la cantidad
		de chequeos a realizar. Recordar que en Rainbow, ante cualquier modificación en el estado de la arquitectura, es
		necesario verificar todas las restricciones definidas para la auto reparación.
		
		\todo{Ampliar gigantescamente la siguiente explicación, con gráficos, mas detalle, etc. y dejando en claro como
		funcionaba en Rainbow y que agregamos nosotros}
	
		\todo{continuar desde aca!!!}


		En el caso de Arco Iris, ante la invocación de un estímulo en el sistema en ejecución, el \textbf{Monitor} del sistema
		informa de esta situación al \textbf{Intérprete}, que a su vez actualiza las propiedades del modelo de la arquitectura (recordemos: en
		ACME) e invoca finalmente al \textbf{Evaluador de Restricciones} para que busque aquellos escenarios que posean al
		estímulo ejecutado y que estén definidos para el \textbf{Entorno} de ejecución actual y que las restricciones
		asociadas a sus \textbf{Cuantificaciones de Respuesta} no se cumplan. Aquellos escenarios que cumplan dichas
		condiciones serán aquellos a los cuales el Manejador de Reparaciones intentará reparar.

	\subsection{Selección de estrategia a aplicar}
	\label{sec:strategySelection}

		\todo{Esta subsección probablemente necesite ser reescrita en su totalidad, explicando en una subsubsection el
		concepto de utilidad del sistema, explicar primero como se calcula el peso de un escenario}

		\subsubsection{Peso de un escenario}
			\label{sec:scenarioWeight}

		\subsubsection{Utilidad del Sistema}
		\label{sec:systemUtility}

			\todo{Explicar Utilidad del sistema}

		El módulo denominado como ``Adaptation Manager'' es uno de los módulos que han sufrido más modificaciones como parte
		de esta extensión a Rainbow. El mismo ha sido extendido \todo{¿cómo?} para que utilice el conocimiento plasmado en los
		escenarios para que determine la mejor (en un sentido heurístico) estrategia de reparación a aplicar, teniendo en
		cuenta:
		\begin{itemize}
			\item el entorno de ejecución en que se encuentra la aplicación,
			\item el atributo de calidad asociado al escenario, \todo{Hablamos por todos lados de QA pero en realidad es
			Concern!} y
			\item las prioridades relativas de los escenarios.
		\end{itemize}
		El objetivo final es el de intentar reparar el inconveniente hallado pero siempre restricto a evitar perjudicar
		algún otro escenario de mayor prioridad \todo{Esto es un efecto colateral de la utility function pero...podemos
		garantizar que esto es asi siempre? Creo que esto necesita ser reescrito} y mediante el uso de heurísticas, poder
		aproximar la mejor estrategia de reparación a llevar a cabo de modo que la \emph{utilidad del sistema} se maximize.

	
		\todo{REVISAR}Cabe aclarar que la ``utilidad del sistema'' es una función que se calcula a partir del cumplimiento o
		no de los escenarios requeridos por los stakeholders, teniendo en cuenta sus prioridades relativas y la prioridad de
		la estrategia simulada.

	\subsection{Modelo de Arco Iris}

		\todo{La idea de esta sección es la de mostrar el modelo de la extensión de una manera consolidada. No tiene sentido
		ponerlo al principio de la sección cuando muchos de los conceptos que se ven todavía no fueron explicados.}

		\begin{center}
			\includegraphics[width=1.00\textwidth]{images/Arco_Iris_Model.png}
		\end{center}

		\todo{Explicar un poco sobre el diagrama anterior.}