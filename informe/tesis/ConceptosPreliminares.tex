\section{Conceptos Preliminares}

	\subsection{Sistemas Autónomos, Auto Adaptación, Auto Reparación\ldots}

 		A medida que va pasando el tiempo, los sistemas de software se vuelven cada vez más complejos y más exigentes en
		cuanto a disponibilidad se trata. Hoy en día los mismos operan en ambientes dinámicos, con requerimientos del
		usuario altamente cambiantes y con la necesidad de operar prácticamente sin interrupción, resultando esto en un
		mayor crecimiento en la administración operativa del software, lo cual representa un costo importante para que el
		sistema pueda funcionar. Para reducir este costo, se puede plantear que los sistemas se adapten de manera dinámica
		para poder utilizar los recursos existentes, a fin de poder atender los cambiantes requerimientos del usuario y los
		errores en el sistema. De forma genérica, a los sistemas de software que cumplen con estas características, se los
		denomina \textbf{Sistemas Autónomos}.
		
		Hilando más fino en la caracterización de sistemas autónomos, encontramos términos en inglés como \textbf{Self
		Configuring} o \textbf{Self Adapting} para referirse a sistemas autónomos que tienen la capacidad de auto configurarse
		(o auto adaptarse) a condiciones cambiantes \textbf{en un entorno normal de ejecución del sistema}.
		
		Por otro lado, cuando la adaptación dinámica del sistema responde a \textbf{errores o situaciones excepcionales} del
		mismo, el término más utilizado actualmente es \emph{self healing} o, en castellano, \textbf{auto reparación}.

		Si bien ya existen mecanismos para mitigar los mencionados problemas, ellos normalmente están intrínsecamente ligados
		al lenguaje de programación utilizado para construír la aplicación, tales como tratamiento de excepciones, protocolos de
		tolerancia a fallos, etc. Además, estos mecanismos generalmente dependen del código de la aplicación que se intenta
		adaptar y consecuentemente, no son fácilmente reutilizables entre distintos sistemas. En resúmen: hoy en día, la
		adaptación de sistemas de software es costosa de construir, dificil de modificar, poco reusable y generalmente solo
		provee soluciones a fallos de manera puntual.

		En cuanto al estado del arte en materia de sistemas autónomos existen diversos enfoques tanto en el ámbito académico
		como en la industria del software.

		Dentro del ámbito de la industria, el concepto de sistemas autónomos se encuentra ampliamente difundido. Sin dudas, el
		enfoque de IBM, denominado ``Autonomic Computing''\cite{IBM-AC} es el más completo, apalancado por un gran grupo de
		investigación y abarcando el problema desde distintos aspectos. También se destaca la iniciativa de Microsoft
		denominada ``Dynamic Systems Initiative'', y no tanto la iniciativa de Sun (``Predictive Self-Healing'' y
		``Conscientious Software''), por estar más ligada a adaptar el enfoque al dominio de los sistemas operativos. Para más
		información sobre estos enfoques, remitirse a \cite{Casuscelli}

		Por otro lado, existen distintos investigadores ligados a prestigiosas instituciones académicas abocados al estudio de
		distintos aspectos de la autonomía de los sistemas. Uno de los primeros investigadores en acuñar el término ``Self
		Healing'' fue el Dr. David Garlan, de la Universidad de Carnegie Mellon, quien formó un grupo de investigación que
		dedicó años a estudiar el tema dentro del marco del proyecto ABLE.\footnote{El proyecto ABLE (\emph{``Architecture
		Based Languages and Environments''}) de la Universidad de Carnegie Mellon lleva a cabo investigaciones que conducen a
		una base de ingeniería para la arquitectura de software. Para más información, visitar
		\url{http://www.cs.cmu.edu/~able}}
		
		El presente trabajo toma como base el trabajo generado por el proyecto ABLE de Carnegie Mellon, el cual implementa
		el concepto de ``Auto Reparación de Sistemas Basada en Modelos de Arquitectura'', el cual se describirá en detalle a
		continuación.

	\subsubsection{Auto Reparación de Sistemas Basada en Modelos de Arquitectura}

		Este enfoque ha sido propuesto por el Dr. Garlan, el cual intenta basar la auto reparación en el modelo de la
		arquitectura del sistema, en lugar de los mecanismos tradicionales para detección y recuperación de errores que se
		implementan a nivel de código.

		La idea propuesta consiste básicamente en un bucle cerrado (\emph{closed-loop} en inglés), donde existen dos capas
		(externas al sistema que está siendo ejecutado) que actúan, una como mecanismo de control y otra monitoreando el
		sistema, lo cual provee una solución mas efectiva que cualquier mecanismo interno porque permite agrupar todo lo
		concerniente a la detección y solución del problema en módulos separados, pudiendo ser analizados, modificados,
		extendidos y reutilizados a través de distintos sistemas.

		\begin{figure}[h]
			\centering
				\includegraphics{images/selfhealing-closed-loop.png}
			\caption{Bucle cerrado}
			\label{fig:selfhealing-closed-loop}
		\end{figure}

		Otro sub-proyecto del proyecto ABLE, denominado \textbf{Rainbow} (sobre el cual profundizaremos más adelante) utiliza
		esta técnica de \emph{closed-loop} para monitorear y reparar sistemas.

	\subsection{Lenguajes de Descripción de Arquitecturas}

		Un problema fundamental en el diseño de arquitecturas de sistemas utilizando el estilo de componentes y
		conectores ha sido encontrar la notación apropiada para definir dichas arquitecturas.

		Un buen lenguaje para describir arquitecturas debería permitir generar una documentación clara sobre los componentes
		de la arquitectura, que luego servirá como base a los desarrolladores, permitiendo a su vez razonar sobre las
		propiedades del sistema y automatizar su análisis, hasta pudiendo quizás llegar a utilizarse para la generación
		automática de parte del código que implementará la arquitectura. También debería ser efectivo para poder validar de
		manera temprana decisiones arquitectónicas, reduciendo así el tiempo de implementación y evitando utilizar
		ineficientemente recursos en el desarrollo del sistema.

		Una forma de describir dichas arquitecturas es mediante el modelado de objetos, si bien este método ha sido
		ampliamente aceptado y utilizado en la industria, tiene varios inconvenientes, el más importante y bloqueante es que
		no proveen un soporte directo para describir propiedades no funcionales, esto hace dificultoso razonar sobre
		propiedades críticas del sistema, como por ejemplo la performance o la confiabilidad. Ésta es la razón principal que
		ha motivado el avance de los ADLs (Architecture Description Languages). Para más información sobre la discusión ADL's
		vs. UML, remitirse a \cite{ADLsVsUML}.

		La descripción de arquitecturas de sistemas basada en ADLs ha avanzado considerablemente en las últimas dos décadas,
		al punto de que ya permiten definir una base formal para su descripción y análisis.

	\subsubsection{Acme}
	\label{sec:acme}

		Acme\cite{ACME} es uno de los ADLs más reconocidos y utilizados, ha sido desarrollado en la Carnegie Mellon
		University, más precisamente por el proyecto ABLE, liderado por el Dr. David Garlan.

		Acme es un pilar fundamental dentro del proyecto ABLE, ya que todo el proyecto gira en torno a la arquitectura de
		software de los sistemas, y es Acme quien permite describir formalmente dichas arquitecturas, por lo tanto todos los
		restantes subproyectos utilizan Acme en menor o mayor medida.

		Además de los beneficios de todo ADL, el lenguaje Acme y su kit de herramientas \emph{AcmeLib (Acme Tool Developer's
		Library)} proveen las siguientes capacidades fundamentales:

		\begin{itemize}
			\item Intercambio Arquitectural: al proveer un formato de intercambio genérico para diseñar arquitecturas de
			software, Acme permite a los desarrolladores de herramientas de este tipo \footnote{ejemplos de herramientas de
			descripción de arquitecturas y modelado UML podrían ser: Enterprise Architect (\url{http://www.sparxsystems.com.au/})
			o Poseidón (\url{http://www.gentleware.com/}), entre tantas otras.} integrar fácilmente con otras herramientas
			complementarias. De esta manera, los arquitectos que usan herramientas basadas en Acme tienen un espectro más amplio
			de herramientas de	análisis y diseño que quienes diseñan sus arquitecturas usando otros ADLs.
			\item Extensibilidad: Acme provee una base sólida, genérica y extensible, y una infraestructura que evita que los
			desarrolladores vuelvan a construir herramientas de base. Más aún, debido a su idea originaria de lenguaje de
			intercambio genérico, Acme permite que las herramientas que se han desarrollado utilizándolo sean compatibles con una
			gran variedad ADLs existentes y con herramientas con un mínimo esfuerzo, y hasta en algunos casos sin esfuerzo alguno.
		\end{itemize}

		Actualmente, el lenguaje Acme y \emph{Acme Tool Developer's Library (AcmeLib)}, proveen una infraestructura genérica y
		extensible para describir, representar, analizar y generar descripciones de arquitecturas de software.

		A continuación, observamos un breve ejemplo de una arquitectura modelada en el lenguaje ACME, la cual posee un
		sistema que contiene:
		\begin{itemize}
			\item un servidor HTTP (con algunas propiedades como por ejemplo fidelidad del contenido que provee)
			\item un cliente HTTP, también con algunas propiedades particulares como el tiempo de respuesta experimentado por el
			usuario.
		\end{itemize}

		\begin{Verbatim}[gobble=3]
			System system : EnvType = {
			    Component server : ServerT, ArchElementT = new ServerT, ArchElementT extended with {
			        Port http0 : HttpPortT;
			        Property cost;
			        Property fidelity;
			        Property load;
			    }
			    Component client : ClientT = new ClientT extended with {
			        Port p0 : HttpReqPortT = new HttpReqPortT extended with {
			            Property isArchEnabled = true;
			        }
			        Property deploymentLocation = "127.0.0.1";
			        Property isArchEnabled = true;
			        Property experRespTime;
			    }
			}
		\end{Verbatim}

		Más adelante, en la sección \ref{sec:casosPracticos}, veremos otro ejemplo (más extenso) del lenguaje al mostrar la
		descripción completa en Acme de la arquitectura del sistema que utilizaremos para mostrar los resultados de la extensión
		implementada en el presente trabajo.

	\subsection{Rainbow}

		\subsubsection{Introducción a Rainbow}

			Software-based systems today increasingly operate in changing environments with variable user needs, resulting in the
			continued increase in administrative overhead for managing these systems. To reduce these costs, systems are
			increasingly expected to dynamically self-adapt to accommodate resource variability, changing user needs, and system
			faults. Mechanisms that support self-adaptation currently exist in the form of programming language features
			such as exceptions and in algorithms such as fault-tolerant protocols. But these mechanisms are
			often highly specific to the application and tightly bound to the code. As a result, self-adaptation in
			today's systems is costly to build, diffiult to modify, and usually provides only localized treatment of
			system faults.
			
			In contrast to these internal mechanisms, recent work uses external models and mechanisms in a closed-loop control
			fashion to achieve various goals by monitoring and adapting system behavior at run-time.1,2 As illustrated in Figure 1,
			control of system adaptation becomes the responsibility of compo- nents outside the system that is being adapted.
			In principle, external control mechanisms provide a more effective engineering solution than internal mechanisms for
			self-adaptation because they localize the concerns of problem detection and
			
			
			resolution in separable modules that can be analyzed, modified, extended, and reused across different systems.
			Additionally, developers can use this approach to add self-adaptation to legacy systems for which the source code may
			not be available. This external approach requires using an appropriate model to reason about the system's dynamic
			behavior. Several researchers have proposed using architectural models,3 which represent the system as a gross
			composition of components, their inter- connections, and their properties of interest.4 Such an architecture-based
			self-adaptation approach offers many benefits. Most significantly, an abstract architectural model can provide a global
			perspective of the system and expose important system-level properties and integrity constraints.
			While attractive in principle, architecture-based self-adaptation raises a number of research and engineering
			challenges. First, the ability to handle a wide variety of systems must be addressed. Since different systems have
			radically different architec- tural styles, properties of interest, and mechanisms supporting dynamic modification, it is
			critical that the architectural control model and modification strategies be tailored to the specific system. Second,
			the need to reduce costs in adding external control to a system must be addressed. Creating the monitoring, modeling,
			and problem-detection mecha
			
			nisms from scratch for each new system would render the approach prohibitively expensive. Our Rainbow framework attempts
			to address both problems. By adopting an architecture-based approach, it provides reusable infrastructure together with
			mechanisms for specializing that infrastructure to the needs of specific systems. These specialization mechanisms let the
			developer of self-adaptation capa- bilities choose what aspects of the system to model and monitor, what conditions
			should trigger adap- tation, and how to adapt the system.
			
			THE RAINBOW FRAMEWORK
			Figure 2 shows the Rainbow framework's control loop for self-adaptation. Rainbow uses an abstract architectural model to
			monitor an execut- ing system's runtime properties, evaluates the model for constraint violation, and-if a problem
			occurs-performs global- and module-level adaptations on the running system.
			
			Reusable Rainbow units
			
			To fulfill Rainbow's objectives, its various components must be reusable from system to system. To identify what parts of
			the framework are reusable, and under what circumstances, we divide the framework into an adaptation infrastructure and
			the system-specific adaptation knowledge. The adaptation infrastructure, divided into system, architecture, and
			translation layers, provides common functionalities across self-adapting systems and is therefore reusable across all
			systems, while the adaptation knowledge itself is typically system-specific (Figure 2).
			System-layer infrastructure. At this layer, we have defined the system access interface and built an infrastructure that
			implements it. A system mea- surement mechanism, realized as probes, observes and measures various system states. This
			low-level system information can be published by or queried from the probes. Additionally, a resource discovery
			mechanism can be queried for new resources based on resource type and other criteria. Finally, an effector mechanism
			carries out the actual sys- tem modification.
			Architecture-layer infrastructure. At this layer, gauges aggregate information from the probes and update the
			appropriate properties in the architec- tural model. A model manager handles and provides access to the system's
			architectural model. A con- straint evaluator checks the model periodically and triggers adaptation if a constraint
			violation occurs. An adaptation engine then determines the course of action and carries out the necessary adaptation.
			Translation infrastructure. This infrastructure helps mediate the mapping of information across the
			abstraction gap from the system to the model and vice versa. A translation repository within the infrastructure
			maintains various mappings that the translator components share, for example, to trans- late an architectural-level
			element identifier into an IP address or an architectural-level change opera- tor into system-level operations.
			System-specific adaptation knowledge. Adding self-adaptation to a system using the functionalities that the adaptation
			infrastructure provides requires using the system-specific adaptation knowledge to tailor that infrastructure. This
			knowledge includes the target system's operational model, which defines parameters such as component types and
			properties, behavioral constraints, and adaptation strategies.



			La herramienta Rainbow, desarrollada también dentro del marco del proyecto ABLE, tiene como finalidad permitir
			reducir el costo e incrementar la confiabilidad al realizar cambios en sistemas complejos de software, para esto
			Rainbow automatiza la adaptación de sistemas de software a traves del modelo de su arquitectura, utilizando
			representaciones explícitas de las tareas del usuario, y estimaciones orientadas a la performance en tiempo de
			ejecución.

			La tecnología en la cual se apoya Rainbow esta basada en innovaciones en tres áreas críticas:
			\begin{enumerate}
				\item Detección: la habilidad de determinar dinámicamente (i.e. en \emph{runtime}) propiedades de sistemas
				complejos y distribuidos.
				\item Resolución: la habilidad de determinar cuando las propiedades observadas del sistema violan los supuestos
				críticos de diseño del sistema.
				\item Adaptación: la habilidad de automatizar la adaptación del sistema en respuesta a las violaciones de los
				supuestos de diseño del sistema.
			\end{enumerate}

			Éstas habilidades proveerán:
			\begin{itemize}
				\item La posibilidad de manipular los cambios en el sistema con respecto a estimaciones soportadas por Rainbow.
				\item Un framework extensible para manipular estimaciones y estrategias de adaptación creadas por terceros.
			\end{itemize}

			Tomando todo esto en conjunto, el objetivo de Rainbow es reducir drásticamente la necesidad de intervención humana en
			la adaptación de sistemas ante cambios en el ambiente para alcanzar los objetivos de calidad requeridos.

			\todo{hablar sobre closed-loop: In contrast to these internal mechanisms, recent work uses external models and
			mechanisms in a closed-loop control fashion to achieve various goals by monitoring and adapting system behavior at
			runtime}

			 En resumen, Rainbow es un \emph{framework} desarrollado en Java cuya finalidad es proveer un mecanismo de adaptación
			 basado en arquitecturas para sistemas de software. Rainbow utiliza un modelo abstracto para monitorear las
			 propiedades de un sistema en tiempo de ejecución, evalúa el modelo detectando violaciones en las restricciones y al
			 encontrar una, ejecuta adaptaciones sobre el sistema en ejecución. A continuación describiremos con más detalle los
			 modulos constitutivos de Rainbow.

			\begin{figure}[H]
				\centering
					\includegraphics{images/Rainbow_Framework.png}
				\caption{Arquitectura de Rainbow}
				\label{fig:Rainbow_Framework}
			\end{figure}
	
			\begin{itemize}
				\item \textbf{Monitor (o \emph{Probe})}: es el módulo que se encarga de obtener la información sobre el
				funcionamiento del sistema en tiempo de ejecución.
				\item \textbf{Evaluador de Restricciones}: es el que determina si el valor de alguna de las variables que se están
				monitoreando violó alguna de las restricciones planteadas (por ejemplo, que la \emph{performance} de un proceso dejó
				de ser aceptable).
				\item \textbf{Modelo de Arquitectura}: es el módulo que contiene una representación en el lenguaje \textbf{Acme} de
				la arquitectura del sistema que se quiere adaptar.
				\item \textbf{Manejador de Reparaciones}: es el módulo que se ocupa de determinar la forma en la que se va a reparar
				o adaptar el sistema en función de los problemas detectados.
				\item \textbf{Intérprete}: es el módulo que interpreta los cambios ocurridos en tiempo de ejecución y los
				``traduce'' a cambios en el modelo de arquitectura.
				\item \textbf{Administrador de Runtime}: es el módulo que implementa en tiempo de ejecución el cambio en el
				comportamiento de la aplicación.
			\end{itemize}
	
			Todos estos mecanismos funcionan de manera externa a la aplicación. Este enfoque tiene varias ventajas, siendo la
			principal el hecho de contar con un \emph{framework} reusable que pueda ser conectado a distintos tipos de
			aplicaciones para que implementen mecanismos de adaptación, minimizando el impacto en la aplicación.
	
			El caracter externo y no intrusivo de Rainbow representa una ventaja también cuando se desea implementar
			auto-reparación en sistemas cuyo código fuente no está disponible o no es plausible de ser modificado.
	
			A pesar de intentar implementar un mecanismo genérico de auto-reparación, Rainbow tiene varios componentes con
			conocimiento fijo\footnote{Más conocido comúnmente como ``hardcodeado'' o ``cableado''.} sobre las reparaciones. Por
			ejemplo, cuáles son las tácticas para la reparación que se deben implementar cuando una determinada restricción es
			violada.

		\subsubsection{Tácticas y Estrategias}
		
			\todo{agregar ejemplo de estrategia, tomarlo de algun newssiteStrategies.s}

			El objetivo de la auto reparación será alcanzar determinados atributos de calidad, pero ¿Cómo haremos para alcanzar
			dichos atributos? En el libro \textbf{Software Arquitectura in Practice} \cite{BassClementz}, Bass, Clements y Kazman
			presentan dos conceptos que nos permiten alcanzar los objetivos del sistema y que han sido ampliamente adoptados en
			la industria, estos conceptos son: tácticas y estrategias.

			Allí se definen las tácticas como una decisión de diseño que influye sobre la respuesta de un atributo de
			calidad, mientras que definen a una estrategia como una colección de tácticas. La figura
			\ref{fig:tactics_control_to_response} muestra gráficamente la visión de las tácticas presentada por los autores.

			\begin{figure}[h]
				\centering
					\includegraphics{images/tactics_control_to_response.png}
				\caption{Visión gráfica del concepto de táctica}
				\label{fig:tactics_control_to_response}
			\end{figure}

			Las tácticas son herramientas que los arquitectos de software han utilizado durante años, en el libro mencionado
			simplemente se las aisla y se las describe, no pretende proclamar la invención de las tácticas sino más bien darle un
			nombre y organizar los patrones comunes utilizados en cuanto a decisiones de arquitectura y clasificarlos. Cada
			táctica	es una opción de diseño para el arquitecto, por ejemplo, introducir redundancia para incrementar la
			disponibilidad del	sistema. En resumen, en el libro se plantea que las estrategias afectan los atributos de calidad
			del sistema, y que	estos proveen a los \emph{stakeholders} de cierto beneficio, al cual llaman utilidad. Cada
			estrategia provee un nivel	específico de utilidad, pero en contrapartida presentan un costo en tiempo y en dinero.
			Por estos motivos se aconseja hacer participar a los \emph{stakeholders} a la hora de decidir qué estrategias se
			emplearán para satisfacer los atributos de calidad definidos para el sistema. Ellos deberán evaluar el retorno de la
			inversión (el ratio entre el beneficio y el costo) de aplicar cada estrategia para elegir la más conveniente.

			La estrategia es la herramienta propuesta por Rainbow para quitar al sistema de un estado indeseable. Por ejemplo, al
			verse la performance del sistema comprometida, una estrategia podría agregar servidores hasta llevar la performance a
			un nivel adecuado.

			Las estrategias son desarrolladas para un \emph{concern} específico. Un \emph{concern} de un sistema abarca un
			subconjunto de propiedades del sistema, como por ejemplo performance, costo o confiabilidad. En una arquitectura
			cliente-servidor, el \emph{concern} performance abarcaría las propiedades ancho de banda y carga del sistema,
			mientras que el \emph{concern} costo se encargaría del costo de los servidores.

			Las estrategias se componen de tácticas, las cuales realizan la modificación en el sistema. Por ejemplo, una
			estrategia podría ser: agregar servidores mientras haya disponible, o hasta que el tiempo de respuesta haya alcanzado
			un	determinado valor. Esta lógica sería descripta en la estrategia, mientras que va a ser la táctica
			levantar-servidor la responsable de ejecutar la acción propiamente dicha, a la cual se la llama \textbf{operador}.

			\todo{TASK: Explicar Stitch con más detalle}

			Rainbow provee un lenguaje de scripting llamado \textbf{Stitch}, pensado para permitir plasmar el conocimiento
			rutinario de las personas sobre adaptación de sistemas de software. Tanto las tácticas como las estrategias serán
			descriptas utilizando Stitch. Ofrece modularidad con respecto a las dimensiones de los atributos de calidad y al
			dominio, permite especificar estrategias de múltiples pasos con condiciones de aplicabilidad y efectos deseados y
			provee	un mecanismo para extender las políticas de adaptación a dominios específicos de sistemas.

		\subsubsection{EMA: Suavizando el Comportamiento}
		\label{sec:exponentialAverage}

			El proceso de adaptar un sistema de manera dinámica puede llegar a ser muy costoso, por ejemplo podría requerir
			asignar más servidores a atender las peticiones de los usuarios, con el respectivo coste monetario que esto podría
			llegar a implicar, también podría significar una merma en la calidad del servicio ofrecido, por ejemplo eliminando
			temporalmente la posibilidad de que los usuarios pueden visualizar los videos de un sitio de noticias. Esto hace que
			lanzar la auto reparación de un sistema deba ser una decisión tomada con cierta cautela y en base a datos confiables
			y sostenidos en el tiempo. Rainbow implementa un mecanismo que permite evitar accionamientos prematuros de la auto
			reparación por la presencia de \emph{outliers}, dicho mecanismo utiliza Exponential Moving Average (EMA), que permite
			ponderar los valores históricos versus el actual basándose en la siguiente fórmula:

			\todo{Ceria: Esto queda medio descolgado acá. Falta bastante detalle de rainbow... el típico grafiquito de su
			arquitectura por ejemplo}

			\begin{equation}
				S_{0} = Y_{0}
			\end{equation}
			\begin{equation}
				S_{t} = \alpha \times Y_{t} + (1-\alpha) \times S_{t-1}
			\end{equation}

			donde $\alpha$ es el factor de suavizado, siendo $0 < \alpha < 1$. En otras palabras, el valor suavizado \smash{$S_{t}$}
			es un simple promedio ponderado de la última observación \smash{$Y_{t}$} y el valor suavizado previo \smash{$S_{t-1}$}.
			El nombre factor de suavizado no es un nombre especialmente adecuado ya que en realidad a mayor $\alpha$ menor
			será el suavizado del promedio, mientras que valores cercanos a cero harán que el promedio se vea menos afectado por
			el nuevo valor observado. No existe un procedimiento formal para determinar el valor de $\alpha$, en el caso de
			Rainbow el valor escogido para las pruebas realizadas ha sido 0.3.

	\subsubsection{Znn: Evaluando la Efectividad de Rainbow}

		Znn es un sistema que simula un sitio web de noticias, el cual nació como proyecto de tesis de doctorado
		\cite{TesisOwen} de un investigadora de Carnegie Mellon, Shang-Wen Cheng. Sus objetivos fueron evaluar la efectividad
		de Rainbow en los siguientes aspectos:
		\begin{itemize}
			\item su efectividad para mantener los atributos de calidad al enfrentar condiciones cambiantes
			\item el \emph{overhead} de procesamiento que implica la auto reparación
			\item el esfuerzo que implica agregar auto reparación mediante Rainbow a Znn
		\end{itemize}

		Si bien Znn nació como herramienta para evaluar Rainbow, Znn y las herramientas asociadas utilizadas para evaluar
		Rainbow han sido abiertas a la comunidad para que puedan ser utilizadas para tomar métricas y poder comparar distintos
		sistemas de auto reparación.

		Znn provee un entorno de simulación de una arquitectura cliente servidor ampliamente configurable que permite
		representar situaciones y controlar las variables de simulación permitiendo modificarlas en cualquier punto de la
		simulación. Por ejemplo, el sistema que se está simulando podría comenzar con solamente 2 clientes, mostrando allí una
		performance aceptable, pero a partir de un momento dado, se agregan 10 clientes comprometiendo así la performance del
		mismo. De esta manera permite simular como responderían las estrategias implementadas ante dicha situación.

		En el presente trabajo se utlizará el modo simulación para realizar los casos de prueba, tomando las estrategias y
		tácticas de Znn. Éstas debieron ser adaptadas para que puedan continuar funcionando con los cambios propuestos en la
		tesis.

	\subsection{Escenarios de Atributos de Calidad y QAW}
		\label{sec:QAS}

		\todo{TASK: Extender definición de Escenarios de Atributos de Calidad (poco, está casi OK así)}

		Los atributos de calidad representan los requerimientos no funcionales de un sistema, y suelen estar pobremente
		especificados, o directamente no especificados (``un requerimiento que no es testeable no es implementable'').

		Los atributos de calidad pueden ser representados mediante escenarios. Los escenarios están compuestos por:

		\begin{itemize}
			\item \textbf{Fuente del estímulo}: Interna o externa \todo{mejorar esta explicación}
			\item \textbf{Estímulo}: condición que debe ser tenida en cuenta al llegar al sistema
			\item \textbf{Entorno}: condiciones en las cuales ocurre el estímulo
			\item \textbf{Artefacto}: el sistema o partes de él afectadas por el estímulo
			\item \textbf{Respuesta}: qué hace el sistema ante la llegada del estímulo
			\item \textbf{Medición de la respuesta}: cuantificación de un atributo de la respuesta
		\end{itemize}

		\begin{figure}[h]
			\centering
				\includegraphics{images/scenario.png}
			\caption{Visión gráfica de un escenario de QAW}
			\label{fig:scenario}
		\end{figure}

		Los escenarios son pequeñas historias que describen una interacción con el sistema, que impacta sobre un atributo de
		calidad en particular. Por ejemplo, un escenario sobre disponibilidad podría ser:
			\begin{quote}
			``Un proceso del sistema recibe un mensaje externo no anticipado durante un modo de operación normal. El proceso
			informa al operador y continúa su operación sin caídas.''
			\end{quote}

		Este escenario se descompone de la siguiente manera:
		\begin{itemize}
			\item \textbf{Fuente del estímulo}: Sistema externo
			\item \textbf{Estímulo}: Mensaje no anticipado
			\item \textbf{Entorno}: Operación normal
			\item \textbf{Artefacto}: Proceso interno
			\item \textbf{Respuesta}: Informar al operador y seguir operando
			\item \textbf{Medición de la respuesta}: sin caídas (downtime)
		\end{itemize}

		Los escenarios permiten obtener el punto de vista de un grupo diverso de stakeholders (arquitectos, desarrolladores,
		usuarios, sponsors, etc). Estos escenarios pueden luego ser utilizados para analizar la arquitectura del sistema e
		identificar concerns y posibles estrategias para atacar problemas.

		\todo{fuente de lo que sigue: http://www.sei.cmu.edu/architecture/tools/qaw/index.cfm}

		Existe una metodología definida por el Software Engineering Institute (SEI) conocida como Quality Attribute Workshop
		(QAW), cuya principal herramienta son los escenarios. Esta metodología provee un método para identificar los atributos
		de calidad críticos de la arquitectura de un sistema, tales como disponibilidad, performance, seguridad, etc, que son
		derivados de objetivos del negocio del sistema. QAW no asume la existencia de una arquitectura del software, sino que
		fue desarrollado en base a reclamos de los clientes que necesitaban un método para identificar los atributos de
		calidad importantes, y aclarar requerimientos del sistema antes de que su arquitectura esté definida.

		En los QAW se organizan reuniones con todos los stakeholders del sistema, en las que se definen los escenarios que en
		definitiva representarán los requerimientos de atributos de calidad que el sistema idealmente deberá satisfacer. Un
		vez definidos todos los escenarios, el siguiente paso del QAW consiste en priorizar y refinar los escenarios, por
		ejemplo agregando detalles adicionales tales como los participantes involucrados, la secuencia de actividades, y
		preguntas sobre el requerimiento que representa cada escenario. El proceso de refinar los escenarios permite a los
		stakeholders comunicarse entre ellos, exponiendo supuestos que pueden no ser tan claros para el resto del grupo. Dicho
		refinamiento también proporciona una visión de cómo interactúan los atributos de calidad entre sí, sirviendo de base
		para definir tradeoffs entre estos atributos.

		El proceso QAW termina con la lista de escenarios refinados y priorizados. Los mismos pueden servir para definir casos
		de pruebas, o como semillas para el proceso ATAM.

	\subsection{ATAM}
	\label{sec:atam}
		\todo{fuente: svn/doc/atam/ATAM Method for Architecture Evaluation.pdf}

		\todo{TASK: Extender definición de ATAM, poner grafiquito, poner foco en la parte de sensitivity point y tradeoff
		point que son los que nos sirven. Poner un ejemplo de c/u.}

		ATAM (Architecture Tradeoff Analysis Method) ha sido desarrollado por el SEI, al igual que QAW, y es una técnica que
		permite analizar arquitecturas de software. Las arquitecturas son complejas, e involucran muchos tradeoffs de diseño.
		Sin un proceso de análisis formal, no se puede estar seguro de que las decisiones de arquitectura tomadas - en
		particular aquellas que afectan el cumplimiento de requerimientos de calidad como performance, disponibilidad,
		seguridad y modificabilidad - son adecuadas para mitigar los riesgos.

		El nombre ATAM proviene no solo del hecho de que refleja cuán bien una arquitectura satisface objetivos de calidad
		específicos, sino también del hecho de que provee una visión de cómo esos objetivos de calidad interactúan entre sí,
		esto es lo que conocemos como tradeoffs.

		La meta de evaluar una arquitectura con ATAM es entender las consecuencias de las decisiones arquitectónicas con
		respecto a los requerimientos de atributos de calidad del sistema. Otro objetivo fundamental de ATAM es determinar si
		dichos requerimientos pueden ser alcanzados con la arquitectura concebida, antes de destinar grandes cantidades de
		recursos a la construcción del software.

		ATAM es un método estructurado y repetible, ayudando así a que las preguntas correctas sobre la arquitectura sean
		planteadas de manera temprana en el proyecto, durante las etapas de análisis de requerimentos y de diseño, en las
		cuales los problemas detectados pueden ser corregidos sin mayores costos. ATAM guía a los usuarios del método
		(stakeholders) para que busquen conflictos en la arquitectura y soluciones a dichos conflictos.

		Cabe aclarar que los QAW han surgido como consecuencia del uso de ATAM, ya que usuarios de éste último solicitaban una
		herramienta o método que les permitiera identificar los requerimientos y los atributos de calidad más importantes del
		sistema, pero antes de que existiese la arquitectura sobre la cual ATAM trabajaría.

		\todo{Sensitivity points, tradeoffs, etc.}