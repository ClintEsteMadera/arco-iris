\section{Conceptos Preliminares}

	\subsection{No todo es funcionalidad\ldots}

		\subsubsection{Restricciones}

			En el desarrollo de sistemas críticos, no es suficiente el satisfacer sólamente \textbf{requerimientos funcionales}
			(i.e. ``aquello que el software deber hacer''). Este tipo de sistemas generalmente deben satisfacer otro tipo de
			\textbf{requerimientos no funcionales}, también llamados \textbf{Restricciones}, los cuales especifican criterios a
			ser usados para juzgar la operación de un sistema en lugar de describir funcionalidad específica para el mismo.
			
			Algunos ejemplos de restricciones sobre un sistema de software son los siguientes:
	
			\begin{enumerate}
				\item el código de la aplicación debe ser desarrollado en Java.
				\item la base de datos debe ser SQL Server.
				\item sólo se utilizarán productos de código abierto (\emph{open-source}).
				\item el sistema debe ser escalable con respecto a la cantidad de usuarios que lo utilizan concurrentemente.
				\item el sistema debe implementar políticas de tolerancia a fallos.
				\item el sistema debe ser diseñado de manera tal que se minimize el procesamiento y el tiempo de respuesta.
			\end{enumerate}
	
			Observamos que 1, 2 y 3 establecen meras restricciones a tener en cuenta en el análisis, diseño o desarrollo de la
			aplicación; mientras que 4, 5 y 6 se refieren a características específicas de \textbf{calidad} deseadas para el
			sistema. Estos últimos se denominan \textbf{Atributos de Calidad} y es imprescindible conocerlos para poder diseñar
			la arquitectura de un sistema. Notemos que, en el ejemplo anterior, las restricciones correspondientes a atributos de
			calidad (4, 5 y 6), están especificados de manera vaga e imprecisa. Esto es lo que suele ocurrir en la mayoría de
			los casos en la industria de desarrollo de \emph{software}. Notar también que los requerimientos 4 y 6 pueden
			llegar a afectarse mutuamente: esto también es muy común y para lograr un buen \emph{tradeoff} entre atributos
			de calidad los arquitectos suelen tener que tomar un conjunto de decisiones arquitectónicas llamadas
			\textbf{estrategias}, sobre las cuales profundizaremos en la sección \ref{sec:tacticasEstrategias}.

		\subsubsection{Atributos de Calidad y \emph{Concerns}}
		
			El estándar 1061-1998 de la IEEE \footnote{Para más información, visitar
			\url{http://standards.ieee.org/findstds/standard/1061-1998.html}} que establece una metodología para la definición de
			métricas con respecto a la calidad del \emph{software}, reza:
			
			\begin{quote}
				La calidad del \emph{software} es el nivel que posee de una combinación deseada de atributos (e.g. confiabilidad,
				interoperabilidad, \emph{performance}, etc.)
			\end{quote}
			
			Algunos ejemplos de atributos de calidad definidos en los estándares IEEE 1061 / ISO 9126
			\footnote{Para más información, visitar \url{http://es.wikipedia.org/wiki/ISO/IEC_9126}} son:
			\begin{itemize}
				\item Eficiencia
				\item Funcionalidad
				\item Mantenibilidad
				\item Portabilidad
				\item Confiabilidad
				\item Usabilidad
			\end{itemize}
			
			Imaginemos que un \emph{sponsor} de un sistema a ser desarrollado establece que el sistema debe ser ``eficiente''.
			¿Qué significa esto exactamente? La pregunta es difícil de contestar si no se dispone de más información.
			Evidentemente, los atributos de calidad son categorizaciones de alto nivel que, si no se dispone de más
			información, no parecen servir de mucho para tomar decisiones arquitectónicas en pos de alcanzar un
			nivel aceptable de dichos atributos de calidad. Al rescate de tal carencia aparecen las denominadas
			\textbf{Incumbencias} o, del inglés y tales como las llamaremos a lo largo de este trabajo, \textbf{Concerns}.
			
			Los \textbf{Concerns} son parámetros mediante los cuales los atributos de un sistema son juzgados, especificados y
			medidos. Usualmente, los requerimientos de atributos de calidad son expresados en términos de \emph{concerns}.
			\cite{QA}.
			
			A continuación, enumeraremos algunos ejemplos de concerns, junto con el atributo de calidad al que pertenecen:
			
			\begin{center}
				\rowcolors*[\hline]{1}{GreenYellow!25}{GreenYellow!10}
				\begin{tabular}{|c|c|}
				\textbf{Atributo de Calidad} & \textbf{\emph{Concerns}}\\
				Eficiencia & Comportamiento Temporal, Utilización de Recursos\\
				Funcionalidad & Interoperabilidad, Seguridad\\
				Mantenibilidad & Cambiabilidad, Facilidad de Prueba\\
				Portabilidad & Adaptabilidad, Coexistencia\\
				Usabilidad & Compresibilidad, Atractivo			
				\end{tabular}
			\end{center}

			Los \emph{concerns} pueden usualmente relacionarse con propiedades de la arquitectura de un sistema, por ejemplo,
			en una arquitectura cliente-servidor, el atributo de calidad \emph{performance} posee varios \emph{concerns}
			asociados, por ejemplo, el \textbf{tiempo de respuesta}, el cuál está relacionado directamente con algunas
			propiedades de la arquitectura como el ancho de banda de los servidores, la carga del sistema, la cantidad de
			servidores, etc.
			
			Tanto los atributos de calidad como los \emph{concerns} son conceptos fundamentales en el presente trabajo, no solo
			desde un punto de vista teórico sino que también serán utilizados en la práctica.
			
	\subsection{Sistemas Autónomos, Auto Adaptación, Auto Reparación\ldots}

 		A medida que va pasando el tiempo, los sistemas de software se vuelven cada vez más complejos y más exigentes en
		cuanto a disponibilidad se trata. Hoy en día los mismos operan en ambientes dinámicos, con requerimientos de usuario
		altamente cambiantes y con la necesidad de operar prácticamente sin interrupción, resultando esto en un aumento
		en la administración operativa del software, lo cual representa un costo importante para que el sistema pueda
		mantenerse operativo. Para reducir este costo, se puede plantear que los sistemas se adapten de manera dinámica para
		poder utilizar los recursos existentes, a fin de poder atender los cambiantes requerimientos de atributos de
		calidad, así también como los errores en el sistema. De forma genérica, a los sistemas de software que cumplen con
		estas características, se los denomina \textbf{Sistemas Autónomos}.

		Hilando más fino en la caracterización de sistemas autónomos, encontramos términos en inglés como \emph{Self
		Configuring} o \emph{Self Adapting} para referirse a sistemas autónomos que tienen la capacidad de auto configurarse
		(o auto adaptarse) a condiciones cambiantes en el entorno de ejecución del sistema.

		Por otro lado, cuando la adaptación dinámica del sistema responde a errores o situaciones excepcionales del
		mismo, el término más utilizado actualmente es \emph{Self Healing} o, en castellano, \textbf{Auto Reparación}.

		Si bien ya existen mecanismos para mitigar los mencionados problemas, ellos normalmente están intrínsecamente ligados
		al lenguaje de programación utilizado para construír la aplicación, tales como tratamiento de excepciones, protocolos de
		tolerancia a fallos, etc. Además, estos mecanismos generalmente dependen del código de la aplicación que se intenta
		adaptar y consecuentemente, no son fácilmente reutilizables entre distintos sistemas. En resúmen: hoy en día, la
		adaptación de sistemas de software es costosa de construir, dificil de modificar, poco reusable y generalmente solo
		provee soluciones a fallos de manera puntual.

		En cuanto al estado del arte en materia de sistemas autónomos existen diversos enfoques tanto en el ámbito académico
		como en la industria del software.

		Dentro del ámbito de la industria, el concepto de sistemas autónomos se encuentra ampliamente difundido. Sin dudas, el
		enfoque de IBM, denominado ``Autonomic Computing'' \cite{IBM-AC} es el más completo, apalancado por un gran grupo de
		investigación y abarcando el problema desde distintos aspectos. También se destaca la iniciativa de Microsoft
		denominada ``Dynamic Systems Initiative'', y no tanto la iniciativa de Sun (``Predictive Self-Healing'' y
		``Conscientious Software''), por estar más ligada a adaptar el enfoque al dominio de los sistemas operativos. Para más
		información sobre estos enfoques, remitirse a \cite{Casuscelli}

		Por otro lado, existen distintos investigadores ligados a prestigiosas instituciones académicas abocados al estudio de
		distintos aspectos de la autonomía de los sistemas. Uno de los primeros investigadores en acuñar el término ``Self
		Healing'' fue el Dr. David Garlan, de la Universidad de Carnegie Mellon, quien formó un grupo de investigación que
		dedicó años a estudiar el tema dentro del marco del proyecto ABLE.\footnote{El proyecto ABLE (\emph{``Architecture
		Based Languages and Environments''}) de la Universidad de Carnegie Mellon lleva a cabo investigaciones que conducen a
		una base de ingeniería para la arquitectura de software. Para más información, visitar
		\url{http://www.cs.cmu.edu/~able}}

		El presente trabajo toma como base el trabajo generado por el proyecto ABLE de Carnegie Mellon, el cual implementa
		el concepto de ``Auto Reparación de Sistemas Basada en Modelos de Arquitectura'', el cual se describirá en detalle a
		continuación.

	\subsubsection{Auto Reparación de Sistemas Basada en Modelos de Arquitectura}
	\label{sec:ARSBMA}

		En contraste con los mecanismos tradicionales para detección y recuperación de errores que se implementan como parte
		del código específico de la aplicación, con mecanismos localizados y poco escalables entre distintos sistemas; el
		enfoque propuesto por el Dr. David Garlan, usa \textbf{el modelo de la arquitectura} del sistema que se desea adaptar
		como instrumento para razonar sobre sus propiedades (e.g. tiempo de respuesta de un servidor) y sus correlatos
		con la dinámica del sistema en tiempo de ejecución.

		Diversos investigadores han propuesto usar modelos arquitecturales \cite{ArchBasedApproach} que representan al
		sistema como una mera composición de componentes, sus interconexiones (conectores) y sus propiedades de
		interés. Este modelo es conocido comunmente como \textbf{C\&C} (componentes y conectores)\cite{C&C}. Tal propuesta
		ofrece diversos beneficios, el más significativo: un modelo arquitectural abstracto provee una perspectiva global del
		sistema y expone sus propiedades y restricciones de integridad.

		La idea propuesta consiste básicamente en un bucle cerrado (\emph{closed-loop} en inglés), donde existen dos capas
		(externas al sistema que está siendo ejecutado) que actúan, una encargada del monitoreo del sistema y la otra
		proveyendo un mecanismo de control y adaptación. Esto ofrece una solución mas efectiva que cualquier mecanismo interno
		porque permite agrupar todo lo concerniente a la detección y solución del problema en módulos separados, pudiendo ser
		analizados, modificados, extendidos y reutilizados a través de distintos sistemas.

		\begin{figure}[h]
			\centering
				\includegraphics{images/selfhealing-closed-loop.png}
			\caption{Bucle cerrado}
			\label{fig:selfhealing-closed-loop}
		\end{figure}

		Otro sub proyecto del proyecto ABLE, denominado \textbf{Rainbow} (sobre el cual profundizaremos más adelante) utiliza
		esta técnica de \emph{closed-loop} para monitorear y reparar sistemas.

	\subsection{Lenguajes de Descripción de Arquitecturas}

		Un problema fundamental en el diseño de arquitecturas de sistemas utilizando el estilo de componentes y
		conectores ha sido encontrar la notación apropiada para definir dichas arquitecturas.

		Un buen lenguaje para describir arquitecturas debería permitir generar una documentación clara sobre los componentes
		de la arquitectura, que luego servirá como base a los de\-sa\-rro\-lla\-do\-res, permitiendo a su vez razonar sobre
		las propiedades del sistema y automatizar su análisis, hasta pudiendo quizás llegar a utilizarse para la generación
		automática de parte del código que implementará la arquitectura. También debería ser efectivo para poder validar de
		manera temprana decisiones arquitectónicas, reduciendo así el tiempo de implementación y evitando utilizar
		ineficientemente recursos en el desarrollo del sistema.

		Una forma de describir dichas arquitecturas es mediante el modelado de objetos mediante UML, si bien este método ha
		sido ampliamente aceptado y utilizado en la industria, tiene varios inconvenientes, el más importante e
		invalidante es que no provee un soporte directo para describir propiedades no funcionales, esto hace dificultoso
		razonar sobre propiedades críticas del sistema, como por ejemplo la \emph{performance} o la confiabilidad. Ésta es la
		razón principal que ha motivado el avance de los ADLs (\emph{Architecture Description Languages}). Para más
		información sobre la discusión ADL's vs. UML, remitirse a \cite{ADLsVsUML}.

		La descripción de arquitecturas de sistemas basada en ADLs ha avanzado considerablemente en las últimas dos décadas,
		al punto de que ya permiten definir una base formal para su descripción y análisis.

	\subsubsection{Acme}
	\label{sec:acme}

		Acme\cite{ACME} es uno de los ADLs más reconocidos y utilizados, ha sido desarrollado en la universidad de Carnegie
		Mellon, más precisamente por el proyecto ABLE, liderado por el Dr. David Garlan.

		Acme es un pilar fundamental dentro del proyecto ABLE, ya que todo el proyecto gira en torno a la arquitectura de
		software de los sistemas, y es Acme quien permite describir formalmente dichas arquitecturas, por lo tanto todos los
		restantes sub proyectos utilizan Acme en menor o mayor medida.

		Además de los beneficios de todo ADL, el lenguaje Acme y su kit de herramientas \emph{AcmeLib (Acme Tool Developer's
		Library)} proveen las siguientes capacidades fundamentales:

		\begin{itemize}
			\item Intercambio Arquitectural: al proveer un formato de intercambio genérico para diseñar arquitecturas de
			software, Acme permite a los desarrolladores de herramientas de este tipo \footnote{Ejemplos de herramientas de
			descripción de arquitecturas y modelado UML podrían ser: Enterprise Architect (\url{http://www.sparxsystems.com.au/})
			o Poseidón (\url{http://www.gentleware.com/}), entre tantas otras.} integrar fácilmente con otras herramientas
			complementarias. De esta manera, los arquitectos que usan herramientas basadas en Acme tienen un espectro más amplio
			de herramientas de	análisis y diseño que quienes diseñan sus arquitecturas usando otros ADLs.
			\item Extensibilidad: Acme provee una base sólida, genérica y extensible, y una infraestructura que evita que los
			desarrolladores vuelvan a construir herramientas de base. Más aún, debido a su idea originaria de lenguaje de
			intercambio genérico, Acme permite que las herramientas que se han desarrollado utilizándolo sean compatibles con una
			gran variedad ADLs existentes y con herramientas con un mínimo esfuerzo, y hasta en algunos casos sin esfuerzo alguno.
		\end{itemize}

		Actualmente, el lenguaje Acme y \emph{Acme Tool Developer's Library (AcmeLib)}, proveen una infraestructura genérica y
		extensible para describir, representar, analizar y generar descripciones de arquitecturas de software.

		A continuación, observamos un breve ejemplo de una arquitectura modelada en el lenguaje ACME, la cual posee un
		sistema que contiene:
		\begin{itemize}
			\item un servidor HTTP, con algunas propiedades como por ejemplo fidelidad del contenido que provee.
			\item un cliente HTTP, también con algunas propiedades particulares como el tiempo de respuesta experimentado por el
			usuario.
		\end{itemize}

		\begin{Verbatim}[gobble=3]
			System system : ClientServerType = {
			    Component server : ServerT = new ServerT extended with {
			        Port http0 : HttpPortT;
			        Property cost;
			        Property fidelity;
			        Property load;
			    }
			    Component client : ClientT = new ClientT extended with {
			        Port p0 : HttpReqPortT = new HttpReqPortT extended with {
			            Property isArchEnabled = true;
			        }
			        Property deploymentLocation = "127.0.0.1";
			        Property isArchEnabled = true;
			        Property experRespTime;
			    }
			}
		\end{Verbatim}

		Más adelante, en la sección \ref{sec:casosPracticos}, veremos otro ejemplo (más extenso) del lenguaje al mostrar la
		descripción completa en Acme de la arquitectura del sistema que utilizaremos para mostrar los resultados de la extensión
		implementada en el presente trabajo.

		\subsubsection{Tácticas y Estrategias}
		\label{sec:tacticasEstrategias}

			Hemos mencionado anteriormente que el objetivo de la auto reparación es el alcanzar determinados atributos de
			calidad definidos para un determinado sistema, ajustando su comportamiento, de ser necesario, de acuerdo a
			las condiciones de ejecución del mismo. En el libro \textbf{Software Architecture in Practice} \cite{BassClementz},
			Bass, Clements y Kazman caracterizan y formalizan dos herramientas que vienen siendo ampliamente utilizadas desde
			hace tiempo por los arquitectos de software en la industria, estas son: las \textbf{tácticas} y las
			\textbf{estrategias}.

			Las \textbf{tácticas} se definen como decisiones de diseño tendientes a controlar las respuestas del sistema a
			determinados estímulos, a fin de satisfacer uno o más atributos de calidad requeridos. La figura
			\ref{fig:tactics_control_to_response} muestra gráficamente el concepto de táctica arquitectural.

			\begin{figure}[h]
				\centering
					\includegraphics{images/tactics_control_to_response.png}
				\caption{Visión gráfica del concepto de táctica}
				\label{fig:tactics_control_to_response}
			\end{figure}

			Cada táctica es una opción de diseño para el arquitecto, un ejemplo concreto podría ser el introducir redundancia en
			determinados componentes de la arquitectura (e.g. base de datos, servidores web replicados, etc.) para incrementar la
			dis\-po\-ni\-bi\-li\-dad del sistema.

			Por otro lado, una \textbf{estrategia} puede ser entendida como un procedimiento delineado por los arquitectos de
			\emph{software} para intentar llevar al sistema a un nivel dónde los atributos de calidad se cumplan en el nivel
			deseado; haciendo uso de una o más tácticas. Cada táctica es ejecutada únicamente cuando el estado del sistema
			satisface las condiciones impuestas por la estrategia para dicha ejecución. Por ejemplo, en una arquitectura
			cliente-servidor y al verse el tiempo de respuesta comprometido, una estrategia podría intentar agregar servidores
			mientras existan disponibles o, hasta que el tiempo de respuesta haya descendido por debajo de un determinado umbral.
			Esta lógica sería descrita en la estrategia, mientras que será la táctica \verb@levantar-servidor@ la responsable de
			ejecutar la acción propiamente dicha. Notar que si bien esta estrategia está diseñada para mejorar el tiempo de
			respuesta, también afecta negativamente al \emph{concern} ``cantidad de servidores'' (correspondiente al atributo de
			calidad ``costo'') puesto que usualmente el utilizar mayor cantidad de servidores suele tener un costo económico no
			despreciable.
			
			Cuando una estrategia se diseña para mejorar un atributo de calidad en particular, se puede decir que los
			\emph{stakeholders} que definen dichos atributos de calidad obtienen cierto ``beneficio'' de las estrategias. Cada
			estrategia provee un nivel específico de dicho beneficio, pero en contrapartida presenta un costo en tiempo y, sobre
			todo, en dinero. Es por este motivo que los \emph{stakeholders} deben participar en el proceso de decisión de cúales
			estrategias se emplearán para satisfacer los atributos de calidad definidos para el sistema. Ellos deberán evaluar el
			retorno de la inversión (la relación costo-beneficio) de aplicar cada estrategia para elegir la más conveniente.

			La estrategia es la herramienta propuesta por Rainbow para quitar al sistema de un estado no deseado.

	\subsection{Rainbow}

		\subsubsection{Introducción a Rainbow}

			La herramienta Rainbow, también dentro del marco del proyecto ABLE, tiene como finalidad permitir reducir el costo e
			incrementar la confiabilidad al realizar cambios en sistemas complejos de software, para esto Rainbow automatiza la
			adaptación de sistemas de software a traves de sus modelos de arquitectura, tal cual fue descrito en la sección
			\ref{sec:ARSBMA}.

			Si bien en principio el enfoque de auto adaptación basado en arquitecturas es atractivo, el mismo supone un número
			significativo de desafíos en el campo de la investigación así también como en el de la ingeniería:

			\begin{itemize}
				\item En primer lugar, uno de los aspectos claves que Rainbow intenta cubrir es la habilidad de manejar una amplia
				variedad de sistemas con arquitecturas, propiedades de interés y mecanismos que soporten modificaciones dinámicas
				completamente diferentes.

				\item Por otro lado, Rainbow intenta ser una solución que permita reducir el costo de agregar control externo al
				sistema a reparar, puesto que crear los me\-ca\-nis\-mos de monitoreo y detección de
				problemas desde cero para un sistema nuevo sería prohibitivamente costoso. El enfocar la auto reparación de un
				sistema en su arquitectura permite disponer de una infraestructura reutilizable junto con mecanismos para adaptar
				dicha infraestructura a las necesidades específicas de cada sistema.
			\end{itemize}

			Cabe mencionar que el caracter externo y no intrusivo de Rainbow representa una ventaja también cuando se
			desea implementar auto reparación en sistemas cuyo código fuente no está disponible o no es plausible de ser
			modificado.

			\subsubsection{Arquitectura de Rainbow}

				La Figura \ref{fig:Rainbow_Framework} muestra la arquitectura de Rainbow. En resumidas palabras, el \emph{framework}
				utiliza un modelo arquitectural abstracto para monitorear las propiedades en \emph{runtime} del sistema que está
				siendo ejecutado, evalúa el modelo para detectar violaciones a restricciones impuestas sobre el mismo y lleva a cabo
				adaptaciones en el sistema tendientes a eliminar tales violaciones.

				\begin{figure}[H]
					\centering
						\includegraphics{images/Rainbow_Framework.png}
					\caption{Arquitectura de Rainbow}
					\label{fig:Rainbow_Framework}
				\end{figure}

				La infraestructura de adaptación de Rainbow se divide en capas que proveen funcionalidades comunes a distintos
				sistemas auto adaptables logrando por lo tanto el objetivo de disponer de componentes reutilizables, a saber:
				\begin{enumerate}
					\item \textbf{Capa de Sistema}:\\
					En esta capa se define e implementa una interfaz de acceso al sistema que está siendo ejecutado. Se define un
					mecanismo para medir variables de interés, materializado en \emph{Probes}: componentes que observan
					y miden diversos estados del sistema, para luego publicarlos.

					Adicionalmente, existe un mecanismo para descubrir recursos que puede ser utilizado especificando el tipo de
					recurso, entre otros criterios. Finalmente, los denominados \emph{Effectors} llevan a cabo las modificaciones
					propiamente dichas sobre el sistema.
					\item \textbf{Capa de Arquitectura}:\\
					En esta capa, los denominados \emph{Gauges} agregan información provenientes de los \emph{Probes} y
					mantienen constantemente actualizadas las propiedades correspondientes en el modelo arquitectural del sistema
					(descrito en ACME), el cual es manejado y accedido mediante un componente denominado \emph{Model Manager}. El
					\emph{Constraint Evaluator} chequea el modelo periódicamente y dispara la adaptación en el caso que ocurra una
					violación en alguna restricción impuesta sobre el modelo. En ese caso, el motor de adaptación (\emph{Adaptation
					Engine}) determina el curso de acción y lleva a cabo la adaptación necesaria.
					\item \textbf{Capa de Traducción}:\\
					Esta capa es la encargada de cubrir la brecha de abstracción existente entre el sistema en ejecución y el modelo
					de su arquitectura (en ambos sentidos). En esta infraestructura, un repositorio de traducción mantiene diversos
					mapeos compartidos por distintos componentes dentro de esta capa, por ejemplo, una operación a nivel modelo de la
					arquitectura en su correspondiente operación de \emph{runtime}:

					\begin{Verbatim}[gobble=7]
						       Componente de Log::desactivar       <==>       Logger.disableLog()
					\end{Verbatim}
				\end{enumerate}

				Rainbow es un \emph{framework} desarrollado en el lenguaje de programación Java\textsuperscript{\texttrademark} y
				todos los derechos sobre el código fuente pertenecen al grupo ABLE de la Universidad de Carnegie Mellon. Los autores
				de este trabajo solicitaron permiso a este grupo para poder acceder al código fuente de Rainbow para poder realizar
				la extensión objeto de este trabajo. En la wiki oficial de Rainbow pueden encontrarse instrucciones para
				instalar versiones ya compiladas del \emph{framework}. Para más información, visitar
				\url{http://rainbow.self-adapt.org/RainbowInstall}.

		\subsubsection{Conocimiento específico del sistema}
		
			En la sección anterior hemos descrito la infraestructura básica provista por Rainbow. Es de notar que la misma no es
			suficiente para satisfacer las necesidades puntuales de auto adaptación de un sistema en particular. Para
			lograr esto, es necesario extender dicha infraestructura, agregando conocimiento específico del sistema que se desea
			adaptar. Este conocimiento (típicamente no reutilizable entre distintos sistemas) incluye el modelo operacional
			del sistema, que define parámetros como tipos de componentes y propiedades, restricciones de comportamiento,
			estrategias de adaptación, interfaz para acceder a la información de \emph{runtime} del sistema, así también como
			para hacer efectivas las estrategias de reparación, etc.

		\subsubsection{Stitch}
			A fin de disponer de una forma suficientemente expresiva de definir tácticas y estrategias, Rainbow incluye
			un lenguaje de \emph{scripting} de propósito específico llamado \textbf{Stitch}, el cual permite plasmar el
			conocimiento rutinario de las personas sobre adaptación de sistemas de software.

			Algunas de las características innovadoras de Stitch:
			\begin{itemize}
				\item \textbf{Control del sistema}: La selección de la próxima acción a ejecutar en el contexto de una estrategia
				depende de los efectos observados luego de la acción previa.
				\item \textbf{Sensibilidad al contexto}: La selección de la mejor estrategia se realiza considerando el estado
				actual del sistema, mediante la inspección de algunas de sus propiedades.
				\item \textbf{Asincronismo}: Stitch permite especificar un tiempo de demora luego de la ejecución de una táctica
				para que los efectos de la táctica se puedan ver reflejados en el sistema.
			\end{itemize}

		\subsubsection{Ejemplo de una Táctica en Stitch}

			En la figura \ref{fig:tactics_example} se puede apreciar un ejemplo de una táctica definida en Stitch para ser
			utilizada por Rainbow. Primeramente, se importa el modelo de la arquitectura del sistema en cuestión junto con la
			implementación de un operador que permite impactar al sistema en ejecución (estos operadores suelen ser provistos por
			el usuario de la aplicación).
			
			\begin{figure}[h]
				\centering
					\includegraphics[width=0.98\textwidth]{images/tactics_example.png}
				\caption{Ejemplo de una táctica en Stitch}
				\label{fig:tactics_example}
			\end{figure}
			
			La táctica consiste en disminuir la fidelidad (a modo sólo texto) del contenido provisto por todos los servidores
			cuando se detecta que al menos un cliente experimenta un tiempo de respuesta superior a un determinado umbral. Para lograr
			esto, Rainbow inspecciona las propiedades del modelo de la arquitectura del sistema, definido en ACME, el cúal se
			supone constantemente actualizado por Rainbow con respecto al estado actual del sistema en ejecución.
			
			Por último, se especifica que el efecto esperado de ejecutar la táctica consiste en que todos los clientes
			experimenten un tiempo de respuesta inferior al umbral y que, por otro lado, todos los servidores se encuentren
			prestando servicio en modo sólo texto.

		\subsubsection{Ejemplo de una Estrategia en Stitch}

			En la figura \ref{fig:strategies_example} podemos ver un ejemplo de una estrategia definida en Stitch para ser
			utilizada por Rainbow.

			\begin{figure}[h]
				\centering
					\includegraphics[width=0.98\textwidth]{images/strategies_example.png}
				\caption{Ejemplo de una estrategia en Stitch}
				\label{fig:strategies_example}
			\end{figure}

			La estrategia representa un algoritmo simple para disminuír el tiempo de respuesta experimentado por el usuario de un
			sistema cliente-servidor. Se definen algunos predicados de primer orden que predican sobre propiedades del modelo de
			la arquitectura del sistema, el cual se asume constantemente actualizado por Rainbow con respecto al sistema en
			ejecución. En el caso que haya en la arquitectura un conector que muestre alta latencia, se invoca la táctica
			definida en la Figura \ref{fig:tactics_example} (la cual cambia la fidelidad de todos los servidores a modo sólo
			texto) y se espera 1 segundo antes de determinar el éxito o no de la ejecución de la táctica.
			
			En el caso en el que no se detecte alta latencia o que la anterior táctica haya fallado, y siempre chequeando que se
			detecte alta carga en el sistema; se intenta ejecutar otra táctica que consiste en agregar un servidor más en pos de
			mejorar el \emph{concern} tiempo de respuesta. Si luego de esperar 2 segundos para que los efectos de la táctica
			puedan verse reflejados en el sistema, no hay más alta carga, la estrategia se considera exitosa, caso contrario, la
			misma se considera fallida.

		\subsubsection{EMA: Suavizando el Comportamiento}
		\label{sec:exponentialAverage}

			El proceso de adaptar un sistema de manera dinámica puede llegar a ser muy costoso, por ejemplo, en un sistema
			cliente-servidor, el asignar más servidores para atender las peticiones de los usuarios implica normalmente un coste
			monetario no despreciable. Otro ejemplo podría ser el suspender temporalmente la reproducción de videos en un sitio
			de noticias. Si bien esta decisión puede servir para disminuír el tiempo de respuesta experimentado por los usuarios
			en un contexto de alta carga, también provoca una clara disminución en la calidad del servicio ofrecido. Estos
			ejemplos concretos sirven para inferir que el disparar un mecanismo de auto reparación en un sistema debe ser una
			decisión tomada con cierta cautela y en base a datos confiables y sostenidos en el tiempo.
			
			Hemos visto anteriormente, de manera somera, de que manera Rainbow (mediante estrategias y tácticas definidas en el
			lenguaje Stitch) utiliza datos sobre el sistema en ejecución para decidir el mejor camino a tomar para adaptar el
			sistema a los requerimientos de atributos de calidad correspondientes. Consideremos un escenario dónde una estrategia
			debe decidir si el último paso ejecutado fue exitoso o no. Para eso, deberá consultar una o más propiedades del
			sistema en ejecución, los cuáles, podrían llegar a no ser representativos del entorno \emph{real} en que el sistema
			se encuentra ejecutando; debido a la presencia de algunos pocos valores considerablemente distintos del resto de los
			datos recientes \emph{históricos} que se usan para tomar decisiones (\emph{outliers}).
			
			Rainbow implementa un mecanismo que permite evitar accionamientos prematuros de la auto reparación debido a la
			presencia de \emph{outliers}. El mentado mecanismo utiliza \emph{Exponential Moving Average} (EMA)\footnote{Para
			más información, visitar\\
			\url{http://en.wikipedia.org/wiki/Exponential_moving_average\#Exponential_moving_average}}, que permite ponderar los
			valores históricos de la(s) propiedad(es) del sistema que se consultan para tomar decisiones. La función de suavizado
			que implementa esta heurística se define inductivamente de la siguiente manera:

			\begin{equation}
				S_0 = Y_0
			\end{equation}
			\begin{equation}
				S_t = \alpha \times Y_t + (1-\alpha) \times S_{t-1}
			\end{equation}

			donde $\alpha$ se denomina \textbf{factor de suavizado} y $0 < \alpha < 1$.
			
			El valor suavizado $S_t$ no es ni más ni menos que un promedio ponderado de la última observación $Y_t$ y el valor
			suavizado previo $S_{t-1}$.
			
			Notar que con valores \emph{altos} de $\alpha$, el último valor observado tendrá más preponderancia que el valor
			histórico (suavizado) anterior. Por el contrario, con un $\alpha$ tendiendo a cero, la última observación de una
			propiedad de la arquitectura no tendrá mucha relevancia en el valor promedio $S_t$. No existe un procedimiento formal
			para determinar el valor de $\alpha$, en el caso particular de las pruebas realizadas en este trabajo, se ha elegido
			$\alpha = 0.3$, es decir que, se ponderará con un 30\% al último valor observado mientras que el valor histórico
			tendrá un peso del 70\%; con esto nos aseguramos que los valores de las propiedades del sistema que son relevantes
			para la auto adaptación no fluctúen bruscamente debido a unos pocos \emph{outliers}.

	\subsubsection{Znn: Evaluando la Efectividad de Rainbow}

		Znn es un sistema que simula un sitio web de noticias, el cual nació en el contexto de la tesis de doctorado
		\cite{TesisOwen} de un investigador de la universidad de Carnegie Mellon, Shang-Wen Cheng. En dicha tesis, se
		evalúa a Rainbow en los siguientes aspectos:
		\begin{itemize}
			\item su efectividad para mantener los atributos de calidad ante condiciones cambiantes.
			\item la sobrecarga de procesamiento que implica la auto reparación.
			\item el esfuerzo que implica agregar auto reparación mediante Rainbow a Znn.
		\end{itemize}

		Si bien Znn y sus herramientas asociadas (\emph{probes}, \emph{gauges}, tácticas, estrategias, etc.) nacieron con
		el único objetivo de evaluar la efectividad de Rainbow, las mismas han sido abiertas a la comunidad para que puedan
		ser utilizadas para tomar métricas y poder comparar distintos sistemas de auto reparación.

		Znn provee un entorno de simulación de una arquitectura cliente servidor ampliamente configurable que permite
		representar situaciones y controlar las variables de simulación permitiendo modificarlas en cualquier punto de ésta
		última.
		
		Por ejemplo, es posible configurar a Znn para que inicie con solamente 2 clientes, mostrando allí un desempeño
		aceptable y que luego se agreguen 10 clientes, comprometiendo así la \emph{performance} del mismo. De esta manera, Znn
		permite simular como responderían las estrategias implementadas ante dicha situación.

		Rainbow soporta dos modos de ejecución: el normal, con un sistema real conectado al mismo ó un modo de simulación, el
		cuál permite utilizar, por ejemplo, las herramientas provistas por Znn. En el presente trabajo se utilizará el modo
		simulación para los casos de prueba, tomando las estrategias y tácticas provistas por Znn. Éstas debieron ser
		adaptadas para que puedan seguir funcionando con los cambios propuestos en el presente trabajo.

	\subsection{Escenarios de Atributos de Calidad}
		\label{sec:QAS}

		\todo{TASK: Extender definición de Escenarios de Atributos de Calidad (poco, está casi OK así)}

		\todo{tomar info de acá que está muy bueno y conciso:
		\url{http://etutorials.org/Programming/Software+architecture+in+practice,+second+edition/Part+Two+Creating+an+Architecture/Chapter+4.+Understanding+Quality+Attributes/4.3+System+Quality+Attributes/}}

		Los atributos de calidad pueden ser representados mediante escenarios. Los escenarios están compuestos por:

		\begin{itemize}
			\item \textbf{Fuente del estímulo}: Interna o externa \todo{mejorar esta explicación}
			\item \textbf{Estímulo}: condición que debe ser tenida en cuenta al llegar al sistema
			\item \textbf{Entorno}: condiciones en las cuales ocurre el estímulo
			\item \textbf{Artefacto}: el sistema o partes de él afectadas por el estímulo
			\item \textbf{Respuesta}: qué hace el sistema ante la llegada del estímulo
			\item \textbf{Medición de la respuesta}: cuantificación de un atributo de la respuesta
		\end{itemize}

		\begin{figure}[h]
			\centering
				\includegraphics{images/scenario.png}
			\caption{Visión gráfica de un escenario}
			\label{fig:scenario}
		\end{figure}

		Los escenarios son pequeñas historias que describen una interacción con el sistema, que impacta sobre un atributo de
		calidad en particular. Por ejemplo, un escenario sobre disponibilidad podría ser:
			\begin{quote}
			``Un proceso del sistema recibe un mensaje externo no anticipado durante un modo de operación normal. El proceso
			informa al operador y continúa su operación sin caídas.''
			\end{quote}

		Este escenario se descompone de la siguiente manera:
		\begin{itemize}
			\item \textbf{Fuente del estímulo}: Sistema externo
			\item \textbf{Estímulo}: Mensaje no anticipado
			\item \textbf{Entorno}: Operación normal
			\item \textbf{Artefacto}: Proceso interno
			\item \textbf{Respuesta}: Informar al operador y seguir operando
			\item \textbf{Medición de la respuesta}: sin caídas (downtime)
		\end{itemize}

		Los escenarios permiten obtener el punto de vista de un grupo diverso de \emph{stakeholders} (arquitectos,
		desarrolladores, usuarios, sponsors, etc). Estos escenarios pueden luego ser utilizados para analizar la arquitectura
		del sistema e identificar concerns y posibles estrategias para atacar problemas.


		\subsubsection{QAW}
		\todo{fuente de lo que sigue: http://www.sei.cmu.edu/architecture/tools/qaw/index.cfm}

		Existe una metodología definida por el Software Engineering Institute (SEI) conocida como \textbf{Quality Attribute
		Workshop (QAW)}, cuya principal herramienta son los escenarios. Esta metodología provee un método para identificar los
		atributos de calidad críticos de la arquitectura de un sistema, tales como disponibilidad, \emph{performance},
		seguridad, etc, que son derivados de objetivos del negocio del sistema. QAW no asume la existencia de una arquitectura
		del software, sino que fue desarrollado como consecuencia de la necesidad de \emph{stakeholders} y arquitectos de un
		método que permita identificar los atributos de calidad importantes para el correcto funcionamiento del sistema antes de
		que su arquitectura estuviese definida.

		QAW consiste en reuniones en las que participan todos los \emph{stakeholders} del sistema, en las que se definen los
		escenarios que en definitiva representarán los requerimientos de atributos de calidad que el sistema idealmente deberá
		satisfacer. Una vez definidos todos los escenarios, el siguiente paso del QAW consiste en priorizar y refinar los
		escenarios, por ejemplo agregando detalles adicionales tales como los participantes involucrados, la secuencia de
		actividades, y preguntas sobre el requerimiento que representa cada escenario. El proceso de refinar los escenarios
		permite a los \emph{stakeholders} comunicarse entre ellos, exponiendo supuestos que pueden no ser tan claros para el
		resto de los participantes. Dicho refinamiento también proporciona una visión de cómo interactúan los atributos
		de calidad entre sí, sirviendo de base para definir \emph{tradeoffs} entre estos atributos.

		El proceso QAW termina con la lista de escenarios refinados y priorizados. Los mismos pueden servir para definir casos
		de pruebas, o como semillas para el proceso ATAM.
		
		Si bien no es requisito excluyente utilizar la metodología QAW para poder emplear Arco Iris, su uso es recomendado ya
		que hará uso intensivo de los escenarios de atributos de calidad, y de su correcta definición dependerá el nivel de 
		optimización y flexibilización que Arco Iris puede alcanzar al auto reparar un sistema.

	\subsection{ATAM}
	\label{sec:atam}
		\todo{fuente: svn/doc/atam/ATAM Method for Architecture Evaluation.pdf}

		\todo{TASK: Extender definición de ATAM, poner grafiquito, poner foco en la parte de sensitivity point y tradeoff
		point que son los que nos sirven. Poner un ejemplo de c/u.}

		ATAM (Architecture Tradeoff Analysis Method) ha sido desarrollado por el SEI, al igual que QAW, y es una técnica que
		permite analizar arquitecturas de software. Las arquitecturas son complejas, e involucran muchos tradeoffs de diseño.
		Sin un proceso de análisis formal, no se puede estar seguro de que las decisiones de arquitectura tomadas - en
		particular aquellas que afectan el cumplimiento de requerimientos de calidad como \emph{performance}, disponibilidad,
		seguridad y modificabilidad - son adecuadas para mitigar los riesgos.

		El nombre ATAM proviene no solo del hecho de que refleja cuán bien una arquitectura satisface objetivos de calidad
		específicos, sino también del hecho de que provee una visión de cómo esos objetivos de calidad interactúan entre sí,
		esto es lo que conocemos como tradeoffs.

		La meta de evaluar una arquitectura con ATAM es entender las consecuencias de las decisiones arquitectónicas con
		respecto a los requerimientos de atributos de calidad del sistema. Otro objetivo fundamental de ATAM es determinar si
		dichos requerimientos pueden ser alcanzados con la arquitectura concebida, antes de destinar grandes cantidades de
		recursos a la construcción del software.

		ATAM es un método estructurado y repetible, ayudando así a que las preguntas correctas sobre la arquitectura sean
		planteadas de manera temprana en el proyecto, durante las etapas de análisis de requerimentos y de diseño, en las
		cuales los problemas detectados pueden ser corregidos sin mayores costos. ATAM guía a los usuarios del método
		(\emph{stakeholders}) para que busquen conflictos en la arquitectura y soluciones a dichos conflictos.

		Cabe aclarar que los QAW han surgido como consecuencia del uso de ATAM, ya que usuarios de éste último solicitaban una
		herramienta o método que les permitiera identificar los requerimientos y los atributos de calidad más importantes del
		sistema, pero antes de que existiese la arquitectura sobre la cual ATAM trabajaría.

		\todo{Sensitivity points, tradeoffs, etc.}