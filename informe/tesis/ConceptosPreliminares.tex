\section{Conceptos Preliminares}

	\subsection{Sistemas Autónomos, Auto Adaptación, Auto Reparación\ldots}

 		A medida que va pasando el tiempo, los sistemas de software se vuelven cada vez más complejos y más exigentes en
		cuanto a disponibilidad se trata. Hoy en día los mismos operan en ambientes dinámicos, con requerimientos de usuario
		altamente cambiantes y con la necesidad de operar prácticamente sin interrupción, resultando esto en un aumento
		en la administración operativa del software, lo cual representa un costo importante para que el sistema pueda
		mantenerse operativo. Para reducir este costo, se puede plantear que los sistemas se adapten de manera dinámica para
		poder utilizar los recursos existentes, a fin de poder atender los cambiantes requerimientos de atributos de
		calidad, así también como los errores en el sistema. De forma genérica, a los sistemas de software que cumplen con
		estas características, se los denomina \textbf{Sistemas Autónomos}.
		
		Hilando más fino en la caracterización de sistemas autónomos, encontramos términos en inglés como \emph{Self
		Configuring} o \emph{Self Adapting} para referirse a sistemas autónomos que tienen la capacidad de auto configurarse
		(o auto adaptarse) a condiciones cambiantes en el entorno de ejecución del sistema.
		
		Por otro lado, cuando la adaptación dinámica del sistema responde a errores o situaciones excepcionales del
		mismo, el término más utilizado actualmente es \emph{Self Healing} o, en castellano, Auto Reparación.

		Si bien ya existen mecanismos para mitigar los mencionados problemas, ellos normalmente están intrínsecamente ligados
		al lenguaje de programación utilizado para construír la aplicación, tales como tratamiento de excepciones, protocolos de
		tolerancia a fallos, etc. Además, estos mecanismos generalmente dependen del código de la aplicación que se intenta
		adaptar y consecuentemente, no son fácilmente reutilizables entre distintos sistemas. En resúmen: hoy en día, la
		adaptación de sistemas de software es costosa de construir, dificil de modificar, poco reusable y generalmente solo
		provee soluciones a fallos de manera puntual.

		En cuanto al estado del arte en materia de sistemas autónomos existen diversos enfoques tanto en el ámbito académico
		como en la industria del software.

		Dentro del ámbito de la industria, el concepto de sistemas autónomos se encuentra ampliamente difundido. Sin dudas, el
		enfoque de IBM, denominado ``Autonomic Computing'' \cite{IBM-AC} es el más completo, apalancado por un gran grupo de
		investigación y abarcando el problema desde distintos aspectos. También se destaca la iniciativa de Microsoft
		denominada ``Dynamic Systems Initiative'', y no tanto la iniciativa de Sun (``Predictive Self-Healing'' y
		``Conscientious Software''), por estar más ligada a adaptar el enfoque al dominio de los sistemas operativos. Para más
		información sobre estos enfoques, remitirse a \cite{Casuscelli}

		Por otro lado, existen distintos investigadores ligados a prestigiosas instituciones académicas abocados al estudio de
		distintos aspectos de la autonomía de los sistemas. Uno de los primeros investigadores en acuñar el término ``Self
		Healing'' fue el Dr. David Garlan, de la Universidad de Carnegie Mellon, quien formó un grupo de investigación que
		dedicó años a estudiar el tema dentro del marco del proyecto ABLE.\footnote{El proyecto ABLE (\emph{``Architecture
		Based Languages and Environments''}) de la Universidad de Carnegie Mellon lleva a cabo investigaciones que conducen a
		una base de ingeniería para la arquitectura de software. Para más información, visitar
		\url{http://www.cs.cmu.edu/~able}}
		
		El presente trabajo toma como base el trabajo generado por el proyecto ABLE de Carnegie Mellon, el cual implementa
		el concepto de ``Auto Reparación de Sistemas Basada en Modelos de Arquitectura'', el cual se describirá en detalle a
		continuación.

	\subsubsection{Auto Reparación de Sistemas Basada en Modelos de Arquitectura}
	\label{sec:ARSBMA}
		
		En contraste con los mecanismos tradicionales para detección y recuperación de errores que se implementan como parte
		del código específico de la aplicación, con mecanismos localizados y poco escalables entre distintos sistemas; el
		enfoque propuesto por el Dr. David Garlan, usa \textbf{el modelo de la arquitectura} del sistema que se desea adaptar
		como instrumento para razonar sobre sus propiedades (e.g. tiempo de respuesta de un servidor) y sus correlatos
		con la dinámica del sistema en tiempo de ejecución.
		
		Diversos investigadores han propuesto usar modelos arquitecturales \cite{ArchBasedApproach} que representan al
		sistema como una mera composición de componentes, sus interconexiones (conectores) y sus propiedades de
		interés. Este modelo es conocido comunmente como \textbf{C\&C} (componentes y conectores)\cite{C&C}. Tal propuesta
		ofrece diversos beneficios, el más significativo: un modelo arquitectural abstracto provee una perspectiva global del
		sistema y expone sus propiedades y restricciones de integridad.

		La idea propuesta consiste básicamente en un bucle cerrado (\emph{closed-loop} en inglés), donde existen dos capas
		(externas al sistema que está siendo ejecutado) que actúan, una encargada del monitoreo del sistema y la otra
		proveyendo un mecanismo de control y adaptación. Esto ofrece una solución mas efectiva que cualquier mecanismo interno
		porque permite agrupar todo lo concerniente a la detección y solución del problema en módulos separados, pudiendo ser
		analizados, modificados, extendidos y reutilizados a través de distintos sistemas.

		\begin{figure}[h]
			\centering
				\includegraphics{images/selfhealing-closed-loop.png}
			\caption{Bucle cerrado}
			\label{fig:selfhealing-closed-loop}
		\end{figure}

		Otro sub-proyecto del proyecto ABLE, denominado \textbf{Rainbow} (sobre el cual profundizaremos más adelante) utiliza
		esta técnica de \emph{closed-loop} para monitorear y reparar sistemas.

	\subsection{Lenguajes de Descripción de Arquitecturas}

		Un problema fundamental en el diseño de arquitecturas de sistemas utilizando el estilo de componentes y
		conectores ha sido encontrar la notación apropiada para definir dichas arquitecturas.

		Un buen lenguaje para describir arquitecturas debería permitir generar una documentación clara sobre los componentes
		de la arquitectura, que luego servirá como base a los de\-sa\-rro\-lla\-do\-res, permitiendo a su vez razonar sobre
		las propiedades del sistema y automatizar su análisis, hasta pudiendo quizás llegar a utilizarse para la generación
		automática de parte del código que implementará la arquitectura. También debería ser efectivo para poder validar de
		manera temprana decisiones arquitectónicas, reduciendo así el tiempo de implementación y evitando utilizar
		ineficientemente recursos en el desarrollo del sistema.

		Una forma de describir dichas arquitecturas es mediante el modelado de objetos mediante UML, si bien este método ha
		sido ampliamente aceptado y utilizado en la industria, tiene varios inconvenientes, el más importante e
		invalidante es que no provee un soporte directo para describir propiedades no funcionales, esto hace dificultoso
		razonar sobre propiedades críticas del sistema, como por ejemplo la \emph{performance} o la confiabilidad. Ésta es la
		razón principal que ha motivado el avance de los ADLs (\emph{Architecture Description Languages}). Para más
		información sobre la discusión ADL's vs. UML, remitirse a \cite{ADLsVsUML}.

		La descripción de arquitecturas de sistemas basada en ADLs ha avanzado considerablemente en las últimas dos décadas,
		al punto de que ya permiten definir una base formal para su descripción y análisis.

	\subsubsection{Acme}
	\label{sec:acme}

		Acme\cite{ACME} es uno de los ADLs más reconocidos y utilizados, ha sido desarrollado en la universidad de Carnegie
		Mellon, más precisamente por el proyecto ABLE, liderado por el Dr. David Garlan.

		Acme es un pilar fundamental dentro del proyecto ABLE, ya que todo el proyecto gira en torno a la arquitectura de
		software de los sistemas, y es Acme quien permite describir formalmente dichas arquitecturas, por lo tanto todos los
		restantes sub proyectos utilizan Acme en menor o mayor medida.

		Además de los beneficios de todo ADL, el lenguaje Acme y su kit de herramientas \emph{AcmeLib (Acme Tool Developer's
		Library)} proveen las siguientes capacidades fundamentales:

		\begin{itemize}
			\item Intercambio Arquitectural: al proveer un formato de intercambio genérico para diseñar arquitecturas de
			software, Acme permite a los desarrolladores de herramientas de este tipo \footnote{Ejemplos de herramientas de
			descripción de arquitecturas y modelado UML podrían ser: Enterprise Architect (\url{http://www.sparxsystems.com.au/})
			o Poseidón (\url{http://www.gentleware.com/}), entre tantas otras.} integrar fácilmente con otras herramientas
			complementarias. De esta manera, los arquitectos que usan herramientas basadas en Acme tienen un espectro más amplio
			de herramientas de	análisis y diseño que quienes diseñan sus arquitecturas usando otros ADLs.
			\item Extensibilidad: Acme provee una base sólida, genérica y extensible, y una infraestructura que evita que los
			desarrolladores vuelvan a construir herramientas de base. Más aún, debido a su idea originaria de lenguaje de
			intercambio genérico, Acme permite que las herramientas que se han desarrollado utilizándolo sean compatibles con una
			gran variedad ADLs existentes y con herramientas con un mínimo esfuerzo, y hasta en algunos casos sin esfuerzo alguno.
		\end{itemize}

		Actualmente, el lenguaje Acme y \emph{Acme Tool Developer's Library (AcmeLib)}, proveen una infraestructura genérica y
		extensible para describir, representar, analizar y generar descripciones de arquitecturas de software.

		A continuación, observamos un breve ejemplo de una arquitectura modelada en el lenguaje ACME, la cual posee un
		sistema que contiene:
		\begin{itemize}
			\item un servidor HTTP, con algunas propiedades como por ejemplo fidelidad del contenido que provee.
			\item un cliente HTTP, también con algunas propiedades particulares como el tiempo de respuesta experimentado por el
			usuario.
		\end{itemize}

		\begin{Verbatim}[gobble=3]
			System system : ClientServerType = {
			    Component server : ServerT = new ServerT extended with {
			        Port http0 : HttpPortT;
			        Property cost;
			        Property fidelity;
			        Property load;
			    }
			    Component client : ClientT = new ClientT extended with {
			        Port p0 : HttpReqPortT = new HttpReqPortT extended with {
			            Property isArchEnabled = true;
			        }
			        Property deploymentLocation = "127.0.0.1";
			        Property isArchEnabled = true;
			        Property experRespTime;
			    }
			}
		\end{Verbatim}

		Más adelante, en la sección \ref{sec:casosPracticos}, veremos otro ejemplo (más extenso) del lenguaje al mostrar la
		descripción completa en Acme de la arquitectura del sistema que utilizaremos para mostrar los resultados de la extensión
		implementada en el presente trabajo.

	\subsection{Rainbow}

		\subsubsection{Introducción a Rainbow}

			La herramienta Rainbow, también dentro del marco del proyecto ABLE, tiene como finalidad permitir reducir el costo e
			incrementar la confiabilidad al realizar cambios en sistemas complejos de software, para esto Rainbow automatiza la
			adaptación de sistemas de software a traves de sus modelos de arquitectura, tal cual fue descrito en la sección
			\ref{sec:ARSBMA}.

			Sin bien en principio el enfoque de auto adaptación basado en arquitecturas es atractivo, el mismo supone un número
			significativo de desafíos en el campo de la investigación así también como en el de la ingeniería:

			\begin{itemize}
				\item En primer lugar, uno de los aspectos claves que Rainbow intenta cubrir es la habilidad de manejar una amplia
				variedad de sistemas con arquitecturas, propiedades de interés y mecanismos que soporten modificaciones dinámicas
				completamente diferentes.
								
				\item Por otro lado, Rainbow intenta ser una solución que permita reducir el costo de agregar control externo al
				sistema a reparar, puesto que crear los me\-ca\-nis\-mos de monitoreo y detección de
				problemas desde cero para un sistema nuevo sería prohibitivamente costoso. El enfocar la auto reparación de un
				sistema en su arquitectura permite disponer de una infraestructura reutilizable junto con mecanismos para adaptar
				dicha infraestructura a las necesidades específicas de cada sistema.
			\end{itemize}
	
			Cabe mencionar que el caracter externo y no intrusivo de Rainbow representa una ventaja también cuando se
			desea implementar auto reparación en sistemas cuyo código fuente no está disponible o no es plausible de ser
			modificado.
	
				
			\subsubsection{Arquitectura de Rainbow}
		
				La Figura \ref{fig:Rainbow_Framework} muestra el ciclo de control cerrado de Rainbow para implementar auto
				adaptación. Rainbow usa un modelo arquitectural abstracto para monitorear las propiedades en \emph{runtime} del
				sistema que está siendo ejecutado, evalúa el modelo para detectar violaciones en restricciones impuestas sobre el
				mismo y, si un problema ocurre, lleva a cabo adaptaciones en el sistema que se está ejecutando.
	
				\begin{figure}[H]
					\centering
						\includegraphics{images/Rainbow_Framework.png}
					\caption{Arquitectura de Rainbow}
					\label{fig:Rainbow_Framework}
				\end{figure}

			
				Rainbow está dividido básicamente en dos grandes partes:
				\begin{itemize}
					\item la \textbf{infraestructura de adaptación} la cual se divide a su vez en capas de \textbf{sistema},
					\textbf{arquitectura} y \textbf{traducción}, las cuales proveen funcionalidades comunes a distintos sistemas auto
					adaptables logrando por lo tanto el objetivo de disponer de componentes reutilizables.
					\item el \textbf{conocimiento específico sobre adaptación}:  típicamente no es reutilizable entre distintos
					sistemas.
				\end{itemize}

			\todo{mover las siguientes 4 secciones al itemizado anterior y traducir todo}
	
			\subsubsection{Capa de Sistema}
				
				En esta capa se define e implementa una interfaz de acceso al sistema que está siendo ejecutado. Se define un
				mcanismo para medir variables de interés en el sistema, materializado en \emph{probes}: componentes que observan y
				miden diversos estados del sistema, para luego publicarlos.
				
				Additionally, a resource discovery mechanism can be queried for new resources based on resource type and other
				criteria. Finally, an effector mechanism carries out the actual system modification.
				
			\subsubsection{Capa de Arquitectura}
				
				At this layer, gauges aggregate information from the probes and update the appropriate properties in the
				architectural model. A model manager handles and provides access to the system's architectural model. A constraint
				evaluator checks the model periodically and triggers adaptation if a constraint violation occurs. An adaptation
				engine then determines the course of action and carries out the necessary adaptation.
				
			\subsubsection{Capa de Traducción}
				
				This infrastructure helps mediate the mapping of information across the abstraction gap from the system to the model
				and vice versa. A translation repository within the infrastructure maintains various mappings that the translator
				components share, for example, to translate an architectural-level element identifier into an IP address or an
				architectural-level change operator into system-level operations.
				
			\subsubsection{Conocimiento específico del sistema sobre adaptación}
				
				Adding self-adaptation to a system using the functionalities that the adaptation infrastructure provides requires
				using the system-specific adaptation knowledge to tailor that infrastructure. This knowledge includes the target
				system's operational model, which defines parameters such as component types and properties, behavioral constraints,
				and adaptation strategies.

			\todo{mencionar que está hecho en Java y como obtener el código}
			desarrollada en el lenguaje de programación Java\textsuperscript{\texttrademark}

		\subsubsection{Tácticas y Estrategias}
		
			\todo{agregar ejemplo de estrategia, tomarlo de algun newssiteStrategies.s}

			El objetivo de la auto reparación será alcanzar determinados atributos de calidad, pero ¿Cómo haremos para alcanzar
			dichos atributos? En el libro \textbf{Software Arquitectura in Practice} \cite{BassClementz}, Bass, Clements y Kazman
			presentan dos conceptos que nos permiten alcanzar los objetivos del sistema y que han sido ampliamente adoptados en
			la industria, estos conceptos son: tácticas y estrategias.

			Allí se definen las tácticas como una decisión de diseño que influye sobre la respuesta de un atributo de
			calidad, mientras que definen a una estrategia como una colección de tácticas. La figura
			\ref{fig:tactics_control_to_response} muestra gráficamente la visión de las tácticas presentada por los autores.

			\begin{figure}[h]
				\centering
					\includegraphics{images/tactics_control_to_response.png}
				\caption{Visión gráfica del concepto de táctica}
				\label{fig:tactics_control_to_response}
			\end{figure}

			Las tácticas son herramientas que los arquitectos de software han utilizado durante años, en el libro mencionado
			simplemente se las aisla y se las describe, no pretende proclamar la invención de las tácticas sino más bien darle un
			nombre y organizar los patrones comunes utilizados en cuanto a decisiones de arquitectura y clasificarlos. Cada
			táctica	es una opción de diseño para el arquitecto, por ejemplo, introducir redundancia para incrementar la
			disponibilidad del	sistema. En resumen, en el libro se plantea que las estrategias afectan los atributos de calidad
			del sistema, y que	estos proveen a los \emph{stakeholders} de cierto beneficio, al cual llaman utilidad. Cada
			estrategia provee un nivel	específico de utilidad, pero en contrapartida presentan un costo en tiempo y en dinero.
			Por estos motivos se aconseja hacer participar a los \emph{stakeholders} a la hora de decidir qué estrategias se
			emplearán para satisfacer los atributos de calidad definidos para el sistema. Ellos deberán evaluar el retorno de la
			inversión (el ratio entre el beneficio y el costo) de aplicar cada estrategia para elegir la más conveniente.

			La estrategia es la herramienta propuesta por Rainbow para quitar al sistema de un estado indeseable. Por ejemplo, al
			verse la performance del sistema comprometida, una estrategia podría agregar servidores hasta llevar la performance a
			un nivel adecuado.

			Las estrategias son desarrolladas para un \emph{concern} específico. Un \emph{concern} de un sistema abarca un
			subconjunto de propiedades del sistema, como por ejemplo performance, costo o confiabilidad. En una arquitectura
			cliente-servidor, el \emph{concern} performance abarcaría las propiedades ancho de banda y carga del sistema,
			mientras que el \emph{concern} costo se encargaría del costo de los servidores.

			Las estrategias se componen de tácticas, las cuales realizan la modificación en el sistema. Por ejemplo, una
			estrategia podría ser: agregar servidores mientras haya disponible, o hasta que el tiempo de respuesta haya alcanzado
			un	determinado valor. Esta lógica sería descripta en la estrategia, mientras que va a ser la táctica
			levantar-servidor la responsable de ejecutar la acción propiamente dicha, a la cual se la llama \textbf{operador}.

			\todo{TASK: Explicar Stitch con más detalle}

			Rainbow provee un lenguaje de scripting llamado \textbf{Stitch}, pensado para permitir plasmar el conocimiento
			rutinario de las personas sobre adaptación de sistemas de software. Tanto las tácticas como las estrategias serán
			descriptas utilizando Stitch. Ofrece modularidad con respecto a las dimensiones de los atributos de calidad y al
			dominio, permite especificar estrategias de múltiples pasos con condiciones de aplicabilidad y efectos deseados y
			provee	un mecanismo para extender las políticas de adaptación a dominios específicos de sistemas.

		\subsubsection{EMA: Suavizando el Comportamiento}
		\label{sec:exponentialAverage}

			El proceso de adaptar un sistema de manera dinámica puede llegar a ser muy costoso, por ejemplo podría requerir
			asignar más servidores a atender las peticiones de los usuarios, con el respectivo coste monetario que esto podría
			llegar a implicar, también podría significar una merma en la calidad del servicio ofrecido, por ejemplo eliminando
			temporalmente la posibilidad de que los usuarios pueden visualizar los videos de un sitio de noticias. Esto hace que
			lanzar la auto reparación de un sistema deba ser una decisión tomada con cierta cautela y en base a datos confiables
			y sostenidos en el tiempo. Rainbow implementa un mecanismo que permite evitar accionamientos prematuros de la auto
			reparación por la presencia de \emph{outliers}, dicho mecanismo utiliza Exponential Moving Average (EMA), que permite
			ponderar los valores históricos versus el actual basándose en la siguiente fórmula:

			\todo{Ceria: Esto queda medio descolgado acá. Falta bastante detalle de rainbow... el típico grafiquito de su
			arquitectura por ejemplo}

			\begin{equation}
				S_{0} = Y_{0}
			\end{equation}
			\begin{equation}
				S_{t} = \alpha \times Y_{t} + (1-\alpha) \times S_{t-1}
			\end{equation}

			donde $\alpha$ es el factor de suavizado, siendo $0 < \alpha < 1$. En otras palabras, el valor suavizado \smash{$S_{t}$}
			es un simple promedio ponderado de la última observación \smash{$Y_{t}$} y el valor suavizado previo \smash{$S_{t-1}$}.
			El nombre factor de suavizado no es un nombre especialmente adecuado ya que en realidad a mayor $\alpha$ menor
			será el suavizado del promedio, mientras que valores cercanos a cero harán que el promedio se vea menos afectado por
			el nuevo valor observado. No existe un procedimiento formal para determinar el valor de $\alpha$, en el caso de
			Rainbow el valor escogido para las pruebas realizadas ha sido 0.3.

	\subsubsection{Znn: Evaluando la Efectividad de Rainbow}

		Znn es un sistema que simula un sitio web de noticias, el cual nació como proyecto de tesis de doctorado
		\cite{TesisOwen} de un investigadora de Carnegie Mellon, Shang-Wen Cheng. Sus objetivos fueron evaluar la efectividad
		de Rainbow en los siguientes aspectos:
		\begin{itemize}
			\item su efectividad para mantener los atributos de calidad al enfrentar condiciones cambiantes
			\item el \emph{overhead} de procesamiento que implica la auto reparación
			\item el esfuerzo que implica agregar auto reparación mediante Rainbow a Znn
		\end{itemize}

		Si bien Znn nació como herramienta para evaluar Rainbow, Znn y las herramientas asociadas utilizadas para evaluar
		Rainbow han sido abiertas a la comunidad para que puedan ser utilizadas para tomar métricas y poder comparar distintos
		sistemas de auto reparación.

		Znn provee un entorno de simulación de una arquitectura cliente servidor ampliamente configurable que permite
		representar situaciones y controlar las variables de simulación permitiendo modificarlas en cualquier punto de la
		simulación. Por ejemplo, el sistema que se está simulando podría comenzar con solamente 2 clientes, mostrando allí una
		performance aceptable, pero a partir de un momento dado, se agregan 10 clientes comprometiendo así la performance del
		mismo. De esta manera permite simular como responderían las estrategias implementadas ante dicha situación.

		En el presente trabajo se utlizará el modo simulación para realizar los casos de prueba, tomando las estrategias y
		tácticas de Znn. Éstas debieron ser adaptadas para que puedan continuar funcionando con los cambios propuestos en la
		tesis.

	\subsection{Escenarios de Atributos de Calidad y QAW}
		\label{sec:QAS}

		\todo{TASK: Extender definición de Escenarios de Atributos de Calidad (poco, está casi OK así)}

		Los atributos de calidad representan los requerimientos no funcionales de un sistema, y suelen estar pobremente
		especificados, o directamente no especificados (``un requerimiento que no es testeable no es implementable'').

		Los atributos de calidad pueden ser representados mediante escenarios. Los escenarios están compuestos por:

		\begin{itemize}
			\item \textbf{Fuente del estímulo}: Interna o externa \todo{mejorar esta explicación}
			\item \textbf{Estímulo}: condición que debe ser tenida en cuenta al llegar al sistema
			\item \textbf{Entorno}: condiciones en las cuales ocurre el estímulo
			\item \textbf{Artefacto}: el sistema o partes de él afectadas por el estímulo
			\item \textbf{Respuesta}: qué hace el sistema ante la llegada del estímulo
			\item \textbf{Medición de la respuesta}: cuantificación de un atributo de la respuesta
		\end{itemize}

		\begin{figure}[h]
			\centering
				\includegraphics{images/scenario.png}
			\caption{Visión gráfica de un escenario de QAW}
			\label{fig:scenario}
		\end{figure}

		Los escenarios son pequeñas historias que describen una interacción con el sistema, que impacta sobre un atributo de
		calidad en particular. Por ejemplo, un escenario sobre disponibilidad podría ser:
			\begin{quote}
			``Un proceso del sistema recibe un mensaje externo no anticipado durante un modo de operación normal. El proceso
			informa al operador y continúa su operación sin caídas.''
			\end{quote}

		Este escenario se descompone de la siguiente manera:
		\begin{itemize}
			\item \textbf{Fuente del estímulo}: Sistema externo
			\item \textbf{Estímulo}: Mensaje no anticipado
			\item \textbf{Entorno}: Operación normal
			\item \textbf{Artefacto}: Proceso interno
			\item \textbf{Respuesta}: Informar al operador y seguir operando
			\item \textbf{Medición de la respuesta}: sin caídas (downtime)
		\end{itemize}

		Los escenarios permiten obtener el punto de vista de un grupo diverso de stakeholders (arquitectos, desarrolladores,
		usuarios, sponsors, etc). Estos escenarios pueden luego ser utilizados para analizar la arquitectura del sistema e
		identificar concerns y posibles estrategias para atacar problemas.

		\todo{fuente de lo que sigue: http://www.sei.cmu.edu/architecture/tools/qaw/index.cfm}

		Existe una metodología definida por el Software Engineering Institute (SEI) conocida como Quality Attribute Workshop
		(QAW), cuya principal herramienta son los escenarios. Esta metodología provee un método para identificar los atributos
		de calidad críticos de la arquitectura de un sistema, tales como disponibilidad, performance, seguridad, etc, que son
		derivados de objetivos del negocio del sistema. QAW no asume la existencia de una arquitectura del software, sino que
		fue desarrollado en base a reclamos de los clientes que necesitaban un método para identificar los atributos de
		calidad importantes, y aclarar requerimientos del sistema antes de que su arquitectura esté definida.

		En los QAW se organizan reuniones con todos los stakeholders del sistema, en las que se definen los escenarios que en
		definitiva representarán los requerimientos de atributos de calidad que el sistema idealmente deberá satisfacer. Un
		vez definidos todos los escenarios, el siguiente paso del QAW consiste en priorizar y refinar los escenarios, por
		ejemplo agregando detalles adicionales tales como los participantes involucrados, la secuencia de actividades, y
		preguntas sobre el requerimiento que representa cada escenario. El proceso de refinar los escenarios permite a los
		stakeholders comunicarse entre ellos, exponiendo supuestos que pueden no ser tan claros para el resto del grupo. Dicho
		refinamiento también proporciona una visión de cómo interactúan los atributos de calidad entre sí, sirviendo de base
		para definir tradeoffs entre estos atributos.

		El proceso QAW termina con la lista de escenarios refinados y priorizados. Los mismos pueden servir para definir casos
		de pruebas, o como semillas para el proceso ATAM.

	\subsection{ATAM}
	\label{sec:atam}
		\todo{fuente: svn/doc/atam/ATAM Method for Architecture Evaluation.pdf}

		\todo{TASK: Extender definición de ATAM, poner grafiquito, poner foco en la parte de sensitivity point y tradeoff
		point que son los que nos sirven. Poner un ejemplo de c/u.}

		ATAM (Architecture Tradeoff Analysis Method) ha sido desarrollado por el SEI, al igual que QAW, y es una técnica que
		permite analizar arquitecturas de software. Las arquitecturas son complejas, e involucran muchos tradeoffs de diseño.
		Sin un proceso de análisis formal, no se puede estar seguro de que las decisiones de arquitectura tomadas - en
		particular aquellas que afectan el cumplimiento de requerimientos de calidad como performance, disponibilidad,
		seguridad y modificabilidad - son adecuadas para mitigar los riesgos.

		El nombre ATAM proviene no solo del hecho de que refleja cuán bien una arquitectura satisface objetivos de calidad
		específicos, sino también del hecho de que provee una visión de cómo esos objetivos de calidad interactúan entre sí,
		esto es lo que conocemos como tradeoffs.

		La meta de evaluar una arquitectura con ATAM es entender las consecuencias de las decisiones arquitectónicas con
		respecto a los requerimientos de atributos de calidad del sistema. Otro objetivo fundamental de ATAM es determinar si
		dichos requerimientos pueden ser alcanzados con la arquitectura concebida, antes de destinar grandes cantidades de
		recursos a la construcción del software.

		ATAM es un método estructurado y repetible, ayudando así a que las preguntas correctas sobre la arquitectura sean
		planteadas de manera temprana en el proyecto, durante las etapas de análisis de requerimentos y de diseño, en las
		cuales los problemas detectados pueden ser corregidos sin mayores costos. ATAM guía a los usuarios del método
		(stakeholders) para que busquen conflictos en la arquitectura y soluciones a dichos conflictos.

		Cabe aclarar que los QAW han surgido como consecuencia del uso de ATAM, ya que usuarios de éste último solicitaban una
		herramienta o método que les permitiera identificar los requerimientos y los atributos de calidad más importantes del
		sistema, pero antes de que existiese la arquitectura sobre la cual ATAM trabajaría.

		\todo{Sensitivity points, tradeoffs, etc.}