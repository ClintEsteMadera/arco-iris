\section{Conceptos Preliminares}

	\subsection{Atributos de Calidad y Restricciones}
	 
		Desde hace unos años en la bibliografía de la Ingeniería de Software y más específicamente de la Ingeniería de
		Requerimientos se busca imponer el término \textbf{Atributos de Calidad} a las categorías de requerimientos que un
		sistema debe cumplir. Tradicionalmente los requerimientos eran divididos en \textbf{Requerimientos Funcionales} para
		referirse a la ``funcionalidad del negocio'' y \textbf{Requerimientos No Funcionales} para referirse a otros
		requerimientos como seguridad, \emph{performance}, usabilidad, escalabilidad, etc. Sin embargo, esta división resulta
		poco apropiada, dado que algunos de los llamados \textbf{Requerimientos No Funcionales} usualmente se terminan
		implementando con funcionalidad, como puede ser un módulo de autenticación para lograr seguridad. El término
		\textbf{Atributos de Calidad} aparece entonces como más general, y permite una clasificación más clara entre la
		funcionalidad y otros atributos. Algunos ejemplos de Atributos de Calidad son los siguientes:

		\begin{enumerate}
			\item \label{ejAtributoCalidad1} el sistema debe ser escalable con respecto a la cantidad de usuarios que lo utilizan
			concurrentemente.
			\item \label{ejAtributoCalidad2} el sistema debe implementar políticas de tolerancia a fallos.
			\item \label{ejAtributoCalidad3} el sistema debe ser diseñado de manera tal que se minimize el procesamiento y el
			tiempo de respuesta.
		\suspend{enumerate}

		Por otro lado, debemos tener en cuenta que al momento de diseñar una aplicación, el ingeniero de \emph{software} muchas
		veces está limitado en sus decisiones por distintos factores, a los cuales, en la terminología de la Ingeniería de
		Requerimientos, se los llama \textbf{Restricciones}. Algunos ejemplos de restricciones sobre un sistema de
		\emph{software} son los siguientes:

		\resume{enumerate}
			\item el código de la aplicación debe ser desarrollado en Java.
			\item la base de datos debe ser SQL Server.
			\item sólo se utilizarán productos de código abierto (\emph{open-source}).
		\end{enumerate}

		Es imprescindible conocer los Atributos de Calidad requeridos para un sistema a fin de poder diseñar la arquitectura
		del mismo. Notemos que, en los ejemplos de atributos de calidad (\ref{ejAtributoCalidad1}, \ref{ejAtributoCalidad2} y
		\ref{ejAtributoCalidad3}), los mismos se encuentran especificados de manera vaga e imprecisa. Esto es lo que suele
		ocurrir en la mayoría de los casos en la industria de desarrollo de \emph{software}. Notar también que los
		requerimientos \ref{ejAtributoCalidad1} y \ref{ejAtributoCalidad3} pueden llegar a afectarse mutuamente: esto también
		es muy común y para lograr un buen \emph{tradeoff} entre atributos de calidad los arquitectos suelen tener que tomar
		un conjunto de decisiones arquitectónicas llamadas \textbf{estrategias}, sobre las cuales profundizaremos en la
		sección \ref{sec:tacticasEstrategias}.

		\subsubsection{Atributos de Calidad y \emph{Concerns}}
		
			El estándar 1061-1998 de la IEEE \footnote{Para más información, visitar
			\url{http://standards.ieee.org/findstds/standard/1061-1998.html}} que establece una metodología para la definición de
			métricas con respecto a la calidad del \emph{software}, dice:
			
			\begin{quote}
				La calidad del \emph{software} es el nivel que posee de una combinación deseada de atributos (e.g. confiabilidad,
				interoperabilidad, \emph{performance}, etc.)
			\end{quote}
			
			Algunos ejemplos de atributos de calidad definidos en los estándares IEEE 1061 / ISO 9126
			\footnote{Para más información, visitar \url{http://es.wikipedia.org/wiki/ISO/IEC_9126}} son:
			\begin{itemize}
				\item Eficiencia
				\item Funcionalidad
				\item Mantenibilidad
				\item Portabilidad
				\item Confiabilidad
				\item Usabilidad
			\end{itemize}
			
			Imaginemos que el \emph{sponsor} de un sistema a ser desarrollado establece que el sistema debe ser ``eficiente''.
			¿Qué significa esto exactamente? La pregunta es difícil de contestar si no se dispone de más información.
			Evidentemente, los atributos de calidad son categorizaciones de alto nivel que, si no se dispone de más
			información, no parecen servir de mucho para tomar decisiones arquitectónicas en pos de alcanzar un
			nivel aceptable de dichos atributos de calidad. Al rescate de tal carencia aparecen las denominadas
			\textbf{Incumbencias} o, del inglés y tales como las llamaremos a lo largo de este trabajo, \textbf{Concerns}.
			
			Los \textbf{Concerns} son parámetros mediante los cuales los atributos de un sistema son juzgados, especificados y
			medidos. Usualmente, los requerimientos de atributos de calidad son expresados en términos de \emph{concerns}.
			\cite{QA}.
			
			A continuación, enumeraremos algunos ejemplos de \emph{concerns}, junto con el atributo de calidad al que pertenecen:
			
			\begin{center}
				\rowcolors*[\hline]{1}{GreenYellow!25}{GreenYellow!10}
				\begin{tabular}{|c|c|}
				\textbf{Atributo de Calidad} & \textbf{\emph{Concerns}}\\
				Eficiencia & Comportamiento Temporal, Utilización de Recursos\\
				Funcionalidad & Interoperabilidad, Seguridad\\
				Mantenibilidad & Cambiabilidad, Facilidad de Prueba\\
				Portabilidad & Adaptabilidad, Coexistencia\\
				Usabilidad & Compresibilidad, Atractivo			
				\end{tabular}
			\end{center}

			Los \emph{concerns} pueden usualmente relacionarse con propiedades de la arquitectura de un sistema, por ejemplo,
			en una arquitectura cliente-servidor, el atributo de calidad \emph{performance} posee varios \emph{concerns}
			asociados, por ejemplo, el \textbf{tiempo de respuesta}, el cuál está relacionado directamente con algunas
			propiedades de la arquitectura como el ancho de banda de los servidores, la carga del sistema, la cantidad de
			servidores, etc.
			
			Tanto los atributos de calidad como los \emph{concerns} son conceptos fundamentales en el presente trabajo, no sólo
			desde un punto de vista teórico sino que también serán utilizados en la práctica.
			
	\subsection{Sistemas Autónomos, Auto Adaptación, Auto Reparación\ldots}

 		A medida que va pasando el tiempo, los sistemas de software se vuelven cada vez más complejos y más exigentes en
		cuanto a disponibilidad se trata. Hoy en día los mismos operan en ambientes dinámicos, con requerimientos de usuario
		altamente cambiantes y con la necesidad de operar prácticamente sin interrupción, resultando esto en un aumento
		en la administración operativa del software, lo cual representa un costo importante para que el sistema pueda
		mantenerse operativo. Para reducir este costo, se puede plantear que los sistemas se adapten de manera dinámica para
		poder utilizar los recursos existentes, a fin de poder atender los cambiantes requerimientos de atributos de
		calidad, así también como los errores en el sistema. De forma genérica, a los sistemas de software que cumplen con
		estas características, se los denomina \textbf{Sistemas Autónomos}.

		Hilando más fino en la caracterización de sistemas autónomos, encontramos términos en inglés como \emph{Self
		Configuring} o \emph{Self Adapting} para referirse a sistemas autónomos que tienen la capacidad de auto configurarse
		(o auto adaptarse) a condiciones cambiantes en el entorno de ejecución del sistema.

		Por otro lado, cuando la adaptación dinámica del sistema responde a errores o situaciones excepcionales del
		mismo, el término más utilizado actualmente es \emph{Self Healing} o, en castellano, \textbf{Auto Reparación}.

		Si bien ya existen mecanismos para mitigar los mencionados problemas, ellos normalmente están intrínsecamente ligados
		al lenguaje de programación utilizado para construir la aplicación, tales como tratamiento de excepciones, protocolos
		de tolerancia a fallos, etc. Además, estos mecanismos generalmente dependen del código de la aplicación que se intenta
		adaptar y consecuentemente, no son fácilmente reutilizables entre distintos sistemas. En resumen: hoy en día, la
		adaptación de sistemas de software es costosa de construir, difícil de modificar, poco reutilizable y generalmente sólo
		provee soluciones a fallos de manera puntual.

		En cuanto al estado del arte en materia de sistemas autónomos existen diversos enfoques tanto en el ámbito académico
		como en la industria del software.

		Dentro del ámbito de la industria, el concepto de sistemas autónomos se encuentra ampliamente difundido. Sin dudas, el
		enfoque de IBM, denominado ``Autonomic Computing'' \cite{IBM-AC} es el más completo, apalancado por un gran grupo de
		investigación y abarcando el problema desde distintos aspectos. También se destaca la iniciativa de Microsoft
		denominada ``Dynamic Systems Initiative'', y no tanto la iniciativa de Sun (``Predictive Self-Healing'' y
		``Conscientious Software''), por estar más ligada a adaptar el enfoque al dominio de los sistemas operativos. Para más
		información sobre estos enfoques, remitirse a \cite{Casuscelli}

		Por otro lado, existen distintos investigadores ligados a prestigiosas instituciones académicas abocados al estudio de
		distintos aspectos de la autonomía de los sistemas. Uno de los primeros investigadores en acuñar el término ``Self
		Healing'' fue el Dr. David Garlan, de la Universidad de Carnegie Mellon, quien formó un grupo de investigación que
		dedicó años a estudiar el tema dentro del marco del proyecto ABLE.\footnote{El proyecto ABLE (\emph{``Architecture
		Based Languages and Environments''}) de la Universidad de Carnegie Mellon lleva a cabo investigaciones que conducen a
		una base de ingeniería para la arquitectura de software. Para más información, visitar
		\url{http://www.cs.cmu.edu/~able}}

		El presente trabajo toma como base el trabajo generado por el proyecto ABLE de Carnegie Mellon, el cual implementa
		el concepto de ``Auto Reparación de Sistemas Basada en Modelos de Arquitectura'', el cual se describirá en detalle a
		continuación.

	\subsubsection{Auto Reparación de Sistemas Basada en Modelos de Arquitectura}
	\label{sec:ARSBMA}

		En contraste con los mecanismos tradicionales para detección y recuperación de errores que se implementan como parte
		del código específico de la aplicación, con mecanismos localizados y poco reutilizables entre distintos sistemas; el
		enfoque propuesto por el Dr. David Garlan, usa \textbf{el modelo de la arquitectura} del sistema que se desea adaptar
		como instrumento para razonar sobre sus propiedades (e.g. tiempo de respuesta de un servidor) y sus correlatos
		con la dinámica del sistema en tiempo de ejecución.

		Diversos investigadores han propuesto usar modelos arquitecturales \cite{ArchBasedApproach} que representan al
		sistema como una mera composición de componentes, sus interconexiones (conectores) y sus propiedades de
		interés. Este modelo es conocido comunmente como \textbf{C\&C} (componentes y conectores)\cite{C&C}. Tal propuesta
		ofrece diversos beneficios, el más significativo: un modelo arquitectural abstracto provee una perspectiva global del
		sistema y expone sus propiedades y restricciones de integridad.

		La idea propuesta consiste básicamente en un bucle cerrado (\emph{closed-loop} en inglés), donde existen dos capas
		(externas al sistema que está siendo ejecutado) que actúan, una encargada del monitoreo del sistema y la otra
		proveyendo un mecanismo de control y adaptación. Esto ofrece una solución mas efectiva que cualquier mecanismo interno
		porque permite agrupar todo lo concerniente a la detección y solución del problema en módulos separados, pudiendo ser
		analizados, modificados, extendidos y reutilizados a través de distintos sistemas.

		\begin{figure}[h]
			\centering
				\includegraphics{images/selfhealing-closed-loop.png}
			\caption{Bucle cerrado}
			\label{fig:selfhealing-closed-loop}
		\end{figure}

		Otro sub proyecto del proyecto ABLE, denominado \textbf{Rainbow} (sobre el cual profundizaremos más adelante) utiliza
		esta técnica de \emph{closed-loop} para monitorear y reparar sistemas.

	\subsection{Lenguajes de Descripción de Arquitecturas}

		Un problema fundamental en el diseño de arquitecturas de sistemas utilizando el estilo de componentes y
		conectores ha sido encontrar la notación apropiada para definir dichas arquitecturas.

		Un buen lenguaje para describir arquitecturas debería permitir generar una documentación clara sobre los componentes
		de la arquitectura, que luego servirá como base a los de\-sa\-rro\-lla\-do\-res, permitiendo a su vez razonar sobre
		las propiedades del sistema y automatizar su análisis, hasta pudiendo quizás llegar a utilizarse para la generación
		automática de parte del código que implementará la arquitectura. También debería ser efectivo para poder validar de
		manera temprana decisiones arquitectónicas, reduciendo así el tiempo de implementación y evitando utilizar
		ineficientemente recursos en el desarrollo del sistema.

		Una forma de describir dichas arquitecturas es mediante el modelado de objetos con UML, si bien este método ha
		sido ampliamente aceptado y utilizado en la industria, tiene varios inconvenientes: el más importante e
		invalidante es que no provee un soporte directo para describir propiedades no funcionales. Ésto hace dificultoso
		razonar sobre propiedades críticas del sistema, como por ejemplo la \emph{performance} o la confiabilidad. Ésta es la
		razón principal que ha motivado el avance de los ADLs (\emph{Architecture Description Languages}). Para más
		información sobre la discusión ADL's vs. UML, remitirse a \cite{ADLsVsUML}.

		La descripción de arquitecturas de sistemas basada en ADLs ha avanzado considerablemente en las últimas dos décadas,
		al punto de que ya permiten definir una base formal para su descripción y análisis.

	\subsubsection{Acme}
	\label{sec:acme}

		Acme\cite{ACME} es uno de los ADLs más reconocidos y utilizados, ha sido desarrollado en la universidad de Carnegie
		Mellon, más precisamente por el proyecto ABLE, liderado por el Dr. David Garlan.

		Acme es un pilar fundamental dentro del proyecto ABLE, ya que todo el proyecto gira en torno a la arquitectura de
		software de los sistemas, y es Acme quien permite describir formalmente dichas arquitecturas, por lo tanto todos los
		restantes sub proyectos utilizan Acme en menor o mayor medida.

		Además de los beneficios de todo ADL, el lenguaje Acme y su kit de herramientas \emph{AcmeLib (Acme Tool Developer's
		Library)} proveen las siguientes capacidades fundamentales:

		\begin{itemize}
			\item Intercambio Arquitectural: al proveer un formato de intercambio genérico para diseñar arquitecturas de
			software, Acme permite a los desarrolladores de herramientas de este tipo \footnote{Ejemplos de herramientas de
			descripción de arquitecturas y modelado UML podrían ser: Enterprise Architect (\url{http://www.sparxsystems.com.au/})
			o Poseidón (\url{http://www.gentleware.com/}), entre tantas otras.} integrar fácilmente con otras herramientas
			complementarias. De esta manera, los arquitectos que usan herramientas basadas en Acme tienen un espectro más amplio
			de herramientas de	análisis y diseño que quienes diseñan sus arquitecturas usando otros ADLs.
			\item Extensibilidad: Acme provee una base sólida, genérica y extensible, y una infraestructura que evita que los
			desarrolladores vuelvan a construir herramientas de base. Más aún, debido a su idea originaria de lenguaje de
			intercambio genérico, Acme permite que las herramientas que se han desarrollado utilizándolo sean compatibles con una
			gran variedad ADLs existentes y con herramientas con un mínimo esfuerzo, y hasta en algunos casos sin esfuerzo alguno.
		\end{itemize}

		Actualmente, el lenguaje Acme y \emph{Acme Tool Developer's Library (AcmeLib)}, proveen una infraestructura genérica y
		extensible para describir, representar, analizar y generar descripciones de arquitecturas de software.

		A continuación, observamos un breve ejemplo de una arquitectura modelada en el lenguaje ACME, la cual posee un
		sistema que contiene:
		\begin{itemize}
			\item un servidor HTTP, con algunas propiedades como por ejemplo fidelidad del contenido que provee.
			\item un cliente HTTP, también con algunas propiedades particulares como el tiempo de respuesta experimentado por el
			usuario.
		\end{itemize}

		\begin{Verbatim}[gobble=3]
			System system : ClientServerType = {
			    Component server : ServerT = new ServerT extended with {
			        Port http0 : HttpPortT;
			        Property cost;
			        Property fidelity;
			        Property load;
			    }
			    Component client : ClientT = new ClientT extended with {
			        Port p0 : HttpReqPortT = new HttpReqPortT extended with {
			            Property isArchEnabled = true;
			        }
			        Property deploymentLocation = "127.0.0.1";
			        Property isArchEnabled = true;
			        Property experRespTime;
			    }
			}
		\end{Verbatim}

		Más adelante, en la sección \ref{sec:casosPracticos}, veremos otro ejemplo (más extenso) del lenguaje al mostrar la
		descripción completa en Acme de la arquitectura del sistema que utilizaremos para mostrar los resultados de la extensión
		implementada en el presente trabajo.

		\subsubsection{Tácticas y Estrategias}
		\label{sec:tacticasEstrategias}

			Hemos mencionado anteriormente que el objetivo de la auto reparación es el alcanzar determinados atributos de
			calidad definidos para un determinado sistema, ajustando su comportamiento, de ser necesario, de acuerdo a
			las condiciones de ejecución del mismo. En el libro \textbf{Software Architecture in Practice} \cite{BassClementz},
			Bass, Clements y Kazman caracterizan y formalizan dos herramientas que vienen siendo ampliamente utilizadas desde
			hace tiempo por los arquitectos de software en la industria, estas son: las \textbf{tácticas} y las
			\textbf{estrategias}.

			Las \textbf{tácticas} se definen como decisiones de diseño tendientes a controlar las respuestas del sistema a
			determinados estímulos, a fin de satisfacer uno o más atributos de calidad requeridos. La figura
			\ref{fig:tactics_control_to_response} muestra gráficamente el concepto de táctica arquitectural.

			\begin{figure}[h]
				\centering
					\includegraphics{images/tactics_control_to_response.png}
				\caption{Visión gráfica del concepto de táctica}
				\label{fig:tactics_control_to_response}
			\end{figure}

			Cada táctica es una opción de diseño para el arquitecto, un ejemplo concreto podría ser el introducir redundancia en
			determinados componentes de la arquitectura (e.g. base de datos, servidores web replicados, etc.) para incrementar la
			dis\-po\-ni\-bi\-li\-dad del sistema.

			Por otro lado, una \textbf{estrategia} puede ser entendida como un procedimiento delineado por los arquitectos de
			\emph{software} para intentar llevar al sistema a un nivel dónde los atributos de calidad se cumplan en el nivel
			deseado; haciendo uso de una o más tácticas. Cada táctica es ejecutada únicamente cuando el estado del sistema
			satisface las condiciones impuestas por la estrategia para dicha ejecución. Por ejemplo, en una arquitectura
			cliente-servidor y al verse el tiempo de respuesta comprometido, una estrategia podría intentar agregar servidores
			mientras existan disponibles o, hasta que el tiempo de respuesta haya descendido por debajo de un determinado umbral.
			Esta lógica sería descrita en la estrategia, mientras que será la táctica \verb@levantar-servidor@ la responsable de
			ejecutar la acción propiamente dicha. Notar que si bien esta estrategia está diseñada para mejorar el tiempo de
			respuesta, también afecta negativamente al \emph{concern} ``cantidad de servidores'' (correspondiente al atributo de
			calidad ``costo'') puesto que usualmente el utilizar mayor cantidad de servidores suele tener un costo económico no
			despreciable.
			
			Cuando una estrategia se diseña para mejorar un atributo de calidad en particular, se puede decir que los
			\emph{stakeholders} que definen dichos atributos de calidad obtienen cierto ``beneficio'' de las estrategias. Cada
			estrategia provee un nivel específico de dicho beneficio, pero en contrapartida presenta un costo en tiempo y, sobre
			todo, en dinero. Es por este motivo que los \emph{stakeholders} deben participar en el proceso de decisión de cúales
			estrategias se emplearán para satisfacer los atributos de calidad definidos para el sistema. Ellos deberán evaluar el
			retorno de la inversión (la relación costo-beneficio) de aplicar cada estrategia para elegir la más conveniente.

			La estrategia es la herramienta propuesta por Rainbow para quitar al sistema de un estado no deseado.

	\subsection{Rainbow}

		\subsubsection{Introducción a Rainbow}

			La herramienta Rainbow, también dentro del marco del proyecto ABLE, tiene como finalidad permitir reducir el costo e
			incrementar la confiabilidad al realizar cambios en sistemas complejos de software, para esto Rainbow automatiza la
			adaptación de sistemas de software a traves de sus modelos de arquitectura, tal cual fue descrito en la sección
			\ref{sec:ARSBMA}.

			Si bien en principio el enfoque de auto adaptación basado en arquitecturas es atractivo, el mismo supone un número
			significativo de desafíos en el campo de la investigación así también como en el de la ingeniería:

			\begin{itemize}
				\item En primer lugar, uno de los aspectos claves que Rainbow intenta cubrir es la habilidad de manejar una amplia
				variedad de sistemas con arquitecturas, propiedades de interés y mecanismos que soporten modificaciones dinámicas
				completamente diferentes.

				\item Por otro lado, Rainbow intenta ser una solución que permita reducir el costo de agregar control externo al
				sistema a reparar, puesto que crear los me\-ca\-nis\-mos de monitoreo y detección de
				problemas desde cero para un sistema nuevo sería prohibitivamente costoso. El enfocar la auto reparación de un
				sistema en su arquitectura permite disponer de una infraestructura reutilizable junto con mecanismos para adaptar
				dicha infraestructura a las necesidades específicas de cada sistema.
			\end{itemize}

			Cabe mencionar que el caracter externo y no intrusivo de Rainbow representa una ventaja también cuando se
			desea implementar auto reparación en sistemas cuyo código fuente no está disponible o no es plausible de ser
			modificado.

			\subsubsection{Arquitectura de Rainbow}

				La Figura \ref{fig:Rainbow_Framework} muestra la arquitectura de Rainbow. En resumidas palabras, el \emph{framework}
				utiliza un modelo arquitectural abstracto para monitorear las propiedades en \emph{runtime} del sistema que está
				siendo ejecutado, evalúa el modelo para detectar violaciones a restricciones impuestas sobre el mismo y lleva a cabo
				adaptaciones en el sistema tendientes a eliminar tales violaciones.

				\begin{figure}[H]
					\centering
						\includegraphics{images/Rainbow_Framework.png}
					\caption{Arquitectura de Rainbow}
					\label{fig:Rainbow_Framework}
				\end{figure}

				La infraestructura de adaptación de Rainbow se divide en capas que proveen funcionalidades comunes a distintos
				sistemas auto adaptables logrando por lo tanto el objetivo de disponer de componentes reutilizables, a saber:
				\begin{enumerate}
					\item \textbf{Capa de Sistema}:\\
					En esta capa se define e implementa una interfaz de acceso al sistema que está siendo ejecutado. Se define un
					mecanismo para medir variables de interés, materializado en \emph{Probes}: componentes que observan
					y miden diversos estados del sistema, para luego publicarlos.

					Adicionalmente, existe un mecanismo para descubrir recursos que puede ser utilizado especificando el tipo de
					recurso, entre otros criterios. Finalmente, los denominados \emph{Effectors} llevan a cabo las modificaciones
					propiamente dichas sobre el sistema.
					\item \textbf{Capa de Arquitectura}:\\
					En esta capa, los denominados \emph{Gauges} agregan información provenientes de los \emph{Probes} y
					mantienen constantemente actualizadas las propiedades correspondientes en el modelo arquitectural del sistema
					(descrito en ACME), el cual es manejado y accedido mediante un componente denominado \emph{Model Manager}. El
					\emph{Constraint Evaluator} chequea el modelo periódicamente y dispara la adaptación en el caso que ocurra una
					violación en alguna restricción impuesta sobre el modelo. En ese caso, el motor de adaptación (\emph{Adaptation
					Engine}) determina el curso de acción y lleva a cabo la adaptación necesaria.
					\item \textbf{Capa de Traducción}:\\
					Esta capa es la encargada de cubrir la brecha de abstracción existente entre el sistema en ejecución y el modelo
					de su arquitectura (en ambos sentidos). En esta infraestructura, un repositorio de traducción mantiene diversos
					mapeos compartidos por distintos componentes dentro de esta capa, por ejemplo, una operación a nivel modelo de la
					arquitectura en su correspondiente operación de \emph{runtime}:

					\begin{Verbatim}[gobble=7]
						       Componente de Log::desactivar       <==>       Logger.disableLog()
					\end{Verbatim}
				\end{enumerate}

				Rainbow es un \emph{framework} desarrollado en el lenguaje de programación Java\textsuperscript{\texttrademark} y
				todos los derechos sobre el código fuente pertenecen al grupo ABLE de la Universidad de Carnegie Mellon. Los autores
				de este trabajo solicitaron permiso a este grupo para poder acceder al código fuente de Rainbow para poder realizar
				la extensión objeto de este trabajo. En la wiki oficial de Rainbow pueden encontrarse instrucciones para
				instalar versiones ya compiladas del \emph{framework}. Para más información, visitar
				\url{http://rainbow.self-adapt.org/RainbowInstall}.

		\subsubsection{Conocimiento específico del sistema}
		
			En la sección anterior hemos descrito la infraestructura básica provista por Rainbow. Es de notar que la misma no es
			suficiente para satisfacer las necesidades puntuales de auto adaptación de un sistema en particular. Para
			lograr esto, es necesario extender dicha infraestructura, agregando conocimiento específico del sistema que se desea
			adaptar. Este conocimiento (típicamente no reutilizable entre distintos sistemas) incluye el modelo operacional
			del sistema, que define parámetros como tipos de componentes y propiedades, restricciones de comportamiento,
			estrategias de adaptación, interfaz para acceder a la información de \emph{runtime} del sistema, así también como
			para hacer efectivas las estrategias de reparación, etc.

		\subsubsection{Stitch}

			A fin de disponer de una forma suficientemente expresiva de definir tácticas y estrategias, Rainbow incluye
			un lenguaje de \emph{scripting} de propósito específico llamado \textbf{Stitch}, el cual permite plasmar el
			conocimiento rutinario de las personas sobre adaptación de sistemas de software.

			Algunas de las características innovadoras de Stitch:
			\begin{itemize}
				\item \textbf{Control del sistema}: La selección de la próxima acción a ejecutar en el contexto de una estrategia
				depende de los efectos observados luego de la acción previa.
				\item \textbf{Sensibilidad al contexto}: La selección de la mejor estrategia se realiza considerando el estado
				actual del sistema, mediante la inspección de algunas de sus propiedades.
				\item \textbf{Asincronismo}: Stitch permite especificar un tiempo de demora luego de la ejecución de una táctica
				para que los efectos de la táctica se puedan ver reflejados en el sistema.
			\end{itemize}

		\subsubsection{Ejemplo de una Táctica en Stitch}

			En la figura \ref{fig:tactics_example} se puede apreciar un ejemplo de una táctica definida en Stitch para ser
			utilizada por Rainbow. Primeramente, se importa el modelo de la arquitectura del sistema en cuestión junto con la
			implementación de un operador que permite impactar al sistema en ejecución (estos operadores suelen ser provistos por
			el usuario de la aplicación).
			
			\begin{figure}[h]
				\centering
					\includegraphics[width=0.98\textwidth]{images/tactics_example.png}
				\caption{Ejemplo de una táctica en Stitch}
				\label{fig:tactics_example}
			\end{figure}
			
			La táctica consiste en disminuir la fidelidad (a modo sólo texto) del contenido provisto por todos los servidores
			cuando se detecta que al menos un cliente experimenta un tiempo de respuesta superior a un determinado umbral. Para lograr
			esto, Rainbow inspecciona las propiedades del modelo de la arquitectura del sistema, definido en ACME, el cúal se
			supone constantemente actualizado por Rainbow con respecto al estado actual del sistema en ejecución.
			
			Por último, se especifica que el efecto esperado de ejecutar la táctica consiste en que todos los clientes
			experimenten un tiempo de respuesta inferior al umbral y que, por otro lado, todos los servidores se encuentren
			prestando servicio en modo sólo texto.

		\subsubsection{Ejemplo de una Estrategia en Stitch}

			En la figura \ref{fig:strategies_example} podemos ver un ejemplo de una estrategia definida en Stitch para ser
			utilizada por Rainbow.

			\begin{figure}[h]
				\centering
					\includegraphics[width=0.98\textwidth]{images/strategies_example.png}
				\caption{Ejemplo de una estrategia en Stitch}
				\label{fig:strategies_example}
			\end{figure}

			La estrategia representa un algoritmo simple para disminuir el tiempo de respuesta experimentado por el usuario de un
			sistema cliente-servidor. Se definen algunos predicados de primer orden que predican sobre propiedades del modelo de
			la arquitectura del sistema, el cual se presume constantemente actualizado por Rainbow con respecto al sistema en
			ejecución.
			
			El primer paso de la estrategia consiste en verificar que haya en la arquitectura un conector que presente
			alta latencia, en ese caso, se invoca la táctica definida en la Figura \ref{fig:tactics_example}, la cual cambia la
			fidelidad de todos los servidores a modo sólo texto, y se espera 1 segundo antes de determinar el éxito o no de la
			ejecución de la táctica. Si la táctica tuvo éxito, la estrategia finaliza satisfactoriamente. Sino, la estrategia
			chequea la existencia de al menos un servidor con alta carga, y en caso afirmativo, ejecuta otra táctica que consiste
			en agregar un servidor más en pos de mejorar el \emph{concern} tiempo de respuesta. Si luego de esperar 2 segundos
			para que los efectos de la táctica puedan verse reflejados en el sistema, todos los servidores operan con carga
			normal, la estrategia finaliza exitosamente, caso contrario, la misma se considera fallida.

		\subsubsection{\emph{Exponential Moving Average}}
		\label{sec:exponentialAverage}

			El proceso de adaptar un sistema de manera dinámica puede llegar a ser muy costoso, por ejemplo, en un sistema
			cliente-servidor, el asignar más servidores para atender las peticiones de los usuarios implica normalmente un coste
			monetario no despreciable. Otro ejemplo podría ser el suspender temporalmente la reproducción de videos en un sitio
			de noticias. Si bien esta decisión puede servir para disminuir el tiempo de respuesta experimentado por los usuarios
			en un contexto de alta carga, también provoca una clara disminución en la calidad del servicio ofrecido. Estos
			ejemplos concretos sirven para inferir que el disparar un mecanismo de auto reparación en un sistema debe ser una
			decisión tomada con cierta cautela y en base a datos confiables y sostenidos en el tiempo.
			
			Hemos visto anteriormente, de manera somera, de que forma Rainbow (mediante estrategias y tácticas definidas en el
			lenguaje Stitch) utiliza datos sobre el sistema en ejecución para decidir el mejor camino a tomar para adaptar el
			sistema. Consideremos un escenario donde una estrategia debe decidir si el último paso ejecutado fue exitoso o no.
			Para eso, deberá consultar una o más propiedades del sistema en ejecución, las cuales podrían llegar a no ser
			representativas del entorno \emph{real} en que el sistema se encuentra, debido a la presencia de (\emph{outliers}),
			i.e. valores aislados considerablemente distintos al resto de los datos recientes que se usan para tomar
			decisiones.
			
			Rainbow implementa un mecanismo que permite evitar accionamientos prematuros de la auto reparación debido a la
			presencia de \emph{outliers}. El mentado mecanismo utiliza \emph{Exponential Moving Average}\footnote{Para
			más información, visitar \url{http://en.wikipedia.org/wiki/Exponential_moving_average}}, que permite ponderar los
			valores históricos de la(s) propiedad(es) del sistema que se consultan para tomar decisiones. La función de suavizado
			que implementa esta heurística se define inductivamente de la siguiente manera:

			\begin{equation}
				S_0 = Y_0
			\end{equation}
			\begin{equation}
				S_t = \alpha \times Y_t + (1-\alpha) \times S_{t-1}
			\end{equation}

			donde $\alpha$ se denomina \textbf{factor de suavizado} y $0 < \alpha < 1$.
			
			El valor suavizado $S_t$ no es ni más ni menos que un promedio ponderado de la última observación $Y_t$ y el valor
			suavizado previo $S_{t-1}$.
			
			Notar que con valores \emph{altos} de $\alpha$, el último valor observado tendrá más preponderancia que el valor
			histórico (suavizado) anterior. Por el contrario, con un $\alpha$ tendiendo a cero, la última observación de una
			propiedad de la arquitectura prácticamente no tendrá relevancia sobre el valor promedio $S_t$.
			
			No existe un procedimiento formal para determinar el valor de $\alpha$, en el caso particular de las pruebas
			realizadas en este trabajo, se ha elegido $\alpha = 0.3$, es decir que, se ponderará con un 30\% al último valor
			observado mientras que el valor histórico tendrá un peso del 70\%; con esto nos aseguramos que los valores de las
			propiedades del sistema que son relevantes para la auto adaptación no fluctúen bruscamente debido a unos pocos
			\emph{outliers}.

	\subsubsection{Znn}

		Znn es un sistema que simula un sitio web de noticias, el cual nació en el contexto de la tesis de doctorado
		\cite{TesisOwen} de Shang-Wen Cheng, un investigador de la universidad de Carnegie Mellon. En dicha tesis, se evalúa a
		Rainbow en los siguientes aspectos:
		\begin{itemize}
			\item su efectividad para mantener los atributos de calidad ante condiciones cambiantes.
			\item la sobrecarga de procesamiento que implica la auto reparación.
			\item el esfuerzo que implica agregar auto reparación a Znn mediante Rainbow.
		\end{itemize}

		Si bien Znn y sus herramientas asociadas (\emph{probes}, \emph{gauges}, tácticas, estrategias, etc.) nacieron con
		el único objetivo de evaluar la efectividad de Rainbow, las mismas han sido abiertas a la comunidad para que puedan
		ser utilizadas para tomar métricas y poder comparar distintos \emph{frameworks} de auto reparación.

		Znn provee un entorno de simulación de una arquitectura cliente-servidor ampliamente configurable que permite
		representar situaciones específicas de ejecución y controlar las variables de simulación permitiendo modificarlas en
		cualquier punto.
		
		Por ejemplo, es posible configurar a Znn para que inicie con solamente 2 clientes, mostrando allí un desempeño
		aceptable y que luego se agreguen 10 clientes, comprometiendo así la \emph{performance} del sistema. De esta
		manera, Znn permite simular cómo responderían las estrategias implementadas ante dicha situación.

		Rainbow soporta dos modos de ejecución: el \textbf{modo normal}, donde el \emph{framework} se conecta con un sistema
		real, y un \textbf{modo simulación}, el cual permite probar las herramientas de auto reparación implementadas por los
		usuarios sin necesidad de conectar a Rainbow con un sistema real en ejecución.
		
		En el presente trabajo se utilizará el modo simulación para los casos de prueba, tomando las estrategias y tácticas
		provistas por Znn. Éstas debieron ser adaptadas para que puedan seguir funcionando con los cambios propuestos en el
		presente trabajo.

	\subsection{Escenarios de Atributos de Calidad}
		\label{sec:QAS}

		Un escenario de atributos de calidad (de ahora en más, simplemente ``escenario'') es la especificación de un
		requerimiento para un atributo de calidad en particular. Consiste de seis partes:

		\begin{itemize}
			\item \textbf{Fuente del estímulo}: Es una entidad (un ser humano, otro sistema o cualquier otro actor) que generó el
			estímulo.
			\item \textbf{Estímulo}: la condición que debe ser tenida en cuenta cuando llega al sistema.
			\item \textbf{Entorno}: el estímulo ocurre bajo ciertas condiciones, e.g. entorno de alta carga, entorno normal,
			sistema no funcionando, etc.
			\item \textbf{Artefacto}: el sistema o partes de él afectadas por el estímulo.
			\item \textbf{Respuesta}: refiere a qué hace el sistema ante la llegada del estímulo.
			\item \textbf{Medición de la respuesta}: cuando ocurre la respuesta, debe ser medible de alguna manera para que el
			requerimiento pueda ser \emph{testeado}.
		\end{itemize}

		\begin{figure}[h]
			\centering
				\includegraphics{images/scenario.png}
			\caption{Visión gráfica de un escenario}
			\label{fig:scenario}
		\end{figure}

		Los escenarios son pequeñas historias que describen una interacción con el sistema, la cual impacta sobre un atributo
		de calidad en particular. Por ejemplo, un escenario sobre disponibilidad podría ser:
		\begin{quote}
		``Un proceso del sistema recibe un mensaje externo no anticipado durante un modo de operación normal. El proceso
		informa al operador sobre la recepción del mensaje y continúa su operación sin caídas.''
		\end{quote}

		\begin{figure}[h]
			\centering
				\includegraphics{images/scenario_availability_example.png}
			\caption{Ejemplo de un escenario de disponibilidad}
			\label{fig:scenario_availability_example}
		\end{figure}

		Este escenario se descompone de la siguiente manera:
		\begin{itemize}
			\item \textbf{Fuente del estímulo}: Cualquier fuente externa
			\item \textbf{Estímulo}: Mensaje no anticipado
			\item \textbf{Entorno}: Operación normal
			\item \textbf{Artefacto}: Proceso interno
			\item \textbf{Respuesta}: Informar al operador y seguir operando
			\item \textbf{Medición de la respuesta}: sin caídas (\emph{downtime})
		\end{itemize}

		Los escenarios permiten obtener el punto de vista de un grupo diverso de \emph{stakeholders} (arquitectos,
		desarrolladores, usuarios, el \emph{sponsor}, etc). Estos escenarios pueden luego ser utilizados para analizar y
		definir la arquitectura del sistema e identificar \emph{concerns} y posibles estrategias para atacar problemas.

		\subsubsection{QAW}
			Existe una metodología definida por el Software Engineering Institute (SEI) conocida como \textbf{Quality Attribute
			Workshops (QAW)}, cuya principal herramienta son los escenarios. Los QAW proveen un método para identificar los
			atributos de calidad críticos de la arquitectura de un sistema, tales como disponibilidad, \emph{performance},
			seguridad, etc, que son derivados de objetivos del negocio. QAW no presupone la existencia de una arquitectura del
			sistema, sino que fue desarrollado como consecuencia de la necesidad de \emph{stakeholders} y arquitectos de un
			método que permita identificar los atributos de calidad importantes para el correcto funcionamiento del sistema
			\textbf{antes de definir su arquitectura}.
	
			Los QAW son reuniones en las que participan todos los \emph{stakeholders}, en las que se definen los escenarios que
			en definitiva representarán los requerimientos de atributos de calidad que el sistema idealmente deberá satisfacer.
			Una vez definidos todos los escenarios, el siguiente paso del QAW consiste en priorizarlos y refinarlos,
			especificando claramente todos las partes que los componen y determinando el atributo de calidad asociado a cada
			escenario. El proceso de refinar los escenarios permite a los \emph{stakeholders} comunicarse entre ellos, exponiendo
			supuestos que pueden no ser tan claros para el resto de los participantes, y proporcionando una visión de cómo
			interactúan los atributos de calidad entre sí, sirviendo de base para definir \emph{tradeoffs} entre estos atributos.
	
			El proceso QAW termina con la lista de escenarios refinados y priorizados. Los mismos pueden servir para definir casos
			de pruebas, o como semillas para el proceso ATAM, sobre el cual discutiremos en la siguiente sección.

			Si bien no es condición necesaria para poder usar Arco Iris, el utilizar la metodología QAW, tal cual está
			descrita en \cite{QAW}, es recomendado ya que Arco Iris hará uso intensivo de los escenarios de atributos de calidad
			y, por lo tanto, de su correcta definición dependerá el nivel de optimización y flexibilización que la extensión a
			Rainbow pueda alcanzar al auto reparar un sistema de \emph{software}.

	\subsection{ATAM}
	\label{sec:atam}

		\subsubsection{Terminología necesaria}

			Antes de profundizar sobre ATAM, es necesario clarificar ciertos términos que serán utilizados en el desarrollo de la
			presente sección. Estos términos son:
			
			\begin{itemize}
				\item \textbf{Riesgo}: decisión arquitectónica potencialmente problemática.
				\item \textbf{Punto sensible}: propiedad de uno o más componentes (y/o relaciones entre componentes) que es crítica
				para poder alcanzar un atributo de calidad determinado. Por ejemplo, un módulo de cifrado es un punto sensible para
				el atributo de calidad ``seguridad''.
				\item \textbf{Punto de \emph{tradeoff}}: se trata de un componente de la arquitectura donde se afecta más
				de un atributo de calidad (y por ende, también es un punto sensible para dichos atributos de calidad). Por ejemplo,
				el módulo de cifrado mencionado anteriormente sería un punto de \emph{tradeoff} de haber requerimientos de
				\emph{performance}, ya que afecta positivamente la seguridad y negativamente la \emph{performance} del sistema. 
				\item \textbf{\emph{Non risks}} son buenas decisiones de arquitectura que normalmente están implícitas en la
				arquitectura.
			\end{itemize}

		\subsubsection{Analizando arquitecturas con ATAM}

			El método para el análisis de \emph{tradeoffs} o, de sus siglas en inglés, ATAM (Architecture Tradeoff Analysis
			Method)\cite{ATAM}, al igual que QAW, ha sido desarrollado por el SEI y es una técnica que permite analizar
			arquitecturas de \emph{software} con el objetivo de validar requerimientos de atributos de calidad, su interacción
			(conocidos como \emph{tradeoffs}), detectar problemas de manera temprana e identificar riesgos y puntos sensibles.
			
			Usualmente, las arquitecturas de \emph{software} son complejas, e involucran muchos \emph{tradeoffs} de diseño. Sin un
			proceso de análisis formal, no es posible garantizar que las decisiones de arquitectura	tomadas \textendash en
			particular aquellas que afectan al cumplimiento de requerimientos de calidad \textendash son adecuadas para mitigar
			los riesgos.
	
			La meta de evaluar una arquitectura con ATAM es entender las consecuencias de las decisiones arquitectónicas con
			respecto a los requerimientos de atributos de calidad del sistema. Otro objetivo fundamental de ATAM es determinar si
			dichos requerimientos pueden ser alcanzados con la arquitectura concebida, antes de destinar grandes cantidades de
			recursos a la construcción del \emph{software}.
	
			ATAM es un método estructurado y repetible, ayudando así a plantear las preguntas correctas sobre la arquitectura
			de manera temprana en el proyecto, durante las etapas de análisis de requerimentos y de diseño, en las
			cuales los problemas detectados pueden ser corregidos sin mayores costos. ATAM guía a los usuarios del método
			(\emph{stakeholders}) para que busquen riesgos en la arquitectura y soluciones a dichos riesgos.
	
			Cabe mencionar que los QAW han surgido como consecuencia del uso de ATAM, puesto que era requerida una herramienta o
			método que permitiera identificar los requerimientos de atributos de calidad más importantes del sistema,
			\textbf{antes de que existiese la arquitectura} sobre la cual ATAM trabajaría. Luego de observar los pasos del
			método ATAM que detallaremos a continuación, no será difícil para el lector inferir que en realidad ATAM incluye una
			versión simplificada de QAW.
	
		\subsubsection{Pasos del método ATAM}

			A continuación se describen los pasos del método ATAM:
	
			\noindent \underline{\emph{Presentación}}

			\begin{enumerate}
				\item \textbf{Presentar ATAM.} El método es descrito a los \emph{stakeholders}.
				\item \textbf{Presentar las metas del negocio.} El \emph{project manager} describe los objetivos del
				negocio que motivan el desarrollo.
				\item \textbf{Presentar la arquitectura.} El equipo de arquitectos presenta la arquitectura propuesta,
				haciendo foco en cómo la misma satisface las metas del negocio.
			\suspend{enumerate}
			
			\noindent \underline{\emph{Investigación y Análisis}}
			
			\resume{enumerate}
				\item \textbf{Identificar enfoques arquitectónicos.} Los enfoques arquitectónicos son identificados
				por el equipo de arquitectura, pero no analizados.
				\item \label{arbolUtilidad} \textbf{Generar el árbol de utilidad.} Se recaban los atributos de calidad que agregan
				utilidad al sistema y se los especifica en forma de escenarios priorizados.
				\item \label{enfoques} \textbf{Analizar enfoques arquitectónicos.} Se delinean enfoques arquitectónicos para los
				escenarios de mayor prioridad recabados en (\ref{arbolUtilidad}). Durante este paso, se identifican riesgos
				arquitectónicos, puntos sensibles y puntos de \emph{tradeoff}.
			\suspend{enumerate}

			\noindent \underline{\emph{Testing}}

			\resume{enumerate}
				\item \label{brainstorming} \textbf{\emph{Brainstorming} y priorización de escenarios.} Basado en los escenarios del
				árbol de utilidad, se genera un conjunto mayor de escenarios más específicos. Estos nuevos escenarios son
				priorizados vía un proceso de votación.
				\item \textbf{Analizar enfoques arquitectónicos.} Se reitera el paso (\ref{enfoques}) pero con los escenarios más
				prioritarios encontrados en el paso (\ref{brainstorming}), con el objetivo de encontrar nuevos riesgos, puntos
				sensibles y \emph{tradeoffs}.
			\suspend{enumerate}

			\noindent \underline{\emph{Reporting}}

			\resume{enumerate}
				\item \textbf{Presentar resultados.} Basado en toda la información recolectada durante el proceso (escenarios,
				el árbol de utilidad, riesgos, puntos sensibles y puntos de \emph{tradeoff}), el equipo de ATAM escribe un reporte
				detallando esta información y las estrategias de mitigación propuestas.
			\end{enumerate}

			\begin{figure}[h]
				\centering
					\includegraphics[width=0.85\textwidth]{images/ATAM_steps.png}
				\caption{Pasos de ATAM}
				\label{fig:ATAM_steps}
			\end{figure}