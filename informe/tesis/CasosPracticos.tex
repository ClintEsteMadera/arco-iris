\section{Casos Prácticos}
\label{sec:casosPracticos}

	En esta sección se presentan y analizan algunos casos de prueba concretos de uso de Arco Iris a fin de evaluar su
	comportamiento. Se utilizará el modo simulación provisto por Rainbow (ver sección  \ref{sec:modosEjecucion})
	para adaptar utilizando Arco Iris al sistema ficticio \textbf{Znn}, reutilizando los componentes de simulación creados
	para la tesis de doctorado dónde dicho sistema es presentado. (ver sección \ref{sec:znn})

	La simulación permite configurar la variación de los valores de ciertas propiedades de los componentes de la
	arquitectura, a fin de simular diversas situaciones de carga en el sistema ficticio. Por ejemplo, se podría especificar
	que a los 10 segundos de haber comenzado la simulación, el ancho de banda de un servidor en particular disminuya y por
	otro lado que en ese mismo instante, la frecuencia de arribo de \emph{requests} del usuario suba en una determinada
	proporción. Este cambio en el entorno de ejecución del sistema simulado, por ejemplo, permitiría evaluar cómo se
	comporta Arco Iris en un contexto de \textbf{alta carga}.
	
	\subsection{Arquitectura del Sistema Simulado}
		Los componentes principales de la arquitectura de Znn son clientes y servidores. Éstos no se conectan directamente
		entre sí, sino que lo hacen por medio de un \emph{proxy}, al cual arriban todas las peticiones de los clientes, y es
		él quien conoce todos los servidores disponibles y distribuye el trabajo entre ellos. A continuación se muestra un diagrama
		de la arquitectura del sistema, extraída utilizando la herramienta AcmeStudio. (En el apéndice
		\ref{sec:arquitecturaZNN} se puede observar el código fuente Acme de dicha arquitectura)

		\begin{figure}[H]
			\centering
				\includegraphics[width=0.9\textwidth]{images/znnArchitecture.png}
			\caption{Arquitectura de Znn vista en Acme Studio}
			\label{fig:znnArchitecture}
		\end{figure}

		En la arquitectura de Znn están definidos tres \emph{concerns} aunque en el presente trabajo, a fin de simplificar
		para el lector la complejidad de las pruebas, se utilizarán sólo dos, a saber:
		\begin{itemize}
			\item \textbf{Tiempo de Respuesta}: tiempo de respuesta promedio experimentado por el usuario de Znn, y
			\item \textbf{Costo}: el cual, refleja la cantidad de servidores prestando servicio con los que Znn cuenta en un
			determinado momento.
		\end{itemize}

		Para las pruebas realizadas en este trabajo, sólo se utilizarán las siguientes tácticas, con el fin de modificar el
		comportamiento del sistema en ejecución:
		\begin{itemize}
			\item Dar de alta un servidor
			\item Dar de baja un servidor
		\end{itemize}

		Para que estas tácticas puedan ejecutarse, Znn implementa los correspondientes \emph{effectors}, quienes serán
		los responsables de efectuar los cambios propiamente dichos sobre el sistema en \emph{runtime}. Los \emph{effectors}
		serán invocados desde las tácticas, cuyas implementaciones en Znn pueden verse en el apéndice \ref{sec:tacticasZNN}.
	
		Antes de comenzar, cabe aclarar que, salvo que se indique lo contrario, la configuración de pesos para cada uno de los
		\emph{concerns} del sistema será equidistribuida. Esta decisión convierte a las prioridades entre escenarios en el
		único factor influyente en la selección de una estrategia candidata para reparar el sistema (ver algoritmo de
		selección de estrategias en la sección \ref{sec:arcoIrisStrategyScoring}), simplificando así los cálculos, así como  		también la comprensibilidad de los resultados presentados.
	\subsection{Comportamiento del Sistema sin Auto Reparación}
	\label{sec:defaultSystemBehavior}
		
		Para comenzar, se presenta el comportamiento del sistema de no existir escenarios ni estrategias, esto permitirá
		evaluar la variación de comportamiento a medida que se vayan agregando escenarios y/o estrategias en los siguientes
		casos de prueba.

		En las figuras \ref{fig:testcase1_1_expRespTime} y \ref{fig:testcase1_1_cost} se puede observar el comportamiento del
		sistema sin escenarios, es decir, sin auto reparación.
		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/testcase1_1_expRespTime.png}
			\caption{Comportamiento del sistema sin escenarios: tiempo de respuesta}
			\label{fig:testcase1_1_expRespTime}
		\end{figure}

		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/testcase1_1_cost.png}
			\caption{Comportamiento del sistema sin escenarios: costo de servidores}
			\label{fig:testcase1_1_cost}
		\end{figure}

		Como se puede observar, la simulación ha sido configurada explícitamente para que Znn se comporte de la siguiente
		manera: el tiempo de respuesta crece hasta superar los 600 ms., man\-te\-nién\-do\-se allí hasta 30 segundos después
		de haber comenzado la simulación, para luego ir bajando paulatinamente hasta estacionarse cerca de los 400 ms. Notar
		que el costo de los servidores se mantiene inmutable frente a los cambios en el tiempo de respuesta, es decir que el
		sistema, de no mediar un usuario administrador o un \emph{framework} de auto reparación como Arco Iris, trabaja
		siempre con un único servidor. Es importante tener en cuenta que la merma en el tiempo de respuesta no se debe a		ninguna acción propia de la auto reparación, sino a cambios en el ambiente, externos al sistema, como por ejemplo el		ancho de banda de la conexión de cada uno de sus clientes.
	\subsection{Comportamiento del Sistema con un Único Escenario}

		Habiendo presentado el comportamiento del sistema sin escenarios definidos, se procederá a definir el primer
		escenario, el cual consiste en determinar un umbral máximo aceptado de 600 ms. para el tiempo de respuesta
		experimentado por el usuario. El objetivo de esta prueba es visualizar cómo, al no haberse definido aún ninguna		estrategia, Arco Iris detectará que existe un escenario que no se satisface aunque no efectuará reparación alguna		sobre el sistema. En la figura \ref{fig:scenario_expRespTime} se muestra el detalle del escenario creado.		\todo{Refrescar todos los screenshots de la GUI (al final!)}

		\begin{figure}[ht]
			\centering
				\includegraphics[width=0.75\textwidth]{images/scenario_expRespTime.png}
			\caption{Detalle del único escenario del sistema}
			\label{fig:scenario_expRespTime}
		\end{figure}

		En el apéndice \ref{sec:scenarioExpRespTimeXML} podemos ver la representación de este escenario en XML.
		
		Dado que Arco Iris no ejecuta estrategia alguna, el costo de servidores no se verá modificado, manteniéndose constante
		en 1, tal como se ha visto en la figura \ref{fig:testcase1_1_cost}.
		
		Por otro lado, en la figura \ref{fig:testcase1_1_expRespTime_threshold} se puede observar que Arco Iris detecta que
		a partir de cierto instante, el tiempo de respuesta alcanza y supera el umbral predefinido en la cuantificación de la
		respuesta del único escenario del sistema.
		
		\begin{figure}[ht]
			\centering
				\includegraphics[width=1.00\textwidth]{images/testcase1_1_expRespTime_threshold.png}
			\caption{Umbral para el tiempo de respuesta superado}
			\label{fig:testcase1_1_expRespTime_threshold}
		\end{figure}

	\subsection{Comportamiento del Sistema con un Único Escenario y una Única Estrategia}

		El próximo paso será definir una estrategia que pueda actuar cuando el escenario planteado deje de cumplirse. La misma
		consistirá simplemente en agregar un servidor, siempre y cuando existan servidores disponibles. La estrategia,
		definida en Stitch, será la siguiente:

		\begin{Verbatim}[gobble=3]
			strategy EnlistServerResponseTime {
			  t0: (true) -> enlistServers(1) @[5000 /*ms*/] {
			    t1: (!RESP_TIME_STILL_BROKEN) -> done;
			    t2: (default) -> TNULL;
			  }
			}
		\end{Verbatim}

		Al agregar esta estrategia, observamos en la figura \ref{fig:testcase1_2_expRespTime} que el tiempo de respuesta
		experimentado por el usuario se corrige rápidamente.

		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/testcase1_2_expRespTime.png}
			\caption{Mejora en el tiempo de respuesta debido a la ejecución de una estrategia}
			\label{fig:testcase1_2_expRespTime}
		\end{figure}

		De manera simultánea a la mejora en el tiempo de respuesta, el costo de servidores aumenta a 2, producto de la
		ejecución de la estrategia. Esto puede observarse en la figura \ref{fig:testcase1_2_cost}. 

		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/testcase1_2_cost.png}
			\caption{Impacto de la estrategia sobre el costo de servidores}
			\label{fig:testcase1_2_cost}
		\end{figure}

		En resumen, hasta aquí sea ha visto el comportamiento del sistema en las siguientes circunstancias:
		\begin{enumerate}
			\item sin información alguna sobre auto reparación.
			\item con un escenario definido pero sin estrategias que lo puedan reparar.
			\item con un escenario definido con una estrategia asociada.
		\end{enumerate}

		Antes de avanzar con casos de pruebas más sofisticados, cabe mencionar que los \emph{logs} generados por Arco Iris
		ofrecen la información necesaria para analizar en detalle los casos de pruebas presentados en este informe. Dada la
		extensión de dichos archivos, es inviable mostrarlos todos para cada caso de prueba, por lo cual, a modo de ejemplo,
		en el apéndice \ref{sec:logCasoPruebaArcoIris} se presenta un extracto del \emph{log} generado por Arco Iris para el
		caso que se acaba de detallar.

	\subsection{\emph{Tradeoff} entre Estrategias}
	
		\todo{Escribir sobre el caso de 1 escenario con dos estrategias compitiendo entre si (el codigo ya esta hecho)}

	\subsection{\emph{Tradeoff} entre Escenarios según Prioridades}

		El objetivo de esta prueba consiste en evaluar el comportamiento de Arco Iris ante la existencia de escenarios con
		distintas prioridades. 

		Para el presente caso de prueba, se toma como base la configuración del caso anterior con las siguientes
		modificaciones:
		\begin{itemize}
			\item El escenario preexistente asociado al tiempo de respuesta (ver figura \ref{fig:scenario_expRespTime}), contará
			ahora solamente con la estrategia \verb@EnlistServerResponseTime@,
			\item Se agrega un escenario de costo, el cual se puede observar en la figura \ref{fig:scenario_cost}, con una
			estrategia de reparación asociada, la cual, puede verse a continuación:
		\end{itemize}

		\begin{Verbatim}[gobble=3]
			strategy ReduceOverallCost {
			  t0: (true) -> dischargeServers(1) @[2000 /*ms*/] {
			    t1: (!COST_STILL_BROKEN) -> done;
			    t3: (default) -> TNULL;
			  }
			}
		\end{Verbatim}

		\begin{figure}[H]
			\centering
				\includegraphics[width=0.80\textwidth]{images/scenario_cost.png}
			\caption{Detalle de un escenario de costo de servidores}
			\label{fig:scenario_cost}
		\end{figure}

		En el apéndice \ref{sec:scenarioCostXML} podemos ver la representación de este escenario en XML.

		Para este caso de prueba en particular, es importante observar que el escenario de tiempo de respuesta es más
		prioritario que el de costo.

		En las figuras \ref{fig:testcase1_3_expRespTime} y \ref{fig:testcase1_3_cost} se puede observar el comportamiento
		del tiempo de respuesta y del costo, respectivamente, para la configuración actual.

		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/testcase1_3_expRespTime.png}
			\caption{Uso de prioridades favoreciendo al escenario de eficiencia sobre el de costo}
			\label{fig:testcase1_3_expRespTime}
		\end{figure}

		\begin{figure}[H]
			\centering
				\includegraphics[width=1.00\textwidth]{images/testcase1_3_cost.png}
			\caption{Reducción del costo como consecuencia de un cambio en el entorno}
			\label{fig:testcase1_3_cost}
		\end{figure}

		Recordemos que el escenario de tiempo de respuesta es el primero que deja de cumplirse, y que para que sea corregido
		debe levantarse un servidor, pero esto es justamente lo que acabamos de definir en el nuevo escenario que no debería
		ocurrir. ¿Cómo repararemos el tiempo de respuesta entonces? Aquí es donde entran en juego las prioridades de los
		escenarios: nuestro escenario prioritario será el del tiempo de respuesta, por lo cual este podrá repararse en
		detrimento del escenario del costo de servidores.

		Una vez reparado el tiempo de respuesta, el escenario de costo dejará de cumplirse y la auto reparación no intentará
		repararlo mientras que la utilidad del sistema en el estado actual sea mayor a la prevista en caso de repararlo. Esto
		hará que recién se repare el escenario de costo cuando esta reparación no rompa el escenario de tiempo de respuesta.
		
		En la figura \ref{fig:testcase1_3_cost} podemos observar cómo el sistema desactiva un servidor en el preciso momento
		en que el entorno de la aplicación cambia y el tiempo de respuesta mejora por razones ajenas a la auto reparación,
		aprovechando esto, Arco Iris logra satisfacer así un escenario que estaba sin cumplirse, sin perjudicar a ninguno de
		los escenarios que se estaban cunmpliendo hasta ese momento.

		Como podemos observar en el gráfico presentado a continuación, efectivamente era factible bajar un servidor sin que se
		dejara de satisfacer el escenario de tiempo de respuesta, llegando así al estado ideal en que ambos escenarios se
		satisfacen simultáneamente. Si bien el tiempo de respuesta sufre un pequeño detrimento al trabajar el sistema con un
		servidor menos, los valores obtenidos siguen siendo suficientemente buenos debido a los cambios que se han suscitado
		en el entorno en que funciona el sistema, sin ninguna intervención de la auto reparación. En resumen, al configurar
		los escenarios más prioritarios permitimos a Arco Iris tomar la decisión de qué escenario reparar en cada instante y
		con qué estrategia. En la figura \ref{fig:testcase1_3_expRespTime} podemos observar un ejemplo concreto de la potencia
		de definir prioridades entre escenarios.

		En la figura \ref{fig:testcase1_3_cost} podemos observar cómo el sistema desactiva un servidor en el preciso momento
		en que el entorno de la aplicación cambia y el tiempo de respuesta mejora por razones ajenas a la auto reparación,
		aprovechando esto, Arco Iris logra satisfacer así un escenario que estaba sin cumplirse, sin perjudicar a ninguno de
		los escenarios que se estaban cunmpliendo hasta ese momento.
		
		Esto nos muestra cómo pueden convivir varios escenarios, y cómo Arco Iris sabrá detectar cual será la estrategia que
		le permitirá maximizar la utilidad del sistema gracias a la configuración de escenarios y sus respectivas prioridades.

	\subsection{\emph{Tradeoff} entre Escenarios según \emph{Concerns} }

		\todo{Implementar el caso en que las prioridades son iguales y el algoritmo decide por peso del concern de un
		escenario en particular}
		
	\subsection{Comportamiento Ante Los Cambios en el Entorno de Ejecución}

		\todo{Implementar un caso de dos escenarios de distinto concern y distinto entorno (normal vs. alta carga) y ver como
		al ppio solo intenta arreglar el de normal y luego pasa a darle bola al de high load}
	
	