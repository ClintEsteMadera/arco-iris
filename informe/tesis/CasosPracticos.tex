\section{Casos Prácticos}\label{CasoPracticoSection}

	En este capítulo se presenta un ejemplo concreto de utilización de Arco Iris, para lo cual se reutilizará la simulación que forma parte del proyecto Znn.
	El sistema consiste en sitio de noticias y la simulación nos permite manejar variables tales como la cantidad de servidores, la fidelidad de la información que se provee, o sea, permite eliminar determinado tipo de contenido (e.g: videos) para mejorar el tiempo de respuesta experimentado por el usuario del sitio.
	
	Antes de comenzar, cabe aclarar que si bien deberíamos configurar los pesos de cada uno de los \emph{concerns} existentes en Znn, a los efectos prácticos de este ejemplo los ignoraremos, pero lo que en realidad estará sucediendo en la simulación es que todos los \emph{concerns} tienen el mismo peso. Esto nos permitirá poder concentrarnos en las prioridades entre escenarios a la hora de escoger la estrategia candidata a reparar el sistema.

	\subsection{Arquitectura del Sistema}

\todo{TURCO: agregar la imagen de la arquitectura tomada del AcmeStudio}

\todo{TURCO: agregar el .acme del sistema utilizado. Poner en Apendix?}
	
	\subsection{Comportamiento del Sistema sin Auto Reparación}
	Comenzaremos considerando cómo se comporta el sistema al no existir escenarios ni estrategias, esto nos permitirá evaluar la variación de comportamiento al ir agregando escenarios y estrategias.
	Para simplificar el ejemplo, los datos que nos interesarán serán el tiempo de respuesta experimentado por el usuario y el costo de servidores del sistema, que en este caso reflejará simplemente la cantidad de servidores levantados con que cuenta el sistema en cada momento.
	
	Entonces, el comportamiento del sistema sin escenarios, o sea, sin autoreparación será el siguiente:
	\begin{center}
		\includegraphics[width=1.00\textwidth]{images/testcase1_1_expRespTime.png}
	\end{center}
	
	\begin{center}
		\includegraphics[width=1.00\textwidth]{images/testcase1_1_cost.png}
	\end{center}

	Como podemos observar, el tiempo de respuesta crece hasta superar los 600ms, man\-te\-nién\-do\-se así por unos 10 segundos, luego el mismo va bajando escalonadamente hasta estacionarse en 360ms. Notar que el costo de los servidores se mantuvo inmutable frente a los cambios en el tiempo de respuesta, o sea que el sistema trabajó siempre con un único servidor.

	\subsection{Comportamiento del Sistema con un único Escenario}
	
	Ahora que ya vimos cómo se comportaría el sistema sin escenarios definidos, pasemos a definir nuestro primer escenario. El mismo consistirá en determinar un umbral (\emph{threshold} de 600ms para el tiempo de respuesta experimentado por el usuario. Tengamos en cuenta que aún no hemos definido ninguna estrategia, por lo cual se detectará que existe un escenario que no se está cumpliendo pero no se encontrará ninguna estrategia que lo pueda reparar. A continuación se muestra el detalle del escenario creado:
		
	\begin{center}
		\includegraphics[width=0.80\textwidth]{images/scenario_expRespTime.png}
	\end{center}
	
	Al no existir ninguna estrategia, el costo de servidores no se verá modificado, por lo cual el gráfico será el mismo que el del caso anterior, salvo que permite observar en qué momento se supera el umbral determinado para el tiempo de respuesta:

	\begin{center}
		\includegraphics[width=1.00\textwidth]{images/testcase1_1_expRespTime_threshold.png}
	\end{center}
	
	\todo{TURCO: ver porqué no se comportó igual al grafico sin escenarios???}
	
	\todo{JONY/TURCO: Mostramos log o lo ponemos en el Apendice???}
	
	\subsection{Comportamiento del Sistema con un único Escenario y una única Estrategia}

	El próximo paso será definir una estrategia que pueda actuar cuando el escenario planteado deje de cumplirse. La misma consistirá simplemente en agregar un servidor, siempre y cuando existan servidores disponibles. La estrategia, definida en Stitch, será la siguiente:
	
	\begin{verbatim}	
		strategy EnlistServersResponseTime
		[ styleApplies ] {
		  t0: (true) -> enlistServers(1) @[5000 /*ms*/] {
		    t1: (!RESP_TIME_STILL_BROKEN) -> done;
		    t2: (default) -> TNULL;
		  }
		}
	\end{verbatim}

	Al agregar esta estrategia, observamos que el tiempo de respuesta experimentado por el usuario se corrige casi instantáneamente, como podemos ver en el siguiente gráfico:
	
	\begin{center}
		\includegraphics[width=1.00\textwidth]{images/testcase1_2_expRespTime.png}
	\end{center}

	Desde ya que este comportamiento se debe a la aplicación de la estrategia, el siguiente gráfico nos muestra cómo varía el costo de servidores al aplicarse la estrategia, simultáneamente con la mejora del tiempo de respuesta:
	
	\begin{center}
		\includegraphics[width=1.00\textwidth]{images/testcase1_2_cost.png}
	\end{center}

	En resumen, lo que hemos visto hasta aquí consiste en:
	\begin{enumerate}
		\item Comportamiento del sistema sin ninguna información de auto reparación.
		\item Comportamiento del sistema con un escenario definido pero sin estrategias que lo puedan reparar.
		\item Comportamiento del sistema con un escenario definido y con una estrategia que lo repara.
	\end{enumerate}
	
	\subsection{Tradeoff entre Estrategias}

	Ahora bien, si analizamos el comportamiento del tiempo de respuesta, vemos que a partir de un determinado momento las condiciones del sistema cambian, lo cual hace que el tiempo de respuesta baje sin incumbencia de la auto reparación. Esto hace que el escenario de tiempo de respuesta se siga cumpliendo, pero observemos que el sistema sigue funcionando con dos servidores, cuando en realidad es muy probable que pueda cumplir con las necesidades de performance con uno solo. Entonces, ¿por qué no minimizar el costo de los servidores? Pues lograremos esto definiendo otro escenario cuya restricción consistirá en que no exista más de un servidor levantado. El escenario que crearemos será el siguiente:
	
	\todo{TURCO: agregar imagen de ScenarioUI del escenario de server cost}

	Antes que nada, recordemos que el escenario de tiempo de respuesta es el primero en romperse, y que para ser corregido debe levantarse un servidor pero esto es justamente lo que acabamos de definir en el nuevo escenario que no debería ocurrir. ¿Cómo reparemos el tiempo de respuesta entonces? Aquí es donde entra en juego las prioridades de los escenarios: nuestro escenario prioritario será el del tiempo de respuesta, por lo cual este podrá repararse en detrimento del escenario del costo de servidores.
	
	Una vez reparado el tiempo de respuesta el escenario del costo quedará roto, pero la auto reparación no intentará repararlo mientras que la utilidad del sistema en el estado actual sea mayor a la prevista en caso de reparar el escenario de costo. Esto hará que recién se repare dicho escenario cuando esta reparación no rompa el escenario de tiempo de respuesta.