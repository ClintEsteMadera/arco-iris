\section{Introducción}

	\subsection{Motivación para este trabajo}

		La complejidad creciente de los sistemas de software desafía de forma permanente el estado del arte de las Ciencias de
		la Computación y la Ingeniería del Software. La velocidad con la que se producen los cambios, la criticidad de las
		fallas que suelen suscitarse y la necesidad de mantener sistemas funcionando de manera continua a pesar de no
		pertenecer a lo que tradicionalmente se conoce como ``sistemas de misión crítica'' ha llevado a los investigadores a
		buscar novedosas formas de resolver estos desafíos. Una de ellas es la tendencia hacia los sistemas autónomos, que
		recibe distintos nombres como ``Computación Autónoma'', ``Software consciente'' o ``Sistemas Auto Reparables'' (``Self
		Healing'', en inglés). En sintonía con esta profusión de vocablos, existen distintos términos para referirse a las
		acciones realizadas por estos sistemas: ``Auto Adaptación'', ``Auto Configuración'', ``Auto Reparación'', etc. En el
		transcurso del presente trabajo, usaremos los términos ``auto reparación'' y ``auto adaptación'' como sinónimos, pese a
		que ambos poseen semánticas ligeramente diferentes pero que no son relevantes para el alcance de este trabajo. Existe
		una cantidad en aumento de especialistas en el mundo \cite{Dawning} que creen que la necesidad de implementar este
		tipo de mecanismos está dando lugar al nacimiento de una nueva era en los sistemas de software.

		La idea subyacente detrás de los nombres antes mencionados es que los sistemas incluyan mecanismos para ajustar su
		comportamiento a partir de fallas o necesidades cambiantes de sus usuarios y/o el entorno en el que operan. De esta
		forma, un sistema puede repararse u optimizarse sin intervención humana. Una de las formas de implementar estos
		mecanismos es la llamada ``Adaptación Basada en Modelos	de Arquitecturas''.
		\cite{ModelBasedAdaptation4SelfHealingSystems} En este tipo de soluciones, existe un módulo que conoce e interpreta
		el modelo de la arquitectura del sistema a adaptar y, sobre la base de este conocimiento y el problema detectado, toma
		una decisión sobre cómo reparar al sistema en cuestión.

		Si bien ya existen soluciones de este tipo, en ninguna se considera la participación de los
		\emph{stakeholders}\footnote{Típicamente: representantes del cliente, el equipo de arquitectura, representantes de los
		usuarios finales, operadores y administradores del sistema, \emph{managers}, \emph{testers}, el \emph{sponsor} del
		proyecto, etc.} en el proceso de detección y corrección automática de errores. Esto motivó el presente trabajo, donde
		se intenta ofrecer una forma de incluir a los \emph{stakeholders} en el proceso, siempre considerando que su
		participación debe contribuir principalmente en la definición de los potenciales problemas y sus posibles soluciones.
		Para esto, se consideró el uso de los denominados ``Escenarios de Atributos de Calidad'' (QAS, de sus siglas en
		inglés, \emph{Quality Attribute Scenarios})\cite{BassClementz}; los cuales permiten definir cómo debería responder el
		sistema, entre otras cosas, ante determinados estímulos y en ciertos entornos de ejecución. Se profundizará sobre el
		concepto de QAS en la sección \ref{sec:QAS}.

		Una vez definidos los escenarios por los \emph{stakeholders}, el paso siguiente consiste en utilizar toda esa
		información en tiempo de ejecución para que el sistema sea capaz de auto repararse. Allí nos servimos de un
		\emph{framework} existente de auto reparación basada en modelos de arquitecturas llamado
		\textbf{Rainbow}.\footnote{Página web oficial de Rainbow: \url{http://www.cs.cmu.edu/~able/research/rainbow/}} Rainbow
		propone una manera estática y poco amigable de configurar la información necesaria para tomar decisiones de auto
		reparación en tiempo de ejecución. Así, el objetivo planteado es superar algunas de dichas limitaciones mediante el
		agregado del concepto central de este trabajo: los ``Escenarios de Atributos de Calidad'' como forma fundamental de
		expresar el conocimiento de los \emph{stakeholders} referido a requerimientos que deben ser contemplados por la
		arquitectura. El objetivo final que se persigue es involucrar a dichos actores en el proceso de Auto Reparación y
		proveerles una mayor visibilidad de las posibles consecuencias que dicho proceso conlleva en el desempeño del sistema.		El objeto del presente trabajo, al cual denominaremos ``Arco Iris'', es el extender el comportamiento original de		Rainbow modificando ciertos componentes del \emph{framework} para que admitan nuevos conceptos que se explicarán más		adelante.
	\subsection{Organización del presente trabajo}

		El presente trabajo consta de cinco partes principales, a saber:
		\begin{enumerate}
			\item \textbf{Conceptos Preliminares:} en esta sección se introducen todos los conceptos, \emph{frameworks},
			herramientas y metodologías necesarias para comprender el trabajo en su conjunto.
			\item \textbf{Extensión a Rainbow:} aquí se explican en detalle los objetivos de la extensión realizada a Rainbow
			(llamada ``Arco Iris''), su implementación y los problemas que dicha extensión intenta resolver.
			\item \textbf{Interfaz Gráfica para ``Arco Iris'':} En esta parte del trabajo se justifica la inclusión de una
			interfaz gráfica de usuario para facilitar la participación de los \emph{stakeholders} no técnicos; así como también
			se detallan los alcances y limitaciones de la herramienta, bautizada ``Arco Iris UI''.
			\item \textbf{Casos Prácticos:} En esta sección del trabajo se describen y analizan varios casos de prueba del
			sistema Arco Iris. Dichas pruebas utilizan un sistema ficticio llamado ``Znn'', desarrollado en una tesis de
			doctorado de la Universidad de Carnegie Mellon \cite{TesisOwen}, el cual provee las condiciones de simulación
			necesarias para poder analizar la extensión realizada a Rainbow de una manera sencilla y efectiva.
			\item \textbf{Trabajo Futuro y Conclusiones:} En la parte final del presente trabajo se establecen conclusiones con
			respecto al nivel de cumplimiento de los objetivos que motivaron el trabajo y a la factibilidad de implementación de
			esta extensión (y, obviamente, de Rainbow) en un sistema real. También se enumeran puntos de continuación, estos son,
			puntos donde se tomaron decisiones tendientes a acotar el problema pero para los cuales se reconocen posibilidades de
			continuación, mejora, refinamiento, etcétera.
		\end{enumerate}