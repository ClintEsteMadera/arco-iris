\section{Trabajo Futuro}
\label{sec:trabajoFuturo}

	Si bien con la introducción de las extensiones presentes en Arco Iris se han presentado considerables mejoras con
	respecto al uso básico de Rainbow, también se han suscitado numerosos puntos de extensión posibles que si bien no
	pudieron formar parte del presente trabajo, es importante que los mismos sean detallados en pos de incentivar la
	investigación futura sobre los mismos. A continuación, citaremos los puntos de extensión posibles a Arco Iris y/o
	Rainbow.

	\subsection{Compatibilidad hacia atrás}

			\todo{Al final no es ni compatible hacia atras ni plugin, explicar}

			Uno de los objetivos de diseño más importantes planteados al momento de pensar Arco Iris fue sin duda el intentar que
			la presente extensión fuera ``compatible hacia atrás'' con \emph{Rainbow}, pudiendo en este caso el usuario, de
			manera relativamente simple, poder elegir entre utilizar los mecanismos de auto reparación provistos por Arco Iris de
			manera aislada, conjuntamente con los de Rainbow, o usar únicamente Rainbow. La implementación de Arco Iris cumple con dicho
			requerimiento ya que extiende (en el sentido estricto de la palabra) y/o modifica componentes , sin cambiar su lógica
			original.
			

			es decir, es altamente deseable que la
			extensión se inserte en el \emph{framework} (conceptualmente hablando) de manera similar a cómo un \emph{plug-in}
			trabaja en cualquier otro sistema de \emph{software}
			
			Es importante notar que para que la extensión sea fácilmente adicionable y/o removible se necesitaría hacer mínimos
			cambios a la visibilidad de algunos componentes de Rainbow (i.e. clases Java), ya que su
			implementación está hecha de tal manera que impide la extensión, ya sea vía herencia o composición de clases.


	\subsection{Análisis y Aprendizaje de la Auto Reparación}

		\subsubsection{Herramientas de análisis y visualización}

			Supongamos que los \emph{stakeholders} ya han definido todos los escenarios que se utilizarán en la reparación via
			Arco Iris. Ahora bien, imaginemos que existe un escenario cuya prioridad es muy alta y a su vez las condiciones
			necesarias para que no se cumpla se dan con mucha frecuencia. Esto resultará en la auto reparación repetida del
			mencionado escenario. Pero ¿qué sucedería si la única que estrategia que repara dicho escenario rompe constantemente
			otros, digamos 3 escenarios de menor prioridad? A priori pareciera que este es el comportamiento esperado, pero
			¿podrían los \emph{stakeholders} convalidar este comportamiento? Claramente se necesitan una serie de estadísticas que
			nos permitan analizar lo que se está reparando, y el impacto sobre los escenarios perjudicados, y también sería
			necesaria una vista sobre el impacto en cada uno de los \emph{concerns} del sistema.
			
			También sería útil proveer una herramienta que permita analizar que estrategias se fueron ejecutando, y cómo se llegó
			a decidir que cada estrategia era la adecuada para reparar el sistema en cada momento. Otra vista que sería útil para
			analizar la configuración de la auto reparación del sistema podría ser un \emph{ranking} de estrategias, en el que	se
			presente el porcentaje de éxito de cada una así como la cantidad de veces que se ejecutó, como quedó el \emph{Utility
			Function} en promedio luego de ejecutar la estrategia, etc.

		\subsubsection{Mecanismo Inteligente de Detección de Estrategias Fallidas}

			\todo{Acá habría que explicar qué hay hoy en Rainbow y pq es insuficiente o poco flexible. Asegurarse que Rainbow
			no vuelve a usar las estrategias fallidas. La idea de las alarmas no me gusta: esto es para que los admines tengan
			que laburar menos\ldots }
			

			Por otro lado, supongamos que bajo la misma situación, la única estrategia que aplica para reparar el escenario falla
			en un 95\% de los casos, ¿tiene sentido continuar ejecutando dicha estrategia teniendo en cuenta cómo afecta la
			\emph{performance} del sistema y de la auto reparación? Una solución sencilla sería permitirle definir al usuario un
			umbral de	fallos, por ejemplo definiendo que si una estrategia falla el 90\% de los intentos o más, la misma queda
			eliminada de las estrategias candidatas. Si bien lo mencionado en el último párrafo ya se encuentra implementado en
			Rainbow, consideramos que la implementación es bastante básica y poco flexible. Por ejemplo sería útil que antes de
			llegado a ese punto, se notifique, a modo de alarma, al responsable de la auto reparación de que una estrategia ha
			estado fallando. Podrían existir sucesivas alarmas antes de desactivar la estrategia.

	\subsection{Configuración Dinámica}

		\todo{No alcanza con la UI (y su XML asociado) para configurar 100\% nuestra solución (hace falta configurar cosas por
		fuera)}
		
		Cuando se desarrolla un sistema se hacen supuestos, se presupone un determinado comportamiento que casi
		indefectiblemente variará cuando el sistema se esté ejecutando: errores del sistema, cambios en el entorno (variación
		de recursos), cambios en las preferencias del usuario, etc. El reconocimiento de dichas presunciones es clave, ya que
		esto acercará al sistema al ``mundo real''. El conocimiento de estos supuestos será muy importantes a la hora de
		reparar el sistema, más aún si se desea implementar un mecanismo de auto reparación flexible y dinámico.

		\todo{La siguiente propuesta debe ser refinada ya que algo hicimos con respecto a esto\ldots}

		Dicho esto, se propone como trabajo a futuro dinamizar la configuración de auto reparación de Arco Iris, permitiendo
		que los \emph{stakeholders} modifiquen los escenarios en caliente, es decir, sin necesidad de detener el \emph{framework}.
		Esto es importante ya que de requerir un sistema alta disponibilidad, no podrá darse el lujo de que el mecanismo de
		auto reparación que utilice sea detenido para reconfigurarlo, sino que debe adaptarse a las nuevas condiciones
		prácticamente sin \emph{impasse}.
		
		\todo{Externalizar MIN\_UTILITY\_THRESHOLD y FAILURE\_RATE\_THRESHOLD (Ver AdaptationManager.java)}

	\subsection{Ampliación de la Configuración Existente}

		\todo{Permitir agregar \emph{concerns} nuevos}\\
		\todo{leer los \emph{artifacts} y sus properties desde el .ACME}\\
		\todo{agregar mas tipos de \emph{constraints}}\\
	
	\subsection{Flexibilización del Entorno}

		\todo{Expandir la idea del ``system environment'' (tenemos una implementación muy restrictiva, no se pueden solapar
		e.g. alta carga y super alta carga).}

	\subsection{Configuración de Escenarios en AcmeStudio}

		Actualmente existe una herramienta de creación y edición de arquitecturas modeladas en Acme, llamada
		\textbf{AcmeStudio} \footnote{Para más información acerca de AcmeStudio, visitar
		\url{http://www.cs.cmu.edu/~acme/AcmeStudio}} la cual se encuentra integrada en la popular herramienta de desarrollo
		Eclipse\footnote{Para más información acerca de Eclipse, visitar \url{http://www.eclipse.org}} como un \emph{plug-in}.

		Se propone como trabajo a futuro extender la herramienta AcmeStudio para que dé soporte a las extensiones propuestas
		en el presente trabajo, permitiendo así la integración del modelado de la arquitectura con el modelado de los
		escenarios que la complementan, utilizando la misma herramienta.

	\subsection{Optimización en la Selección de la Estrategia}

		\todo{Se deja para el final: cómo seleccionar la mejor estrategia (Lo del ``utility function'' es limitado)}

	\subsection{Rainbow y Arco Iris ``Trabajando en Conjunto''}
	
		\todo{hablar sobre arcoIrisSolutionWeight y rainbowSolutionWeight}