\section{Trabajo Futuro}
\label{sec:trabajoFuturo}

	Si bien con la introducción de las extensiones presentes en Arco Iris se han presentado considerables mejoras con
	respecto al uso básico de Rainbow, también se han suscitado numerosos puntos de extensión posibles que si bien no
	pudieron formar parte del presente trabajo, es importante que sean detallados en pos de incentivar la investigación
	futura. A continuación, citaremos los puntos de extensión posibles a Arco Iris y/o Rainbow.

	\subsection{Arco Iris: un \emph{plug-in} de Rainbow}

			Una característica deseable para Arco Iris es, sin duda, que la extensión se inserte en el \emph{framework}
			(conceptualmente hablando) de manera similar a cómo un \emph{plug-in} trabaja en cualquier otro sistema de
			\emph{software}, pudiendo el usuario, de manera relativamente simple, elegir entre utilizar los mecanismos de auto
			reparación provistos por Arco Iris o los de Rainbow.

			Para que esto sea posible, es necesario que Rainbow provea una arquitectura abierta a la extensión de sus componentes
			claves, como ser el \verb@AdaptationManager@, el \verb@RainbowModel@ y \verb@GaugeCoordinator@, entre otros.

			A continuación, se enumeran algunos de los motivos por los cuales Rainbow, en la actualidad, no permite extensiones
			de tipo \emph{plug-in}:
			\begin{enumerate}
				\item Rainbow no trabaja orientado a interfaces, tal como Erich Gamma explica en \cite{DesignPatterns}, observando
				así un alto acoplamiento entre las clases que conforman su diseño y la consecuente imposibilidad de cambiar las
				implementaciones por defecto por otras nuevas.
				\item El mecanismo utilizado por los componentes de Rainbow para obtener referencias a otros componentes con los que
				desean interactuar, implementado en una clase Java denominada \verb@Oracle@), es insuficiente para permitir la
				inyección de diferentes implementaciones del mismo componente. Esto es un error de diseño íntimamente relacionado
				con el punto anterior.
				\item Muchos de los componentes básicos de Rainbow, los cuales se modelan como clases Java, impiden explícitamente
				su extensión (i.e. herencia) mediante modificadores de acceso restrictivos.
			\end{enumerate}

			A modo de conclusión, sería muy positiva una reestructuración de Rainbow para permitir extensiones o agregados al
			mismo de una manera más prolija y ordenada que la que tuvo que utilizarse para la creación de Arco Iris.

	\subsection{Análisis y Aprendizaje de la Auto Reparación}

		\subsubsection{Herramientas de análisis y visualización}

			Supongamos que los \emph{stakeholders} ya han definido todos los escenarios que utilizará Arco Iris para gestionar la
			auto adaptación de un sistema dado. Ahora bien, imaginemos que existe un escenario de muy alta prioridad y a su vez
			las condiciones necesarias para que no se cumpla se dan con mucha frecuencia. Esto posiblemente resulte en la auto
			reparación repetida del mencionado escenario. Pero, ¿qué sucedería si la única estrategia que repara dicho escenario
			``rompe'' constantemente otros, digamos tres, escenarios de menor prioridad? A priori pareciera que este es el
			comportamiento esperado, pero\ldots ¿podrían los \emph{stakeholders} convalidar este comportamiento? Claramente la
			implementación actual de Arco Iris carece de una serie de \textbf{estadísticas y vistas} que permitan analizar lo que
			está siendo reparado, así también como el impacto sobre los escenarios perjudicados y sobre cada uno de los
			\emph{concerns} del sistema.

			También sería útil proveer una herramienta que permita analizar qué estrategias se fueron ejecutando históricamente,
			y de qué manera se llegó a decidir que cada una de ellas era la adecuada para reparar el sistema en cada momento.

		\subsubsection{Más Visibilidad Sobre Las Estrategias Fallidas}

			Tal como se comentó en la sección \ref{sec:failureRate}, Rainbow provee un mecanismo que considera la historia de
			ejecución de las estrategias con el objetivo de evitar elegir aquellas con un alto porcentaje histórico de fallas,
			esto es, estrategias que no resolvieron anteriormente las anomalías que se suponía debían resolver.
			
			Si bien este mecanismo es bastante aceptable, el mismo podría ser mejorado en el futuro en dos aspectos:
			\begin{itemize}
				\item El porcentaje de fallas máximo permitido para que una estrategia pueda ser considerada debe ser configurado
				por el usuario final. La forma más simple de hacer esto es sencillamente externalizando este valor al archivo de
				configuración de la aplicación ya existente (\verb@rainbow.properties@). Este trabajo no se ha encarado en el
				presente trabajo, puesto que implica la modificación (en contraposición a una extensión) de una clase
				específica de Rainbow. Es conveniente que las modificaciones al núcleo de Rainbow sean realizadas por el grupo de
				gente a cargo de su mantenimiento evolutivo.
				\item Este mecanismo provee poca visibilidad al usuario final. Una posible idea para analizar la
				configuración de la auto reparación del sistema podría ser un \textbf{\emph{ranking} de estrategias}, en el que se
				presente el porcentaje de éxito y fallas de cada una así como la cantidad de veces que se ejecutó, cuál es la
				utilidad del sistema promedio luego de ejecutar la estrategia, etc.
				\item Otra posible idea podría ser el proveer una suerte de alarma al usuario administrador (vía e-mail por ejemplo)
				que, previamente a desactivar una estrategia o luego de haber desactivado reiteradas veces la misma estrategia,
				avise sobre este tipo de situaciones, haciendo explícito este tipo de decisiones cruciales y permitiendo así la
				rectificación o ratificación de la configuración de \emph{self healing} que está siendo utilizada.
			\end{itemize}

	\subsection{Ampliación de la Recarga Dinámica de Configuración}

		En la sección \ref{sec:actualizacionDinamicaConfig} se explicó el trabajo hecho en Arco Iris en materia de recarga
		automática de la configuración. Recordemos que se implementó un mecanismo que refresca la configuración relativa a
		Escenarios, Entornos, \emph{Artifacts} y las referencias a las estrategias asociadas a cada escenario. Si bien tal
		mecanismo representa una mejora sustancial con respecto a Rainbow (el cual recordemos que no provee ningún tipo de
		recarga ``en caliente'' de la configuración) entendemos que se puede dar un paso más en la materia, a fin de que el
		\emph{framework} resulte más útil para su uso en un ambiente tan dinámico como el de la industria del \emph{software};
		dónde el reiniciar la aplicación para aplicar un cambio en la configuración resulta muchas veces sencillamente
		inaceptable. En consecuencia, es altamente deseable tender a \textbf{recargar dinámicamente el 100\% de la
		configuración relacionada con auto reparación}. Los cambios necesarios para lograr ésto deben llevarse a cabo
		principalmente en Rainbow, dónde reside el grueso de la configuración estáticamente cargada.

		Rainbow actualmente maneja (a grandes rasgos) los siguientes puntos de configuración:
		\begin{itemize}
			\item el archivo \verb@rainbow.properties@, un típico archivo \verb@.properties@ de Java, el cual es leído una única
			vez al inicializarse el \emph{framework} y que sirve para externalizar propiedades tales como el nivel de \emph{log}
			deseado para la aplicación, el \emph{path} en dónde buscar estrategias y tácticas, el archivo \verb@.acme@ con el
			modelo de la arquitectura del sistema a adaptar, etc. En este caso, sería relativamente sencillo implementar un
			mecanismo de recarga dinámica idéntico al explicado en detalle en la sección \ref{sec:actualizacionDinamicaConfig}
			para recargar la configuración de Arco Iris. El mismo tendría que ser realizado en el constructor de la clase
			\verb@Rainbow)@.
			\item \verb@utilities.yml@, dónde se configuran las curvas de utilidad para el sistema. Al igual que en el caso
			anterior, estas propiedades se leen en el constructor de la clase \verb@Rainbow@ utilizando una clase \emph{helper}
			llamada \verb@YamlUtil@. Utilizando el mismo mecanismo descrito anteriormente se podría dinamizar también la recarga
			dinámica de este archivo.
			\item archivos Stitch (con extensión \verb@.s@) de tácticas y estrategias. La lógica de lectura de tácticas y
			estrategias está ubicada en el \verb@AdaptationManager@. Puesto que en Arco Iris se necesitó extender esta clase, se
			aprovechó la oportunidad para abstraer esta lógica de lectura desde un archivo, a una clase específica llamada
			\verb@StitchLoader@, la cual tiene la responsabilidad no sólo de cargar los datos desde un archivo sino de proveer
			también acceso a los mismos. Sería una buena idea el incorporar esta clase al código base de Rainbow puesto que dicha
			abstracción provee la posibilidad de incorporar rápidamente el mecanismo de refresco mencionado ya reiteradas veces.
			Actualmente dicho comportamiento tampoco está incorporado en Arco Iris, no porque sea un trabajo difícil sino debido
			a que dicha tarea se encuentra afuera del alcance del presente trabajo.
		\end{itemize}

		Como podemos observar, el mecanismo explicado en detalle en la sección \ref{sec:actualizacionDinamicaConfig} es
		fácilmente reutilizable y también observamos posibilidades de mejora del mismo para simplificar aún más su uso
		extendido en todo el \emph{framework}.

	\subsection{Ampliación de la Configuración Existente}
	\label{sec:ampliacionConfiguracionExistente}

		A lo largo del desarrollo del presente trabajo, hemos notado que existen algunas posibilidades de ampliar la
		configuración existente en Arco Iris. A continuación, mencionaremos algunos de ellos.

		\subsubsection{Toda la configuración en un solo archivo}
		\label{sec:todaLaConfigEnUnSoloArchivo}

			A fin de simplificar el uso del \emph{framework} para el usuario final, es altamente deseable poder reducir la cantidad
			de archivos de configuración que deben ser creados, modificados y/o mantenidos para que el tándem Rainbow / Arco Iris
			funcione. Sería deseable realizar modificaciones en ambos \emph{frameworks} para que la configuración se encuentre
			centralizada en uno (idealmente) o dos archivos de configuración; conglomerando allí información referente a tácticas,
			estrategias, el modelo de la arquitectura y todo el modelo existente de Arco Iris, actualmente configurable via XML.

		\subsubsection{Mas tipos de restricciones por defecto}

			En Arco Iris los tipos de restricciones - debido a su inherentemente compleja lógica - están codificados en clases Java
			que, en conjunto, configuran el abanico de restricciones soportadas por el \emph{framework}. Actualmente se provee
			soporte para un tipo solo de restricción: aquella que modela una restricción sobre el valor de una propiedad de un
			artefacto, con respecto a una función binaria numérica como por ejemplo los operadores $<$, $\le$, $>$, $\ge$ y
			$=$.\\ Si bien este tipo de restricciones son altamente representativas del tipo de cosas sobre las que un usuario
			promedio normalmente desea predicar, es de notar que el poder expresivo está claramente acotado. Se propone para un
			trabajo futuro extender el esquema de restricciones modelado en Arco Iris, mediante nuevas implementaciones de la
			interfaz \verb@Constraint@.

	\subsection{Atributos de Calidad y \emph{Concerns} configurables por el usuario}

		Actualmente Arco Iris maneja un conjuntos fijo de Atributos de Calidad y \emph{Concerns}, los cuales se encuentran
		embebidos en clases Java a las cuales el usuario final no puede acceder. En otras palabras, el usuario no puede
		agregar o eliminar libremente Atributos de Calidad o \emph{Concerns}. Claramente, esta rigidez restringe la usabilidad
		del \emph{framework} y debe ser superada.

		Puesto que en Arco Iris los \emph{concerns} juegan un papel más preponderante que los Atributos de Calidad, en este
		apartado nos referiremos únicamente al problema de permitir que el usuario final de Arco Iris pueda agregar o eliminar
		\emph{Concerns} a una configuración de \emph{Self Healing}.

		Existen básicamente dos formas de compensar la falencia antes mencionada: una es sencilla de implementar pero
		incompleta y la otra es difícil de implementar aunque definitiva.

		\subsubsection{Implementación sencilla e incompleta}

			El agregado de una amplia y variada gama de \emph{Concerns} en el código fuente de Arco Iris representa una buena
			solución de compromiso entre máxima flexibilidad para el usuario y facilidad de implementación, ya que sólo se trata
			de recabar una lista de los \emph{Concerns} más conocidos y usualmente utilizados y agregarlos a la clase enumerada
			que modela los tipos posibles de \emph{Concerns} reconocidos por Arco Iris.

		\subsubsection{Implementación difícil y definitiva}

			El problema de permitir el libre agregado y eliminación de \emph{Concerns} por parte del usuario posee varios
			aristas, algunas de las cuáles no son fáciles de resolver, a saber:

			\begin{itemize}
				\item \textbf{Actualización del mapa $<$Concern,Weight$>$ en todos los Entornos}

					Al agregar un concern al sistema, se suscita la duda sobre qué hacer con el mapa\\
					\verb@<Concern,Weight>@ de cada uno de los Entornos ya existentes en el sistema.

					Una posible opción sería cambiar la semántica actual de dicho mapa y que el mismo pase a almacenar únicamente
					aquellos pesos que son distintos de cero, en otras palabras, al no encontrarse en el mapa un valor para un
					determinado \emph{Concern}, se sobreentiende que su peso relativo es 0 (cero).

					Existe otra opción que no cambia la semántica de los mapas (i.e. todos los \emph{Concerns} seguirían siendo
					enumerados por extensión) y para eso se vale de la herramienta Arco Iris UI. Básicamente, al agregar un nuevo
					\emph{Concern}, Arco Iris UI automáticamente lo agregaría también en los mapas de todos los Entornos existentes en
					el sistema, pero\ldots ¿con qué peso? ¿con peso cero? ¿con un peso por defecto configurable al crear el concern? ¿se
					obligaría al usuario a configurar el peso en todos los Entornos? En el caso de eliminación, ¿qué ocurre con el peso
					del \emph{Concern} eliminado? ¿se reparte entre los restantes \emph{concerns}? Pensemos además en lo engorroso que
					serían todo este tipo de reajustes en la configuración para un usuario que no utiliza Arco Iris UI\ldots

					Éstas y otras preguntas son las que alguien encargado de flexibilizar la configuración de \emph{Concerns} debería
					responder y, por ese motivo, preferimos sólamente plantearlas y dejar su resolución abierta.

				\item \textbf{Actualización del \emph{Concern} de Escenarios}

					En el caso de dar de baja un \emph{Concern} lo más razonable sería que Arco Iris UI lo elimine automáticamente de
					todos los Entornos, aunque cabe preguntarse: ¿qué ocurre con los escenarios que estaban relacionados con este
					\emph{Concern}? ¿deben darse de baja? ¿debe forzarse su actualización? Nuevamente, si el usuario no usara Scenarios
					UI, el mantenimiento de la configuración podría tornarse dificultoso.

				\item \label{asignacionEquidistribuidaPesos} \textbf{Asignación equidistribuída de pesos para un Entorno nuevo}

					En Arco Iris, al construir una instancia de \verb@Environment@, se invoca a una función llamada
					\verb@createMapWithEquallyDistributedWeights@ que inicializa el mapa de pesos del Entorno de manera equidistribuída
					entre todos los entornos (e.g. si hay 3 \emph{Concerns} en el sistema, asigna $0.\wideparen{33}$ a cada uno).

					Esta decisión de diseño si bien es razonable, es también mejorable: esto podría ser configurable por el usuario del
					\emph{framework} para poder adaptar mejor la configuración por defecto a los intereses particulares de cada
					sistema. Por ejemplo: es probable que un sistema financiero le otorgue más prioridad a los \emph{concerns}
					relacionados con la eficiencia, mientras que una aplicación de \emph{e-commerce} es probable que le de más
					importancia a la seguridad.

					En el supuesto de que los \emph{Concerns} sean configurables por el usuario final, la función
					\verb@createMapWithEquallyDistributedWeights@ debería reubicarse en una clase del tipo \emph{helper} que tenga
					acceso de alguna manera al \verb@SelfHealingConfigurationManager@ que es el objeto que tendría acceso a la
					información presente en el archivo de configuración de \emph{self healing}.
					
				\item \textbf{Acceso del \emph{ArcoIrisAdaptationManager} a los \emph{Concerns}}

					Una situación similar a la anterior (el acceso al universo de \emph{Concerns} definidos en el sistema) ocurre
					también en el \verb@ArcoIrisAdaptationManager@:

					\begin{Verbatim}[gobble=6]
						public static boolean isConcernStillBroken(String concernString) {
							try {
								Concern concern = Concern.valueOf(concernString);
								...
					\end{Verbatim}

					El \verb@ArcoIrisAdaptationManager@ actualmente posee como colaborador interno a\\
					\verb@RainbowModelWithScenarios@, el cuál accede al \verb@SelfHealingConfigurationManager@, quién es el que
					puede proveer el acceso deseado a todos los \emph{Concerns} definidos en el sistema en un momento dado.
			\end{itemize}

	\subsection{Flexibilización del Entorno}
	\label{sec:flexibilizacionEntorno}

		Actualmente, el algoritmo que decide en qué entorno de ejecución se encuentra el sistema a adaptar en un
		determinado instante, presupone que las restricciones de todos los Entornos del sistema son mutualmente excluyentes
		entre sí. Esto tiene como principal consecuencia el hecho de que, al momento, no se pueden configurar Entornos que
		posean algún tipo de intersección en sus condiciones de aplicabilidad. En particular y a modo de ejemplo, el
		usuario querría poder especificar un escenario de ``Alta Carga'' y otro de ``Extrema Alta Carga'', cuyas condiciones
		de aplicabilidad podrían tener una intersección no nula pues probablemente las condiciones necesarias para
		que el entorno de ``Alta Carga'' se cumpla están incluídas en las condiciones el entorno de ``Extrema Alta Carga''.

		Es deseable que en el caso de entornos con intersección no nula en sus condiciones de aplicabilidad, Arco Iris
		seleccione a aquél que sea más adecuado, de acuerdo al caso en particular. En el ejemplo anterior, ``Extrema Alta
		Carga'' sería el elegido para representar más fielmente el estado actual del sistema. Esto sin duda es altamente
		relevante ya que los pesos configurados en cada uno de los escenarios pueden determinar el curso de la auto reparación
		puesto que afectan directamente al algoritmo de selección de estrategias.

		Una posible solución para este problema podría ser el explicitar relaciones de intersección (o de inclusión) entre
		restricciones y reconfigurar el algoritmo de detección del Entorno actual de ejecución existente en el
		\verb@ArcoIrisAdaptationManager@ para que el mismo elija aquel Entorno con condiciones más generales. A
		continuación, un pseudo-código del posible algoritmo que contempla \textbf{inclusión entre Entornos}:

		\begin{Verbatim}[gobble=3]
			función detectCurrentSystemEnvironment
				candidate = null;
				para cada ent en todos los entornos
					si ent aplica en las actuales condiciones de ejecución entonces
						si candidate == null entonces
							candidate = ent;
							siguiente iteración;
						fin si
				        si ent está incluido en candidate entonces
				        	candidate = ent;
				        fin si
				    is
				done
		\end{Verbatim}

	\subsection{Configuración de Escenarios en AcmeStudio}

		Actualmente existe una herramienta de creación y edición de arquitecturas modeladas en Acme, llamada
		\textbf{AcmeStudio} \footnote{Para más información acerca de AcmeStudio, visitar
		\url{http://www.cs.cmu.edu/~acme/AcmeStudio}} la cual se encuentra integrada en la popular herramienta de desarrollo
		Eclipse\footnote{Para más información acerca de Eclipse, visitar \url{http://www.eclipse.org}} como un \emph{plug-in}.

		Se propone como trabajo a futuro extender la herramienta AcmeStudio para que dé soporte a las extensiones propuestas
		en el presente trabajo, permitiendo así la integración del modelado de la arquitectura con el modelado de los
		escenarios y demás conceptos introducidos en Arco Iris, utilizando la misma herramienta.

		Dependiendo del grado de profundidad en el que se avance en la integración de Arco Iris con Acme Studio, se podría
		incluso especular con un reemplazo completo de la herramienta Arco Iris UI. Esta tarea no fue realizada en el
		contexto del presente trabajo debido a que el encarar el desarrollo de un \emph{plug-in} de Eclipse con estas
		características era una tarea de alta complejidad, que se encuentra afuera del alcance de este trabajo.

	\subsection{Optimización en la Selección de la Estrategia}

		En la sección \ref{sec:strategySelection} se describe en detalle el mecanismo de selección de la mejor estrategia para
		resolver una situación anómala en el sistema que se está adaptando. Este problema posee muchas aristas complejas,
		por lo tanto, una solución sofisticada requiere un trabajo de investigación que excede lo que se puede realizar en
		este trabajo. Esta idea fue además compartida por los investigadores de Carnegie Mellon que fueron consultados al
		inicio del presente trabajo.
		
		La solución propuesta aquí al problema de selección de la mejor estrategia de reparación, es una heurística simple
		basada en el uso del concepto de \textbf{utilidad del sistema}, el cuál, si bien es útil para reducir la dimensión del
		problema y poder avanzar en otros aspectos, es claramente una solución limitada, debido a que para el cálculo de esta
		utilidad se realizan muchos supuestos y simplificaciones sobre el contexto de ejecución del sistema y su correlato con
		el modelo de su arquitectura. Las oportunidades de mejora avisoradas por los autores de este trabajo pasan
		principalmente por implementar mecanismos de aprendizaje sobre qué es lo que funcionó y qué no en reparaciones		anteriores, por mecanismos dinámicos de modificación de los pesos de los \emph{concerns} y prioridades de los		escenarios en función del estado del sistema en un momento dado y finalmente por ajustes a las tácticas y estrategias		que se aplican.
	\subsection{Ausencia u Obsolescencia del Modelo de la Arquitectura}
	\label{sec:ausenciaObsolescenciaModeloArquitectura}

		Tanto Rainbow como Arco Iris hacen foco en disponer de un modelo (actualizado) de la arquitectura del sistema a
		adaptar pero en realidad, no siempre es posible disponer del mismo: puede no haber existido nunca o bien haber
		quedado desactualizado. Existen líneas de investigación que intentan derivar el modelo de la arquitectura a partir de
		un sistema, obteniendo información del mismo en \emph{runtime}. Uno de los proyectos tiene lugar en el contexto del
		grupo de investigación ABLE, el responsable de Rainbow y se llama \textbf{DiscoTect}. Para más información sobre
		dicho proyecto, visitar \url{http://www.cs.cmu.edu/~able/research/discotect.html}.

	\subsection{Adaptación de un Sistema Sobre el Cual se Tiene Poco Control}

		Otro de los tópicos sobre los cuales es necesario también avanzar, es en desarrollar técnicas y herramientas que
		permitan poder alterar el comportamiento de un sistema sobre el cuál se posee muy poco control. Tal es el caso, por
		ejemplo, de sistemas desarrollados por terceras partes, de los cuales no se posee ni siquiera el código fuente. Otro
		ejemplo podría ser el de sistemas pobremente modularizados o codificados con un lenguaje de programación antiguo sobre
		los cuáles parece poco probable que se puedan establecer puntos de comunicación con un \emph{framework} de auto
		adaptación como Arco Iris o Rainbow.
		
		Este tema es crítico para el desarrollo de la auto adaptación de sistemas de \emph{software} considerando que existen
		en el mundo numerosas aplicaciones que se encuentran en las condiciones descritas anteriormente. 

	\subsection{Mecanismo de Reparación ``declarativo''}

		Hasta el momento, en Rainbow y en Arco Iris, las estrategias de reparación se encuentran configuradas de una manera		imperativa, es decir, el arquitecto o una persona con ese rol, configura el \emph{framework} especificando una serie
		de estrategias de reparación, que no son más que algoritmos que intentan resolver o paliar una anomalía en el sistema
		basandose en observaciones sobre las propiedades del mismo en \emph{runtime} y en un conjunto de tácticas (e.g.
		levantar un servidor extra, disminuír el nivel de \emph{logging}, apagar la encripción, etc\ldots) también provistas
		por el usuario del \emph{framework}.
		
		Otra posibilidad menos programática y más declarativa podría consistir en que el usuario únicamente especifique, para
		un escenario, las tácticas que podrían ejecutarse en el caso en que el escenario no se cumpla; dejando al
		\emph{framework} la tarea de combinar ``inteligentemente'' dichas tácticas de la mejor manera posible. Es decir, el
		\emph{framework} debería poder ser capaz de manejar heurísticamente los recursos que posee para interactuar con el
		sistema en \emph{runtime}, de una manera similar a cómo se opera actualmente con estrategias estáticamente
		configuradas por el usuario.
		
		Lo antedicho agregaría flexibilidad puesto que el \emph{framework} no estaría acotado a un conjunto fijo de
		estrategias pre configuradas sino que podría intentar otras opciones dinámicamente, considerando la historia de sus
		ejecuciones pasadas, entre otros tantos aspectos posibles. Por otro lado, siempre que se agrega flexibilidad,
		normalmente se pierde en predictibilidad, ya que las acciones del \emph{framework} serían más difíciles de
		seguir y predecir.
