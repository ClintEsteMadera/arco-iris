\section{Trabajo Futuro}
\label{sec:trabajoFuturo}

	Si bien con la introducción de las extensiones presentes en Arco Iris se han presentado considerables mejoras con
	respecto al uso básico de Rainbow, también se han suscitado numerosos puntos de extensión posibles que si bien no
	pudieron formar parte del presente trabajo, es importante que los mismos sean detallados en pos de incentivar la
	investigación futura sobre los mismos. A continuación, citaremos los puntos de extensión posibles a Arco Iris y/o
	Rainbow.

	\subsection{Arco Iris: un \emph{plug-in} de Rainbow}
	
			Una característica deseable para Arco Iris es, sin duda, que la extensión se inserte en el \emph{framework}
			(conceptualmente hablando) de manera similar a cómo un \emph{plug-in} trabaja en cualquier otro sistema de
			\emph{software}, pudiendo el usuario, de manera relativamente simple, elegir entre utilizar los mecanismos de auto
			reparación provistos por Arco Iris o los de Rainbow.
			
			Para que esto sea posible, es necesario que Rainbow provea una arquitectura abierta a la extensión de sus componentes
			claves, como ser el \verb@AdaptationManager@, el \verb@RainbowModel@ y \verb@GaugeCoordinator@, entre otros.
			
			A continuación, se enumeran alguno de los motivos por los cuales Rainbow, en la actualidad, no permite extensiones de
			tipo \emph{plug-in}:
			\begin{enumerate}
				\item Rainbow no trabaja orientado a interfaces, tal como se Erich Gamma explica en \ref{DesignPatterns},
				observando así un alto acoplamiento entre las clases que conforman su diseño y la consecuente imposibilidad de
				cambiar las implementaciones por defecto por otras nuevas.
				\item El mecanismo utilizado por los componentes de Rainbow para obtener referencias a otros componentes con los que
				desean interactuar, implementado en una clase Java denominada \verb@Oracle@), es insuficiente para permitir la
				inyección de diferentes implementaciones del mismo componente. Esto es un error de diseño íntimamente relacionado
				con el punto anterior.
				\item Muchos de los componentes básicos de Rainbow, los cuales se modelan como clases Java, impiden explícitamente
				su extensión (i.e. herencia) mediante modificadores de acceso restrictivos.
			\end{enumerate}
			
			A modo de conclusión, sería muy positivo una reestructuración de Rainbow para permitir extensiones o agregados al
			mismo de una manera más prolija y ordenada que la que tuvo que utilizarse para la creación de Arco Iris.

	\subsection{Análisis y Aprendizaje de la Auto Reparación}

		\subsubsection{Herramientas de análisis y visualización}

			Supongamos que los \emph{stakeholders} ya han definido todos los escenarios que se utilizará Arco Iris para gestionar
			la auto adaptación de un sistema dado. Ahora bien, imaginemos que existe un escenario de muy alta prioridad y a su
			vez las condiciones necesarias para que no se cumpla se dan con mucha frecuencia. Esto posiblemente resulte en la
			auto reparación repetida del mencionado escenario. Pero, ¿qué sucedería si la única estrategia que repara dicho
			escenario ``rompe'' constantemente otros, digamos tres, escenarios de menor prioridad? A priori pareciera que este es
			el comportamiento esperado, pero\ldots ¿podrían los \emph{stakeholders} convalidar este comportamiento? Claramente la
			implementación actual de Arco Iris carece de una serie de \textbf{estadísticas y vistas} que permitan analizar lo que
			está siendo reparado, así también como el impacto sobre los escenarios perjudicados y sobre cada uno de los
			\emph{concerns} del sistema.
			
			También sería útil proveer una herramienta que permita analizar qué estrategias se fueron ejecutando históricamente,
			y de qué manera se llegó a decidir que cada una de ellas era la adecuada para reparar el sistema en cada momento.

		\subsubsection{Más Visibilidad Sobre Las Estrategias Fallidas}

			Rainbow provee un mecanismo que considera la historia de ejecución de las estrategias. El mismo es útil para que,
			dado un umbral predeterminado y no configurable por el usuario, aquellas estrategias que han fallado porcentualmente
			en un 95\% o más de las veces que fueron ejecutadas, no sean consideradas por el \verb@AdaptationManager@. El
			framework permite especificar al usuario si desea habilitar este mecanismo o no y, de estar habilitado, lleva un
			registro por estrategia de la historia de sus ejecuciones.
			
			El mecanismo contempla el paso del tiempo como un factor importante al momento de determinar el porcentaje de fallos:
			el cociente \[\frac{cantidad\_de\_fallos}{cantidad\_de\_ejecuciones}\]es sopesado con el tiempo que ha pasado desde
			la última ejecución de la estrategia, permitiendo así que la misma vuelva potencialmente a ser considerada en futuras
			ejecuciones.

			Si bien este mecanismo es bastante aceptable, el mismo podría ser mejorado en el futuro en dos aspectos:
			\begin{itemize}
				\item El porcentaje de fallas máximo permitido para que una estrategia pueda ser considerada debe ser configurado
				por el usuario final. La forma más simple de hacer esto es sencillamente externalizando este valor al archivo de
				configuración de la aplicación ya existente (\verb@rainbow.properties@).
				\item Este mecanismo provee poca visibilidad al usuario final. Una posible idea para analizar la
				configuración de la auto reparación del sistema podría ser un \textbf{\emph{ranking} de estrategias}, en el que se
				presente el porcentaje de éxito y fallas de cada una así como la cantidad de veces que se ejecutó, cómo quedó el
				\emph{Utility Function} en promedio luego de ejecutar la estrategia, etc.
				\item Otra posible idea podría ser el proveer una suerte de alarma al usuario administrador (vía e-mail por ejemplo)
				que, previamente a desactivar una estrategia o luego de haber desactivado reiteradas veces la misma estrategia,
				avise sobre este tipo de situaciones, haciendo explícito este tipo de decisiones cruciales y permitiendo así la
				rectificación o ratificación de la configuración de \emph{self healing} que está siendo utilizada.
			\end{itemize}

	\subsection{Ampliación de la Recarga Dinámica de Configuración}

		En la sección \ref{sec:actualizacionDinamicaConfig} se explicó el trabajo hecho en Arco Iris en materia de recarga
		automática de la configuración. Recordemos que se implementó un mecanismo que refresca la configuración relativa a
		Escenarios, Entornos, \emph{Artifacts} y las referencias a las estrategias asociadas a cada escenario. Si bien tal
		mecanismo representa una mejora sustancial con respecto a Rainbow (el cual recordemos que no provee ningún tipo de
		recarga ``en caliente'' de la configuración) entendemos que se puede dar un paso más en la materia, a fin de que el
		\emph{framework} resulte más útil para su uso en un ambiente tan dinámico como el de la industria del \emph{software};
		dónde el reiniciar la aplicación para aplicar un cambio en la configuración resulta muchas veces sencillamente
		inaceptable. En consecuencia, es altamente deseable tender a \textbf{recargar dinámicamente el 100\% de la
		configuración relacionada con auto reparación}. Los cambios necesarios para lograr ésto deben llevarse a cabo
		principalmente en Rainbow, dónde reside el grueso de la configuración estáticamente cargada.
		
		Rainbow actualmente maneja (a grandes rasgos) los siguientes puntos de configuración:
		\begin{itemize}
			\item el archivo \verb@rainbow.properties@, un típico archivo \verb@.properties@ de Java, el cual es leído una única
			vez al inicializarse el \emph{framework} y que sirve para externalizar propiedades tales como el nivel de \emph{log}
			deseado para la aplicación, el \emph{path} en dónde buscar estrategias y tácticas, el archivo .ACME con el modelo de
			la arquitectura del sistema a adaptar, etc. En este caso, sería relativamente sencillo implementar un mecanismo de
			recarga dinámica idéntico al explicado en detalle en la sección \ref{sec:actualizacionDinamicaConfig} para recargar
			la configuración de Arco Iris. El mismo tendría que ser realizado en el constructor de la clase \verb@Rainbow)@.
			\item \verb@utilities.yml@, dónde se configuran las curvas de utilidad para el sistema. Al igual que en el
			caso anterior, estas propiedades se leen en el constructor de la clase \verb@Rainbow@ utilizando una clase
			\emph{helper} llamada \verb@YamlUtil@. Utilizando el mismo mecanismo descrito anteriormente se podría dinamizar
			también la recarga dinámica de este archivo.
			\item archivos Stitch (con extensión \verb@.s@) de tácticas y estrategias. La lógica de lectura de tácticas
			y estrategias está ubicada en el \verb@AdaptationManager@. Puesto que en Arco Iris se necesitó extender esta clase,
			se aprovechó la oportunidad para abstraer esta lógica de lectura desde un archivo, a una clase específica llamada
			\verb@StitchLoader@, la cual tiene la responsabilidad no sólo de cargar los datos desde un archivo sino de proveer
			también acceso a los mismos. Sería una buena idea el incorporar esta clase al código base de Rainbow puesto que
			dicha abstracción provee la posibilidad de incorporar rápidamente el mecanismo de refresco mencionado ya reiteradas
			veces. Actualmente dicho comportamiento tampoco está incorporado en Arco Iris, no porque sea un trabajo difícil sino
			debido a que dicha tarea se encuentra afuera del alcance del presente trabajo.
		\end{itemize}
		
		Como podemos observar, el mecanismo explicado en detalle en la sección \ref{sec:actualizacionDinamicaConfig} es
		fácilmente reutilizable y también observamos posibilidades de mejora del mismo para simplificar aún más su uso
		extendido en todo el \emph{framework}.

	\subsection{Ampliación de la Configuración Existente}

		A lo largo del desarrollo del presente trabajo, hemos notado que existen numerosas posibilidades de ampliar la
		configuración existente tanto en Rainbow, en Arco Iris, como así también en Scenarios UI. Dividiremos los
		agregados/cambios a realizar de acuerdo a la aplicación en la cual deben hacerse.

		\subsubsection{Agregados a Rainbow}
		
			\todo{Externalizar MIN\_UTILITY\_THRESHOLD y FAILURE\_RATE\_THRESHOLD (Ver AdaptationManager.java)}
		
		\subsubsection{Agregados a Arco Iris}
		
			\begin{itemize}
				\item \todo{toda la config en un solo archivo? (estrategias, tácticas, .ACME --> embebidas en el XML)}
				\item \todo{agregar mas tipos de \emph{constraints}}
				\item \todo{Permitir agregar \emph{concerns} nuevos --> explicar el desafío que esto implica, no feasible por ahora}
			\end{itemize}
		
		\subsubsection{Agregados a Scenarios UI}
		
			\todo{leer los \emph{artifacts} y sus properties desde el .ACME}	
			
			\todo{tomar los estímulos referenciando al .acme?}
			
			\todo{editor de tácticas y estrategias?}
	
	\subsection{Flexibilización del Entorno}

		\todo{Expandir la idea del ``system environment'' (tenemos una implementación muy restrictiva, no se pueden solapar
		e.g. alta carga y super alta carga).}

	\subsection{Configuración de Escenarios en AcmeStudio}

		Actualmente existe una herramienta de creación y edición de arquitecturas modeladas en Acme, llamada
		\textbf{AcmeStudio} \footnote{Para más información acerca de AcmeStudio, visitar
		\url{http://www.cs.cmu.edu/~acme/AcmeStudio}} la cual se encuentra integrada en la popular herramienta de desarrollo
		Eclipse\footnote{Para más información acerca de Eclipse, visitar \url{http://www.eclipse.org}} como un \emph{plug-in}.

		Se propone como trabajo a futuro extender la herramienta AcmeStudio para que dé soporte a las extensiones propuestas
		en el presente trabajo, permitiendo así la integración del modelado de la arquitectura con el modelado de los
		escenarios que la complementan, utilizando la misma herramienta.

	\subsection{Optimización en la Selección de la Estrategia}

		\todo{A completar por TURCO: Se deja para el final: cómo seleccionar la mejor estrategia (Lo del ``utility function''
		es limitado)}

	\subsection{Scoring de Estrategias: Rainbow y Arco Iris ``en conjunto''}
	
		\todo{A completar por TURCO: hablar sobre arcoIrisSolutionWeight y rainbowSolutionWeight}
