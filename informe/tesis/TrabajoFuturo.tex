\section{Trabajo Futuro}
\label{sec:trabajoFuturo}

	Si bien con la introducción de las extensiones presentes en Arco Iris se han presentado considerables mejoras con
	respecto al uso básico de Rainbow, también se han suscitado numerosos puntos de extensión posibles que si bien no
	pudieron formar parte del presente trabajo, es importante que los mismos sean detallados en pos de incentivar la
	investigación futura sobre los mismos. A continuación, citaremos los puntos de extensión posibles a Arco Iris y/o
	Rainbow.

	\subsection{Arco Iris: un \emph{plug-in} de Rainbow}
	
			Una característica deseable para Arco Iris es, sin duda, que la extensión se inserte en el \emph{framework}
			(conceptualmente hablando) de manera similar a cómo un \emph{plug-in} trabaja en cualquier otro sistema de
			\emph{software}, pudiendo el usuario, de manera relativamente simple, elegir entre utilizar los mecanismos de auto
			reparación provistos por Arco Iris o los de Rainbow.
			
			Para que esto sea posible, es necesario que Rainbow provea una arquitectura abierta a la extensión de sus componentes
			claves, como ser el \verb@AdaptationManager@, el \verb@RainbowModel@ y \verb@GaugeCoordinator@, entre otros.
			
			A continuación, se enumeran alguno de los motivos por los cuales Rainbow, en la actualidad, no permite extensiones de
			tipo \emph{plug-in}:
			\begin{enumerate}
				\item Rainbow no trabaja orientado a interfaces, tal como se Erich Gamma explica en \ref{DesignPatterns},
				observando así un alto acoplamiento entre las clases que conforman su diseño y la consecuente imposibilidad de
				cambiar las implementaciones por defecto por otras nuevas.
				\item El mecanismo utilizado por los componentes de Rainbow para obtener referencias a otros componentes con los que
				desean interactuar, implementado en una clase Java denominada \verb@Oracle@), es insuficiente para permitir la
				inyección de diferentes implementaciones del mismo componente. Esto es un error de diseño íntimamente relacionado
				con el punto anterior.
				\item Muchos de los componentes básicos de Rainbow, los cuales se modelan como clases Java, impiden explícitamente
				su extensión (i.e. herencia) mediante modificadores de acceso restrictivos.
			\end{enumerate}
			
			A modo de conclusión, sería muy positivo una reestructuración de Rainbow para permitir extensiones o agregados al
			mismo de una manera más prolija y ordenada que la que tuvo que utilizarse para la creación de Arco Iris.

	\subsection{Análisis y Aprendizaje de la Auto Reparación}

		\subsubsection{Herramientas de análisis y visualización}

			Supongamos que los \emph{stakeholders} ya han definido todos los escenarios que se utilizará Arco Iris para gestionar
			la auto adaptación de un sistema dado. Ahora bien, imaginemos que existe un escenario de muy alta prioridad y a su
			vez las condiciones necesarias para que no se cumpla se dan con mucha frecuencia. Esto posiblemente resulte en la
			auto reparación repetida del mencionado escenario. Pero, ¿qué sucedería si la única estrategia que repara dicho
			escenario ``rompe'' constantemente otros, digamos tres, escenarios de menor prioridad? A priori pareciera que este es
			el comportamiento esperado, pero\ldots ¿podrían los \emph{stakeholders} convalidar este comportamiento? Claramente la
			implementación actual de Arco Iris carece de una serie de \textbf{estadísticas y vistas} que permitan analizar lo que
			está siendo reparado, así también como el impacto sobre los escenarios perjudicados y sobre cada uno de los
			\emph{concerns} del sistema.
			
			También sería útil proveer una herramienta que permita analizar qué estrategias se fueron ejecutando históricamente,
			y de qué manera se llegó a decidir que cada una de ellas era la adecuada para reparar el sistema en cada momento.

		\subsubsection{Más Visibilidad Sobre Las Estrategias Fallidas}

			Rainbow provee un mecanismo que considera la historia de ejecución de las estrategias. El mismo es útil para que,
			dado un umbral predeterminado y no configurable por el usuario, aquellas estrategias que han fallado porcentualmente
			en un 95\% o más de las veces que fueron ejecutadas, no sean consideradas por el \verb@AdaptationManager@. El
			framework permite especificar al usuario si desea habilitar este mecanismo o no y, de estar habilitado, lleva un
			registro por estrategia de la historia de sus ejecuciones.
			
			El mecanismo contempla el paso del tiempo como un factor importante al momento de determinar el porcentaje de fallos:
			el cociente \[\frac{cantidad\_de\_fallos}{cantidad\_de\_ejecuciones}\]es sopesado con el tiempo que ha pasado desde
			la última ejecución de la estrategia, permitiendo así que la misma vuelva potencialmente a ser considerada en futuras
			ejecuciones.

			Si bien este mecanismo es bastante aceptable, el mismo podría ser mejorado en el futuro en dos aspectos:
			\begin{itemize}
				\item El porcentaje de fallas máximo permitido para que una estrategia pueda ser considerada debe ser configurado
				por el usuario final. La forma más simple de hacer esto es sencillamente externalizando este valor al archivo de
				configuración de la aplicación ya existente (\verb@rainbow.properties@).
				\item Este mecanismo provee poca visibilidad al usuario final. Una posible idea para analizar la
				configuración de la auto reparación del sistema podría ser un \textbf{\emph{ranking} de estrategias}, en el que se
				presente el porcentaje de éxito y fallas de cada una así como la cantidad de veces que se ejecutó, cómo quedó el
				\emph{Utility Function} en promedio luego de ejecutar la estrategia, etc.
				\item Otra posible idea podría ser el proveer una suerte de alarma al usuario administrador (vía e-mail por ejemplo)
				que, previamente a desactivar una estrategia o luego de haber desactivado reiteradas veces la misma estrategia,
				avise sobre este tipo de situaciones, haciendo explícito este tipo de decisiones cruciales y permitiendo así la
				rectificación o ratificación de la configuración de \emph{self healing} que está siendo utilizada.
			\end{itemize}

	\subsection{Configuración Dinámica: Ampliación de la Configuración Existente}

		En la sección \ref{sec:actualizacionDinamicaConfig} se explicó el trabajo hecho en Arco Iris en materia de recarga
		automática de la configuración. Recordemos que se implementó un mecanismo que refresca la configuración relativa a
		Escenarios, Entornos, Artifacts y las referencias a las estrategias asociadas a cada escenario. Si bien tal mecanismo
		representa una mejora sustancial con respecto a Rainbow (el cual recordemos que no provee ningún tipo de recarga ``en
		caliente'' de la configuración) entendemos que se puede dar un paso más en la materia, a fin de hacerla más útil en un
		ambiente dinámico como el de la industria del \emph{software}: es altamente deseable \textbf{recargar dinámicamente el
		100\% de la configuración de Rainbow/Arco Iris}.
	
		Dividiremos los agregados/cambios a realizar de acuerdo a \emph{dónde} deben hacerse:
	
		\subsubsection{Agregados al archivo de configuración de Arco Iris}

		\subsubsection{Cambios en la carga de configuración de Rainbow}
		
		\subsubsection{Mejoras en Scenarios UI}

		\todo{Strategies y Tácticas, concerns, quality attributes, utilities.yml?}		 
		\todo{Externalizar MIN\_UTILITY\_THRESHOLD y FAILURE\_RATE\_THRESHOLD (Ver AdaptationManager.java)}
		\todo{Permitir agregar \emph{concerns} nuevos --> explicar el desafío que esto implica, no feasible por ahora}\\
		\todo{leer los \emph{artifacts} y sus properties desde el .ACME}\\
		\todo{agregar mas tipos de \emph{constraints}}\\
	
	\subsection{Flexibilización del Entorno}

		\todo{Expandir la idea del ``system environment'' (tenemos una implementación muy restrictiva, no se pueden solapar
		e.g. alta carga y super alta carga).}

	\subsection{Configuración de Escenarios en AcmeStudio}

		Actualmente existe una herramienta de creación y edición de arquitecturas modeladas en Acme, llamada
		\textbf{AcmeStudio} \footnote{Para más información acerca de AcmeStudio, visitar
		\url{http://www.cs.cmu.edu/~acme/AcmeStudio}} la cual se encuentra integrada en la popular herramienta de desarrollo
		Eclipse\footnote{Para más información acerca de Eclipse, visitar \url{http://www.eclipse.org}} como un \emph{plug-in}.

		Se propone como trabajo a futuro extender la herramienta AcmeStudio para que dé soporte a las extensiones propuestas
		en el presente trabajo, permitiendo así la integración del modelado de la arquitectura con el modelado de los
		escenarios que la complementan, utilizando la misma herramienta.

	\subsection{Optimización en la Selección de la Estrategia}

		\todo{Se deja para el final: cómo seleccionar la mejor estrategia (Lo del ``utility function'' es limitado)}

	\subsection{Scoring de Estrategias: Rainbow y Arco Iris ``en conjunto''}
	
		\todo{hablar sobre arcoIrisSolutionWeight y rainbowSolutionWeight}

		\todo{Turco: explicame cual es la gracia de usar todo nuestro mecanismo para luego scorear las estrategias con
		Rainbow. No le veo sentido.}
