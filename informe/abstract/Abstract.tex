\documentclass[11pt, a4paper, spanish]{article}

%%%%%%%%%% COMIENZO DEL PREAMBULO %%%%%%%%%%

%Info sobre este documento
\author{Jonathan Chiocchio, Gabriel Tursi}
\title{Abstract}

%\usepackage{infostyle}                                                  % provee un look & feel similar a un documento Word
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}  % márgenes
\usepackage[ansinew]{inputenc}                                           % permite que los acentos del estilo áéíóú salgan joya
\usepackage[spanish, activeacute]{babel}                                 % idioma español, acentos fáciles y deletreo de palabras
\usepackage{indentfirst}                                                 % permite indentar un parrafo a mano
\usepackage{caratula}                                                    % incluye caratula estándar
\usepackage{tabularx}                                                    % permite usar tablas mas inteligentes que con ``tabular''
\usepackage{multirow}                                                    % permite que una celda de una tabla se extienda verticalmente
\usepackage{graphicx}                                                    % permite insertar gráficos
\usepackage{color}                                                       % permite el uso de colores en el documento
\usepackage{url}                                                         % permite el uso de urls
\usepackage{ulem}                                                        % permite el poder tachar texto
\usepackage[pdfcreator={LaTeX2e},
			pdfauthor={Jonathan Chiocchio, Gabriel Tursi},
			pdftitle={Hacia un modelo m'as flexible para la implementaci'on de la auto reparaci'on de sistemas de software basada en Arquitectura},
			pdfsubject={Hacia un modelo m'as flexible para la implementaci'on de la auto reparaci'on de sistemas de software basada en Arquitectura},
			pdfkeywords={arquitecture design, self-healing, atam, rainbow, ACME},
			pdfstartview=FitH,            % Fits the width of the page to the window
			bookmarksnumbered,            % los bookmarks numerados se ven mejor...
			colorlinks,                   % links con bellos colores
			linkcolor=blue]								% permite cambiar el color de los links
			{hyperref}                    % Permite jugar con algunas cosas que aparecerán en el PDF final

\selectlanguage{spanish}

\linespread{1.3}                    % interlineado equivalente al 1.5 líneas de Word...
\pagestyle{myheadings}              % encabezado personalizable con \markboth{}{}
\markboth{}{}												% PONER TITULO PARA ENCABEZADOS DE PAGINAS(el nombre de la tesis es muy largo)
\headsep = 30pt                     % separación entre encabezado y comienzo del párrafo

%\addtolength{\oddsidemargin}{-2cm}	% configuracion IDEAL!!!
%\addtolength{\textwidth}{4cm}
%\addtolength{\textheight}{2cm}

% macros
\def\todo#1{\textcolor{red}{#1}}
\def\tachar#1{\textcolor{red}{\sout{#1}}}


% Macro 'borde' para un texto con borde
\newsavebox{\fmbox}
\newenvironment{borde}[1]
{\begin{lrbox}{\fmbox}\begin{minipage}{#1}}
{\end{minipage}\end{lrbox}\fbox{\usebox{\fmbox}}\\[10pt]}

%%%%%%%%%% FIN DEL PREAMBULO %%%%%%%%%%

\begin{document}

\normalem                            % Esto impide que el paquete ulem sobreescriba el formateo por defecto del comando ``emph''

\materia{Tesis de Licenciatura en\\[0.3em]Ciencias de la Computación}
\titulo{Hacia un modelo m'as flexible para la implementaci'on de la auto reparaci'on de sistemas de software basada en Arquitectura}
\subtitulo{Resumen extendido}
\integrante{Chiocchio, Jonathan}{849/02}{jchiocchio@gmail.com}
\integrante{Tursi, Germán Gabriel}{699/02}{gabrieltursi@gmail.com}
\director{Santiago Ceria}

\maketitle

\thispagestyle{empty}

\newpage

\section{Introducción}

	\subsection{Motivación para este trabajo}
		La complejidad creciente de los sistemas desafía de forma permanente el estado del arte de las Ciencias de la Computación y la Ingeniería del Software. La velocidad con la que se producen los cambios, la criticidad de las fallas que aparecen y la necesidad de mantener sistemas funcionando de manera continua a pesar de no pertenecer a lo que tradicionalmente se conoce como ``sistemas de misión crítica'' ha llevado a los investigadores a buscar novedosas formas de resolver estos desafíos. Una de ellas es la tendencia hacia los sistemas autónomos, que recibe distintos nombres como ``Computación Autómona'', ``Software consciente'' o ``Sistemas Auto–Reparables'' (o ``Self Healing'' en inglés). Existe una cantidad en aumento de especialistas en el mundo \cite{GAN/03} que creen que la necesidad de implementar este tipo de mecanismos está dando lugar al nacimiento de una nueva era en los sistemas de software.

		La idea subyacente detrás de estos nombres es que los sistemas incluyan mecanismos para ajustar su comportamiento a partir de fallas o necesidades cambiantes de sus usuarios y/o el entorno en el que operan. De esta forma, un sistema puede repararse u optimizarse sin intervención humana. Una de las formas de implementar estos mecanismos es la llamada ``Adaptación Basada en Arquitecturas''. En este tipo de soluciones, el sistema tiene un módulo que conoce su arquitectura, y, sobre la base de este conocimiento y el problema detectado, toma una decisión sobre cómo auto repararse.

	\subsection{Acme}
		\textbf{Acme}\cite{Acme} es un simple y genérico ADL (Architecture Description Language), es decir, un lenguaje para describir arquitecturas de sistemas de software, utilizando la vista de C\&C. (componentes y conectores) \textbf{Acme} está desarrollado por el grupo \textbf{Able}\cite{Able} de la Universidad de Carnegie Mellon (CMU) en Estados Unidos y fue pensado para proveer un formato común de intercambio entre distintos programas de diseño de arquitecturas; así también como para servir de base a futuros programas de este tipo.
		
	\subsection{Rainbow}		
		 Uno de los grupos más importantes en investigación en materia de auto-reparación es el proyecto \textbf{Rainbow}\cite{Rainbow}, enmarcado dentro del proyecto \textbf{Able}, también de la Universidad de Carnegie Mellon (CMU).
		 
		 Rainbow es un \emph{framework} desarrollado en Java cuya finalidad es proveer un mecanismo de adaptación basado en arquitecturas para sistemas de software. La adaptación es lograda a través de varios módulos que colaboran para lograr este objetivo. Estos son:

		\begin{itemize}
			\item \textbf{Monitor}: es el módulo que se encarga de obtener la información sobre el funcionamiento del sistema en tiempo de ejecución.
			\item \textbf{Evaluador de Restricciones}: es el que determina si el valor de alguna de las variables que se están monitoreando violó alguna de las restricciones planteadas (por ejemplo, que la \emph{performance} de un proceso dejó de ser aceptable).
			\item \textbf{Modelo de Arquitectura}: es el módulo que contiene una representación en el lenguaje \textbf{Acme} de la arquitectura del sistema que se quiere adaptar.
			\item \textbf{Manejador de Reparaciones}: es el módulo que se ocupa de determinar la forma en la que se va a “reparar” o “adaptar” el sistema en función de los problemas detectados.
			\item \textbf{Intérprete}: es el módulo que interpreta los cambios ocurridos en tiempo de ejecución y los ``traduce'' a cambios en el modelo de arquitectura.
			\item \textbf{Administrador de Runtime}: es el módulo que implementa en tiempo de ejecución el cambio en el comportamiento de la aplicación.
		\end{itemize}
	  
		Todos estos mecanismos funcionan de manera externa a la aplicación. Este enfoque tiene varias ventajas, siendo la principal el hecho de contar con un \emph{framework} reusable que pueda ser conectado a distintos tipos de aplicaciones para que implementen mecanismos de adaptación, minimizando el impacto en la aplicación.
		
		El caracter externo y no intrusivo de Rainbow representa una ventaja también cuando se desea implementar auto reparación en sistemas cuyo código fuente no está disponible o no es plausible de ser modificado.

		A pesar de intentar implementar un mecanismo genérico de auto-reparación, Rainbow tiene varios componentes con conocimiento fijo\footnote{Más conocido comúnmente como ``hardcodeado'' o ``cableado''.} sobre las reparaciones. Por ejemplo, cuáles son las tácticas para la reparación que se deben implementar cuando una determinada restricción es violada.
		
	\subsubsection{Ejemplo de auto-reparación con Rainbow}
		Dado que estos sistemas y sus conceptos son relativamente novedosos, proponemos un pequeño ejemplo de auto-reparación para afirmar conceptos:

		\begin{itemize}
			\item Supongamos que tenemos una aplicación Web que brinda servicios a millones de usuarios. Es crítico que el tiempo de respuesta ante un pedido de una página se mantenga dentro de rangos razonables.
			\item El sistema está compuesto por varias páginas, siendo la más crítica su página principal. Esta página está formada por varias ``partes'', cada una con su respectiva funcionalidad.
	    \item El \emph{Monitor} implementa un mecanismo de monitoreo del tiempo de respuesta del sistema ante un pedido, y lo informa al \emph{Intérprete}, el que a su vez se encarga de traducir dicha información en cambios en las propiedades del sistema. e.g.\\
	    ``el tiempo de respuesta fue 4.300 ms. $\Rightarrow$ \verb@client.experiencedResponseTime@ $\leftarrow$ \verb@4300@''
	    \item El \emph{Evaluador de Restricciones} determina si las restricciones del sistema siguen cumpliendose o no. Cuando no se respeta el tiempo máximo durante una predeterminada cantidad de veces, decide implementar una auto-reparación.
	    \item El \emph{Manejador de Reparaciones}, en función de su conocimiento de la arquitectura del sistema, decide \textbf{desactivar cierta funcionalidad de la página principal}, resignando funcionalidad para ganar en \emph{performance}.
	    \item Ese cambio se implementa a través del \emph{Administrador de Run-Time}.
	    \item  Al desactivar esa funcionalidad, la performance del sistema mejora.
		\end{itemize}

	\subsection{ATAM y QAW}
		Antes de profundizar en el objetivo de nuestro trabajo, es necesario explicar brevemente dos métodos existentes para analizar y razonar sobre arquitecturas de software y su relación con los atributos de calidad requeridos para un sistema. Estos métodos son importantes para el desarrollo de la tesis.
		
		\textbf{ATAM}\cite{ATAM}\cite{ATAM2} es el acrónimo para ``Architecture Tradeoff Analysis Method'', es decir, es un método de análisis de arquitecturas que hace foco en el balance que hay hacer al momento de tomar decisiones arquitectónicas para satisfacer ciertos atributos de calidad sin descuidar otros (esto es más conocido en la jerga como hacer ``trade-offs'') puesto que normalmente es virtualmente imposible satisfacer todos los atributos de calidad al mismo tiempo. (e.g. más seguridad o más flexibilidad usualmente conllevan a tener peor \emph{performance})

		Algunos de los objetivos más importantes ATAM son: analizar en una etapa temprana del desarrollo cómo las decisiones arquitecturales satisfacen los atributos de calidad requeridos para un sistema, así también como posibles riesgos, puntos sensibles y trade-offs entre ellas.
		
		Íntimamente ligado al método ATAM aparece otro método llamado \textbf{QAW} (Quality Attribute Workshop)\cite{QAW}. Un QAW es un método facilitado que relaciona los \emph{stakeholders} de un sistema de manera temprana en el ciclo de vida para descubrir los atributos de calidad clave en un sistema de software. En el mismo, los \emph{stakeholders} enuncian, discuten, refinan y priorizan \textbf{escenarios} reales de uso de la aplicación, especificando ciertas características de los mismos y lo que es más importante: el atributo de calidad involucrado en dicho escenario. Si bien más adelante ahondaremos en más detalle sobre el concepto de escenario, puesto que es clave en nuestra propuesta de trabajo, un ejemplo de escenario podría ser el siguiente:

		\begin{center}
			{\scriptsize
				\begin{tabularx}{0.9\linewidth}{|l|l|X|}
					\hline
					\multicolumn{ 2}{|l|}{\textbf{Escenario:}} & \textbf{Cuando el sensor de la puerta de un garage detecta a un objeto cerca de la puerta, detiene la misma en menos de un milisegundo.} \\
					\hline
					\multicolumn{ 2}{|l|}{\textbf{Atributos de Calidad relevantes:}} & Seguridad, performance \\
					\hline
					\multirow{7}{*}{\rotatebox{90}{\parbox{2.8cm}{\bf Componentes del Escenario}}} & \textbf{Estímulo:} & Un objeto está en un radio cercano a la puerta de un garage.\\
					\cline{2-3}
					& \textbf{Fuente del Estímulo:} & Un objeto externo al sistema, tal como una bicicleta. \\
					\cline{2-3}
					& \textbf{Entorno:} & La puerta del garage está cerrandose. \\
					\cline{2-3}
					& \textbf{Artefacto (si se conoce):} & Sensor de movimiento del sistema, componente software de control de movimiento. \\
					\cline{2-3}
					& \textbf{Respuesta Esperada:} & La puerta del garage se detiene. \\
					\cline{2-3}
					& \textbf{Medida de la respuesta:} & 1 (un) milisegundo.\\
					\hline
				\end{tabularx}
			}
		\end{center}

\section{Alcance de la tesis}
	\subsection{Idea Básica}
		La idea de esta tesis es extender el \emph{framework} Rainbow para poder lograr una implementación más flexible y poderosa del mecanismo de auto-reparación, ofreciendo a su vez la posibilidad de hacer visible dicho mecanismo a los \emph{stakeholders} de la aplicación, permitiéndoles involucrarse en la definición de escenarios de uso real del sistema y su relación con los atributos de calidad requeridos para el mismo; y en la definición de prioridades de los escenarios y/o estrategias a considerar en la auto-reparación del sistema cuando uno de los escenarios no se cumple.
		
		Lo antedicho se pretende lograr con cambios importantes en varios de sus módulos. A continuación se detallan los cambios propuestos.

	\subsection{Cambios en el \emph{Modelo de Arquitectura}}
		Actualmente Rainbow posee conocimiento sobre la arquitectura del sistema a adaptar mediante su modelo de arquitectura expresado en \textbf{Acme}. Uno de los objetivos de este trabajo es extender el conocimiento que el framework de reparación tiene sobre el sistema en general. Para eso, en el módulo de \textbf{Modelo de Arquitectura}, se implementarán las siguiente mejoras:

			\begin{enumerate}
          \item Incluir información sobre los atributos de calidad que la arquitectura implementa y que son relevantes \emph{para el o los stakeholders del sistema} en tiempo de ejecución. Por ejemplo, poder describir la importancia (relativa) de la \emph{performance}, la usabilidad, la disponibilidad, etc.
          
          Nuestro enfoque para lograr esto consiste en especificar \textbf{Escenarios de Atributos de Calidad} (de ahora en más, simplemente ``Escenarios'' ++ Pongan referencia al libro de BAss y Clements, Capítulo 4)+++), tal cual fueron descriptos en la sección anterior, aunque con algunos agregados de información orientados a la auto reparación.

          Un Escenario modela una situación concreta y real de uso del sistema ante la cual el mismo debe comportarse de una manera esperada. Los escenarios están compuestos por la siguiente información:
					\begin{itemize}
		          \item Fuente del Estímulo
		          \item Estímulo
							\item Artefacto
		          \item Entorno
		          \item Respuesta
		          \item Cuantificación de la Respuesta
					\end{itemize}
		
					\indent De todos estos atributos, son particularmente importantes el \textbf{Estímulo}, \textbf{Artefacto}, el \textbf{Entorno} y la \textbf{Cuantificación de la Respuesta}.
					
					El \textbf{Estímulo} normalmente se asocia a un evento desencadenado en el Artefacto del escenario, que a su vez se encuentra asociado a un componente \emph{runtime} del sistema que se está adaptando.
					
					El \textbf{Artefacto} se refiere al componente, subsistema o parte del sistema afectada por el escenario. Dado que en Acme se especifican los componentes y conectores del sistema, el escenario tendría entonces una vinculación directa en la especificación con los componentes afectados.

					El \textbf{Entorno} condiciona la aplicación del escenario en cuestión a que el sistema se encuentre en un determinado estado. Por ejemplo, se especifica un escenario dónde se dice como el sistema debe responder ante un \emph{request} de determinado tipo, \textbf{en un entorno de alta carga}.

					La \textbf{Cuantificación de la Respuesta} es también importante ya que de ella surgen las restricciones que deben ser evaluadas por el \emph{Evaluador de Restricciones}. Al hacer estos cambios, las restricciones que se usaban anteriormente en Rainbow pasarían a ser en realidad una parte de un Escenario de Atributo de Calidad.
					\item Asignar prioridades a estos escenarios, para que a la hora de escoger una estrategia de auto-reparación, se tengan en consideración otros aspectos del sistema (especificados como atributos de calidad) de modo tal que la estrategia de reparación elegida no comprometa a alguna otra funcionalidad de la aplicación considerada más importante para el usuario.
					
					\item Asociar las estrategias de reparación a los escenarios. Por ejemplo, un escenario podría incluir información del estilo ``Si este escenario se ve comprometido, implementar tal reparación''. Esto agrega la ventaja de que ahora, gracias a los escenarios, los problemas y sus posibles soluciones (i.e. estrategias de reparación), pueden ser visibles a los usuarios y stakeholders de la aplicación. Dichas estrategias (serían más de una, ordenadas por prioridad al igual que los escenarios) poseen la información necesaria para que el \textbf{Manejador de Reparaciones} pueda simular su aplicación y estimar cómo quedaría el sistema luego de haber aplicado dicha estrategia. (estimación de la nueva ``utilidad del sistema''). Cabe aclarar que la ``utilidad del sistema'' es una función que se calcula a partir del cumplimiento o no de los escenarios requeridos por los stakeholders, teniendo en cuenta sus prioridades relativas. 		
			\end{enumerate}

	\subsection{Cambios en el \emph{Evaluador de Restricciones}}
		Debido a que, con este nuevo enfoque, todo pasa por el concepto de escenario, es necesario establecer cambios en la lógica de evaluación de restricciones (o invariantes) del sistema. Dichas restricciones ya no estarían más embebidas en los componentes de la arquitectura (modelados con ACME) sino que las \emph{constraints} a evaluar serían aquellas presentes en la cuantificación de la respuesta de cada escenario.
		
		Ante la invocación de un estímulo en el sistema en ejecución, el \textbf{Monitor} del sistema informa de esta situación al \textbf{Intérprete}, que a su vez actualiza las propiedades del modelo de la arquitectura (recordemos: en ACME) e invoca finalmente al \textbf{Evaluador de Restricciones} para que busque aquellos escenarios que posean al estímulo ejecutado y que estén definidos para el \textbf{Entorno} de ejecución actual y que las restricciones asociadas a sus \textbf{Cuantificaciones de Respuesta} no se cumplan. Aquellos escenarios que cumplan dichas condiciones serán aquellos escenarios que el Manejador de Reparaciones deberá intentar reparar.

	\subsection{Cambios en el \emph{Manejador de Reparaciones}}
    El módulo \emph{Manejador de Reparaciones} se modificará para que utilice el conocimiento plasmado en los escenarios para optar por la estrategia de reparación a aplicar, teniendo en cuenta:
    \begin{itemize}
			\item el estado del sistema actual,
			\item el atributo de calidad asociado al escenario,
			\item el entorno de aplicación del mismo y
			\item las prioridades relativas de los escenarios
		\end{itemize}
		El objetivo final es, además de reparar el inconveniente hallado, evitar perjudicar algún otro escenario de mayor prioridad y mediante el uso de heurísticas, poder aproximar la mejor estrategia de reparación a llevar a cabo de modo que la \emph{utilidad del sistema} se maximize.

	\subsection{Desarrollo de una GUI}
		Se propone el desarrollo de una interfaz de usuario gráfica (GUI, de sus siglas en inglés: Graphical User Interface) para que los distintos \emph{stakeholders} (incluyendo usuarios y arquitectos) puedan colaborar creando y editando escenarios que luego serán importados y utilizados por Rainbow.


	\subsection{Eliminación de limitaciones}
		En la implementación actual de Rainbow, la cantidad de restricciones evaluada es fija. En nuestra versión, los stakeholders podrán cargar una cantidad ilimitada de escenarios y cambiar prioridades relativas y posibles estrategias de reparación. Esto hará que sólo el sistema pueda evaluar correctamente todos los factores a tener en cuenta al momento de aplicar la auto-reparación.


	\subsection{Resúmen}
		En resumidas palabras, el alcance del trabajo consiste en:

		\begin{itemize}
	    \item Definir las siguientes extensiones:
				\begin{itemize}
	          \item Posibilidad de modelar escenarios de atributos de calidad siguiendo los principios de ATAM y QAW.
	          \item Posibilidad de relacionar escenarios con componentes de la arquitectura.
	          \item Posibilidad de especificar prioridades relativas entre escenarios, a ser utilizadas en la elección de la estrategia de reparación a ejecutar.
	          \item Posibilidad de modelar estrategias de reparación y asociarlas a escenarios.
	          \item Posibilidad de definir Entornos de ejecución para el sistema, los cuales tengan un papel clave en el algoritmo de elección de estrategias de reparación.
				\end{itemize}          
	    \item Proponer los cambios en el \emph{Manejador de Reparaciones} y el \emph{Evaluador de Restricciones} de Rainbow, e implementar algunos casos prácticos que permitan mostrar cómo esta estrategia puede funcionar y llevar a un framework de adaptación más flexible y poderoso.
		\end{itemize}

		\todo{Plantear la coexistencia de Rainbow with Scenarios con el Rainbow de siempre? Si hacemos eso, podríamos poner el diagramita ``Rainbow Architecture With Scenarios'' hecho en Enterprise Architect...}

CREO QUE PONDRIA UNA FRASE DEL ESTILO. SE EVALUARA LA FACTIBILIDAD DE PERMITIR QUE LA NUEVA VERSION DE RAINBOW SEA COMPATIBLE CON LA ANTERIOR.

				
		Todo lo antedicho tiene como consecuencia que los usuarios tendrán más herramientas para influir sobre lo que el sistema decida hacer para auto-repararse: sólo con modificar la información de los escenarios el sistema modificará su comportamiento. Como contrapartida, las extensiones propuestas en este trabajo hacen que el sistema se comporte de manera más autónoma a medida que se agregan escenarios; esto paradójicamente le quita control al usuario, ya que el procedimiento de auto-reparación se vuelve más complejo, complicando el seguimiento de las decisiones tomadas por el \emph{framework}.
		
		Por otro lado, luego de la extensión, muchos aspectos del framework de auto-reparación serán más automáticos y no estarán tan fijos como lo están actualmente en Rainbow. Asímismo, se agregan nuevos conceptos que amplían la participación y visibilidad de los usuarios, lo que conlleva múltiples beneficios asociados.

\section{Trabajo a futuro}
	Actualmente existe una herramienta de creación y edición de arquitecturas modeladas en Acme, llamado AcmeStudio\cite{AcmeStudio} la cual se encuentra integrada en la popular herramienta de desarrollo Eclipse\cite{Eclipse} como un \emph{plug-in}.

	Se propone como trabajo a futuro extender la herramienta AcmeStudio para que dé soporte a las extensiones propuestas en el presente trabajo, permitiendo así la integración del modelado de la arquitectura con el modelado de los escenarios que la complementan, utilizando la misma herramienta.

	CREO QUE NO ENUMERARIA TODAS LAS PUNTAS... SIMPLEMENTE DIRIA QUE NUESTRO TRABAJO VA A DEJAR MUCHAS POSIBLES MEJORAS QUE SERAN NECESARIAS ANTES DE LA IMPLEMENTACION DE ESTOS FRAMEWORKS COMO HERRAMIENTAS DE USO GENERALIZADO EN LA INDUSTRIA.

	\todo{Enumerar las posibles ``puntas''???}
\newpage

\begin{thebibliography}{99}
	\bibitem{GAN/03} Ganek, Alan G. y Corbi, Thomas A. The dawning of the autonomic computing era. IBM Syst. J., 42(1):5-18, 2003. ISSN 0018-8670.\\
	\url{http://www.cs.cmu.edu/~garlan/17811/Readings/ganek.pdf}

	\bibitem{Rainbow} Proyecto Rainbow de la Universidad de Carnegie Mellon.\\
	\url{http://www.cs.cmu.edu/~able/research/rainbow/}

	\bibitem{Able} Proyecto Able de la Universidad de Carnegie Mellon.\\
	 \url{http://www.cs.cmu.edu/~able}

	\bibitem{Acme} Proyecto Acme de la Universidad de Carnegie Mellon.\\
	 \url{http://www.cs.cmu.edu/~acme}

	\bibitem{ATAM} ATAM: Method for Architecture Evaluation, Software Engineering Institute (SEI)\\
	 \url{http://www.sei.cmu.edu/library/abstracts/reports/00tr004.cfm}
	 
	\bibitem{ATAM2} The Architecture Tradeoff Analysis Method (ATAM), Software Engineering Institute (SEI)\\
	 \url{http://tinyurl.com/ye5ub9l}

	\bibitem{QAW} Quality Attribute Workshops (QAWs), Third Edition, Software Engineering Institute (SEI)\\
	 \url{http://www.sei.cmu.edu/library/abstracts/reports/03tr016.cfm}
	 
	\bibitem{AcmeStudio} Acme Studio Tool, Software Engineering Institute (SEI)\\
	 \url{http://www.cs.cmu.edu/~acme/AcmeStudio/}

	\bibitem{Eclipse} Eclipse Platform\\
	 \url{http://www.eclipse.org/}

\end{thebibliography}

\end{document}